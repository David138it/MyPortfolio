Mail for feedback: David138it@gmail.com

Web Server on CPU
    Task:
    To create a CPU-based web server. here I am learning how to create a web server on the CPU
    Decision:
    запустить QT creator - открыть проект с расширением .pro - указать правильный путь в библиотеку OpenCL в расширении .pro - запустить проект - после запуска запустить любой браузер - в адресную строку ввести адрес вашей локальной машины с портом 8080 - например так: 192.168.0.2:8080 - узнать ip адрес командой ipconfig
    https://github.com/David138it/MyPortfolio/tree/main/TaskDecision/Engineer-Isu/Cpp/WebServerCpu/
    Source:
    https://www.youtube.com/playlist?list=PLlqeq-isbP97wcBzq4YhOfaEHY59gGyQx

Матрица
    Decision:
    #include <GL/glut.h>
    #include <iostream>
    using namespace std;
    struct Ch{
        Ch(char ach=' ', int alive=0):
            ch(ach),
            live(alive)
        {}
        char ch;
        int live;
    };
    const int W=852/9;
    const int H=480/15;
    Ch screen[W][H];
    void display(){
        glClear(GL_COLOR_BUFFER_BIT);
        for(int y=0; y<H; ++y){
            for(int x=0; x<W; ++x){
                glRasterPos2f(x*9, (y+1)*15);
                glColor3f(0, screen[x][y].live/10000.0, 0);
                glutBitmapCharacter(GLUT_BITMAP_9_BY_15, screen[x][y].ch);
            }
        }
        glutSwapBuffers();
    }
    void timer(int=0){
            for(int y=0; y<H; ++y){
                for(int x=0; x<W; ++x){
                if(screen[x][y].live>0){
                    --screen[x][y].live;
                }
            }
        }
        int x=rand()%W;
        for(int y=0; y<H; ++y){
            if(screen[x][y].live<=0){
                screen[x][y].ch=rand()%256;
                screen[x][y].live=10000;
                break;
            }
        }
        glutPostRedisplay();
        glutTimerFunc(0, timer, 0);
    }
    int main(int argc, char **argv){
        glutInit(&argc, argv);
        glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB);
        glutInitWindowSize(852, 480);
        glutInitWindowPosition(0, 86);
        glutCreateWindow("Metrix Code");
        glClearColor(0, 0, 0, 1.0);
        glMatrixMode(GL_PROJECTION);
        glLoadIdentity();
        glOrtho(0, 852, 480, 0, -1, 1);
        glutDisplayFunc(display);
        timer();
        glutMainLoop();
        /*for(unsigned wchar i=' '; i<500; ++i){
            wcout<<(wchar)i;
        }*/
    }

Телефонный справочник
    Task:
    Address Book. here I am learning how to create a program with a graphical application Address Book - a telephone directory using Model View Controller
    Decision:
    https://github.com/David138it/MyPortfolio/tree/main/TaskDecision/Engineer-Isu/Cpp/AddressBook/
    Source:
    1. https://www.youtube.com/playlist?list=PLvItDmb0sZw_l5qKMLTjePXX485CWKVNe
    Task:
    Я заранее создал список имен c телефонными номерами в файле file.txt. Нужно создать такую программу, что бы при вводе имени на консоле выдавался номер нужного человека. Сделаю я это с помощью вектора.
    Decision:
    #include<iostream>
    #include<fstream>
    #include<vector>
    #include<string>
    using namespace std;
    class Number{
    public:
        string name;
        string number;
        Number (const Number &v):
            name(v.name),
            number(v.number){}
        Number(){}
        const Number &operator=(const Number &v){
            name=v.name;
            number=v.number;
            return v;
        }       
    };
    int main(){
        fstream f("file.txt");
        vector<Number> telBook;
        while(true){
            Number t;
            f>>t.name;
            if(f.eof()){
                break;
            }
            f>>t.number;
            if(f.eof()){
                break;
            }
            telBook.push_back(t);
        }
        while(true){
            cout<<"Введите имя (или стоп)";
            string name;
            cin>>name;
            if(name=="стоп"){
                break;
            }
            for(int i=0;i<telBook.size(); ++i){
                if(telBook[i].name==name){
                    cout<<name<<" "<<telBook[i].number<<endl;
                }
            }
        }
    }

Физика
    Task:
    работа с мышью
    Decision:
    #include <GL/glut.h>
    #include <cstdlib>
    #include <cmath>
    using namespace std;
    int x=0, y=0;
    bool down=false;
    const int N=100;
    struct P{
        float x, y, vx, vy, r, g, b;
    }p[N];
    void display(){
        glClear(GL_COLOR_BUFFER_BIT);
        glPointSize(5);
        glBegin(GL_POINTS);
        for(int i=0; i<N; ++i){
            glColor3f(p[i].r, p[i].g, p[i].b);
            glVertex2f(p[i].x, p[i].y);
        }
        glEnd();
        glutSwapBuffers();
    }
    void timer(int=0){
        display();
        for(int i=0; i<N; ++i){
            p[i].x+=p[i].vx;
            p[i].y+=p[i].vy;
            if (down){
                float d=sqrt((p[i].x-x)*(p[i].x-x)+(p[i].y-y)*(p[i].y-y));
                p[i].x+=5*(x-p[i].x)/d;
                p[i].y+=5*(y-p[i].y)/d;
            }
        }
        glutTimerFunc(10, timer, 0);
    }
    void mouse(int button, int state, int ax, int ay){
        x=ax;
        y=ay;
        down=state==GLUT_DOWN;
    }
    void motion(int ax, int ay){
        x=ax;
        y=ay;
    }
    int main(int argc, char **argv){
        for(int i=0; i<N; ++i){
            p[i].x=rand()%480;
            p[i].y=rand()%480;
            p[i].vx=rand()%480/100.0-2.4;
            p[i].vy=rand()%480/100.0-2.4;
            p[i].r=rand()%200/200.0;
            p[i].g=rand()%200/200.0;
            p[i].b=rand()%200/200.0;
        }
        glutInit(&argc, argv);
        glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB);
        glutInitWindowSize(480, 480);
        glutInitWindowPosition(20, 1050-480-20);
        glutCreateWindow("Knight tour");
        glClearColor(0, 0, 0, 1.0);
        glMatrixMode(GL_PROJECTION);
        glLoadIdentity();
        glOrtho(0, 480, 480, 0, -1, 1);
        glutDisplayFunc(display);
        timer();
        glutMouseFunc(mouse);
        glutMotionFunc(motion);
        glutMainLoop();
    }
    Task:
    Моделирование гравитации
    Decision:
    #include<GL/glut.h>
    #include<cmath>
    struct Particle{
        float x, y, vx, vy, m;
    };
    const int N=4;
    Particle particles[N];
    void display(){
            glClear(GL_COLOR_BUFFER_BIT);
            glBegin(GL_POINTS);
        for(int i=0; i<N; ++i){
            glVertex2f(particles[i].x, particles[i].y);
        }
            glEnd();
            glutSwapBuffers();
    }
    void timer(int=0){
        for(int i=0; i<N; ++i){
            Particle &p0=particles[i];
            for(int j=0; j<N; ++j){
                if(j==i){
                    continue;
                }
                const Particle &p=particles[j];
                float d=sqrt((p0.x-p.x)*(p0.x-p.x)+
                        (p0.y-p.y)*(p0.y-p.y));
                if(d>3){
                    p0.vx+=0.0007*p.m/d/d*(p.x-p0.x)/d;
                                    p0.vy+=0.0007*p.m/d/d*(p.y-p0.y)/d;
                }
            }
            p0.x+=p0.vx;
            p0.y+=p0.vy;

        }
            display();
            glutTimerFunc(1,timer,0);
    }
    int main(int argc, char **argv){
        particles[0].x=100;
        particles[0].y=100;
        particles[0].vx=0;
        particles[0].vy=0;
        particles[0].m=1000;
            particles[1].x=130;
            particles[1].y=100;
            particles[1].vx=0;
            particles[1].vy=-0.1;
            particles[1].m=7;
            particles[2].x=30;
            particles[2].y=100;
            particles[2].vx=0;
            particles[2].vy=0.1;
            particles[2].m=10;
            particles[3].x=25;
            particles[3].y=100;
            particles[3].vx=0;
            particles[3].vy=0.11;
            particles[3].m=0.1;
        glutInit(&argc, argv);
            glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB);
            glutInitWindowSize(200,200);
            glutInitWindowPosition(20,810);
            glutCreateWindow("Gravitation");
            glClearColor(0,0,0,1.0);
            glMatrixMode(GL_PROJECTION);
            glLoadIdentity();
            glOrtho(0,200,200,0,-1,1);
            glutDisplayFunc(display);
            timer();
            glutMainLoop();
    }

Строки
    Task:   
    Дан String с кучей символами, напиши код который вернет самый длинный substring без повторяющихся символов
    input: "aaaabbbbbvvvxvxxzzzzrgdsbbbdddvcc"
    output: "zrgdsb"
    Source:
    1. https://www.youtube.com/playlist?list=PLg5SS_4L6LYuu1RAT4l1tCkZrJzkIaNgL
    Task:
    определить длину строки
    Decision:
    #include<stdio.h>
    #include<string.h>
    void main()
    {
        char S[]="This is string";
        printf("%d",strlen(S));
    } 
    Task:
    Склонение слов
    Decision:
    #include <iostream>
    using namespace std;
    int main(){
        cout<<"Введите кoличество пирожков: ";
        int n;
        cin>>n;
        cout<<"Я собираюсь съесть "<<n;
            int o=n%100;
        if((o>10)&&(o<20)){
            cout<<" .";
        }
        else{
            switch(o%10){
                case 0:
                    cout<<" пирожков.";
                    break;
                case 1:
                    cout<<" пирожок.";
                    break;
                case 2:
                case 3:
                case 4:
                    cout<<" пирожка.";
                    break;
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                    cout<<" пирожков.";
                    break;
            }
        }
        cout<<endl; 
    }

Геометрия
    Task:
    Вращающийся куб
    Decision:
    #include <GL/glut.h>
    //#include <GL/freeglut.h>
    void display(){
        glClear(GL_COLOR_BUFFER_BIT);
        glRotatef(1,1,1,0);
        glBegin(GL_LINE_STRIP);
        glVertex3f(-50, -50, -50);
        glVertex3f(50, -50, -50);
        glVertex3f(50, 50, -50);
        glVertex3f(-50, 50, -50);   
        glVertex3f(-50, -50, -50);
        glEnd();
            glBegin(GL_LINE_STRIP);
            glVertex3f(-50, -50, 50);
            glVertex3f(50, -50, 50);
            glVertex3f(50, 50, 50);
            glVertex3f(-50, 50, 50); 
            glVertex3f(-50, -50, 50);
            glEnd();
            glBegin(GL_LINES);
            glVertex3f(-50, -50, 50);
            glVertex3f(-50, -50, -50);
            glVertex3f(50, -50, 50);
            glVertex3f(50, -50, -50); 
            glVertex3f(50, 50, 50);
        glVertex3f(50, 50, -50);
        glVertex3f(-50, 50, 50);
        glVertex3f(-50, 50, -50);
            glEnd();

        glutSwapBuffers();
    }
    void timer(int=0){
        display();
    glutTimerFunc(10, timer, 0);
    }
    int main(int argc, char **argv){
        glutInit(&argc, argv);
        glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB);
        glutInitWindowSize(200, 200);
        glutInitWindowPosition(20, 810);
        glutCreateWindow("Cube");
        glClearColor(0,0,0,1.0);
        glMatrixMode(GL_PROJECTION);
        glLoadIdentity();
        glOrtho(-100, 100, -100, 100, -100, 100);
        glutDisplayFunc(display);
        timer();
        glutMainLoop();
    }
    Task:
    Две функции, синус и косинус, должны отображаться на одном графике при изменении аргумента функции в диапазоне от 0 до 10 радиан. Графики должны представлять собой ломаные линии, проходящие через узловые точки. Шаг узлов должен быть задан с помощью графического интерфейса. Необходимо выполнить полную разметку осей (ординат и абсцисс). Каждая функция должна использовать свой собственный стиль строки. Необходимо организовать рисование подписи к графику.
    Decision:
    https://github.com/David138it/MyPortfolio/tree/main/TaskDecision/Engineer-Isu/Cpp/Graphics/
    Task:
    Составить программу, принимающую с клавиатуры декартовы координаты точки и печатающую сферические координаты. Преобразование координат должно быть выполнено функцией типа void по формулам
    Decision:
    #include<stdio.h>
    #include<math.h>
    /*void sphere(double x, double y, double z, double *r, double *q, double *fi)
    {
        int a;
        *r=sqrt(x*x+y*y+z*z);
        *q=acos(z/(*r));
        if (x!=0){
            *fi=atan(y/x);
        }
    }
    void main(void)
    {
        double x, y, z, r, q, fi;
        printf("x=");scanf("%lf",&x);
        printf("y=");scanf("%lf",&y);
        printf("z=");scanf("%lf",&z);
        sphere(x, y, z, &r, &q, &fi);
        printf("%lf\n%lf\n%lf\n",r,q,fi);
    }*/
    const double pi=3.1415927;
    void sphere(double x, double y, double z, double *r, double *q, double *fi)
    {
        int a;
        *r=sqrt(x*x+y*y+z*z);
        *q=acos(z/(*r))*180.0/pi;
        if (x!=0){
            *fi=atan(y/x)*180.0/pi;
        }
    }
    void main(void)
    {
        double x, y, z, r, q, fi;
        printf("x=");scanf("%lf",&x);
        printf("y=");scanf("%lf",&y);
        printf("z=");scanf("%lf",&z);
        sphere(x, y, z, &r, &q, &fi);
        printf("%lf\n%lf\n%lf\n",r,q,fi);
    }
    Task:
    нам нужно создать функцию, которая принимает в качестве аргументов полярные координаты точки p и ф и передает в вызывающую эту функцию программу декартовы координаты точки Х и У, вычисляемые по формулам: *X=p*Cos(ф), Y=p*Sin(ф)
    Decision:
    #include<stdio.h>
    #include<math.h>
    const double pi180=3.1415927/180;
    void DECART(double r, double f, double *x, double *y)
    {
        *x=r*sin(f*pi180);
        *y=r*cos(f*pi180);
    }
    void main()
    {
        double r,f,x,y;
        scanf("%lf %lf",&r,&f);
        DECART(r,f,&x,&y);
        printf("%lf %lf",x,y);
    }
    Task:
    Для вводимого с консоли значения вещественной переменной а, напечатать таблицу значений функций вида:
    sin(a)=...
    arccos(a)==...
    ехр(a).==...
    ln(a)=^...
    ceil(a)=...
    floor(a)=...
    sqrt(a)=…
    pow(2,a)=...
    На месте a должно отображаться число, введенное с клавиатуры, на месте ... - значение соответствующей функции. 
    Decision:
    #include<stdio.h>
    #include<curses.h>
    #include<math.h>
    const float Pi=3.1415927;
    void main()
    {
      float a;
      a=30.0;
      printf("Напишите число: "); scanf("%f",&a);
      printf("sin(a)=%4.2lf\n",sin(a*Pi/180.0));
      printf("arccos(a)=%4.2lf\n",acos(a*Pi/180.0));
      printf("exp(a)=%4.2lf\n",exp(a));
      printf("ln(a)=%4.2lf\n",log(a));
      printf("ceil(a)=%4.1lf\n",ceil(a));
      printf("floor(a)=%4.1lf\n",floor(a));
      printf("sqrt(a)=%4.2lf\n",sqrt(a));
      printf("pow(2,a)=%4.2lf\n",pow(2,a));
      getch();
    } 
    Task:
    Используя математическую функцию tan, напечатать таблицу тангенсов и котангенсов в виде:
    a      tg(a)   ctg(a)
    30.0  ...      …
    45.0 ...       …
    60.0 ...       …
    На месте ... должны быть напечатаны соответствующие значения тригонометрических функций с тремя значащими цифрами в дробной части.
    Decision:
    #include<stdio.h>
    #include<curses.h>
    #include<math.h>
    const float Pi=3.1415927;
    void main()
    {
      float a;
      a=30.0;
      printf("a\ttg(a)\tctg(a)\n");
      printf("%4.1f\t%4.2lf\t%4.2lf\n",a,tan(a*Pi/180.0),1/tan(a*Pi/180.0));
      printf("%4.1f\t%4.2lf\t%4.2lf\n",a+15,tan((a+15)*Pi/180.0),1/tan((a+15)*Pi/180.0));
      printf("%4.1f\t%4.2lf\t%4.2lf\n",a+30,tan((a+30)*Pi/180.0),1/tan((a+30)*Pi/180.0));
      getch();
    } 

Игры
    Task:
    Puzzle
    Здесь я учусь создавать игру с графическим приложением Puzzle 15.
    Decision:
    https://github.com/David138it/MyPortfolio/tree/main/TaskDecision/Engineer-Isu/Cpp/15Puzzle/
    Source:
    1. https://www.youtube.com/watch?v=2Scwa8KuNQU&t=79s
    2. https://www.youtube.com/playlist?list=PLvItDmb0sZw_l5qKMLTjePXX485CWKVNe    
    Task:
    Тетрис
    launch the window
    Decision:
    1. https://github.com/David138it/MyPortfolio/tree/main/TaskDecision/Engineer-Isu/Cpp/Tetris/Tetris
    Decision:
    $ g++ painter.cpp tetris.cpp -o main -lglut -lGLU -lGL
    $ ./main
    Task:
    draw a red square in the window
    Decision:
    1. https://github.com/David138it/MyPortfolio/tree/main/TaskDecision/Engineer-Isu/Cpp/Tetris/Tetris1
    Decision:
    $ g++ painter.cpp tetris.cpp -o main -lglut -lGLU -lGL
    $ ./main
    Task:
    draw figures for tetris
    Decision:
    1. https://github.com/David138it/MyPortfolio/tree/main/TaskDecision/Engineer-Isu/Cpp/Tetris/Tetris2
    Decision:
    $ g++ painter.cpp tetris.cpp tetromino.cpp -o main -lglut -lGLU -lGL
    $ ./main
    Task:
    Let's draw a figure now, so that you can turn it over
    Decision:
    1. https://github.com/David138it/MyPortfolio/tree/main/TaskDecision/Engineer-Isu/Cpp/Tetris/Tetris3
    Decision:
    $ g++ painter.cpp tetris.cpp tetromino.cpp -o main -lglut -lGLU -lGL
    $ ./main
    Task:
    We will also check other figures
    Decision:
    1. https://github.com/David138it/MyPortfolio/tree/main/TaskDecision/Engineer-Isu/Cpp/Tetris/Tetris4
    Decision:
    $ g++ painter.cpp tetris.cpp tetromino.cpp -o main -lglut -lGLU -lGL
    $ ./main
    Task:
    Change the color of the shapes
    Decision:
    1. https://github.com/David138it/MyPortfolio/tree/main/TaskDecision/Engineer-Isu/Cpp/Tetris/Tetris5
    Decision:
    $ g++ painter.cpp tetris.cpp tetromino.cpp well.cpp -o main -lglut -lGLU -lGL
    $ ./main
    Task:
    Let's create a movement for the figure
    Decision:
    1. https://github.com/David138it/MyPortfolio/tree/main/TaskDecision/Engineer-Isu/Cpp/Tetris/Tetris6
    Decision:
    $ g++ painter.cpp tetris.cpp tetromino.cpp well.cpp game.cpp -o main -lglut -lGLU -lGL
    $ ./main
    Task:
    Final stage
    Decision:
    $ g++ painter.cpp tetris.cpp tetromino.cpp well.cpp game.cpp -o main -lglut -lGLU -lGL
    $ ./main
    Decision:
    1. https://github.com/David138it/MyPortfolio/tree/main/TaskDecision/Engineer-Isu/Cpp/Tetris/Tetris7
    Task:
    chess rook
    The chess rook moves horizontally or vertically. Given two different cells of the chessboard, determine whether the rook can get from the first cell to the second one in one move. The program receives four numbers from 1 to 8 each, specifying the column number and row number first for the first cell, then for the second cell. The program should output YES if it is possible to get into the second cell from the first cell by the move of the rook, or NO otherwise.
    Task:
    Chess King
    The chess king moves horizontally, vertically and diagonally, but only by 1 square. Given two different squares of the chessboard, determine whether the king can get from the first square to the second one in one move. The program receives four numbers from 1 to 8 each, specifying the column number and row number first for the first cell, then for the second cell. The program should output YES if it is possible to get to the second square from the first square by the king's move, or NO otherwise.
    Task:
    Chess bishop
    Chess bishop moves diagonally. Given two different cells of the chessboard, determine whether the bishop can get from the first cell to the second one in one move. The program receives four numbers from 1 to 8 each, specifying the column number and row number first for the first cell, then for the second cell. The program should output YES if it is possible to get into the second cell from the first cell by the bishop's move, or NO otherwise.
    Task:
    Chess queen
    The chess queen moves diagonally, horizontally or vertically. Given two different cells of the chessboard, determine whether the queen can get from the first cell to the second one in one move. The program receives four numbers from 1 to 8 each, specifying the column number and row number first for the first cell, then for the second cell. The program should output YES if it is possible to get into the second cell from the first cell by the queen's move, or NO otherwise.
    Task:
    Chess knight
    The chess knight moves the letter "G" two squares vertically in any direction and one square horizontally, or vice versa. Given two different squares of the chessboard, determine whether the knight can get from the first square to the second one in one move. The program receives four numbers from 1 to 8 each, specifying the column number and row number first for the first cell, then for the second cell. The program should output YES if it is possible to get to the second square from the first square by the knight's move, or NO otherwise.
    Decision:
    https://github.com/David138it/MyPortfolio/tree/main/TaskDecision/Engineer-Isu/Cpp/Chess/
    Task:
    Шашки
    Decision:
    https://github.com/David138it/MyPortfolio/tree/main/TaskDecision/Engineer-Isu/Cpp/Checkers/
    Task:
    Крестики-нолики
    Decision:
    #include <iostream>
    using namespace std;
    int main() {
        char xo[3][3] = {
            {'.', '.','.'},
            {'.', '.','.'},
            {'.', '.','.'}
        };
        while(true) {
            int x, y;
            cin >> x >> y;
            xo[x][y] = 'x';
            for(int i=0;i<3; i++) {
                for(int j=0;j<3; j++) {
                    cout << xo[i][j] << " ";
                }
                cout << endl;
            }
        }
        return 0;
    }
    Decision:
    #include<iostream>
    using namespace std;
    //char d[9]={ '-', '-', '-', '-', '-', '-', '-', '-', '-'};
    char d[9]={};
    void clear(){
        for(int i=0; i<50; i++){
            cout<<endl;
        }
    }
    void clear_doska(){
        for(int i=0; i<9; i++){
            d[i]='-';
        }
    }
    void doska_player(){
        cout<<"ход игроков"<<endl;
        cout<<"-"<<d[6]<<"-|-"<<d[7]<<"-|-"<<d[8]<<"-"<<endl;
        cout<<"-"<<d[3]<<"-|-"<<d[4]<<"-|-"<<d[5]<<"-"<<endl;
        cout<<"-"<<d[0]<<"-|-"<<d[1]<<"-|-"<<d[2]<<"-"<<endl;
    }
    int doska(){
        cout<<"подсказка хода"<<endl;
        cout<<"-7-|-8-|-9-"<<endl;
        cout<<"-4-|-5-|-6-"<<endl;
        cout<<"-1-|-2-|-3-"<<endl;
        doska_player("");
        //cout<<"ход игроков"<<endl;
        //cout<<"-"<<d[6]<<"-|-"<<d[7]<<"-|-"<<d[8]<<"-"<<endl;
        //cout<<"-"<<d[3]<<"-|-"<<d[4]<<"-|-"<<d[5]<<"-"<<endl;
        //cout<<"-"<<d[0]<<"-|-"<<d[1]<<"-|-"<<d[2]<<"-"<<endl;
        int hod;
        cout<<"ваш ход: ";
        cin>>hod;
        while(hod>9 || hod<1 || d[hod-1]!='-'){
            cout<<"введите правильный ход: ";
            cin>>hod;
        }
        return hod;
    }
    int main(){
        clear_doska();
        int turn=0;
        for(int i=0; i<9; i++){
            clear();
            int hod=doska();
            cout<<"Вы ввели: "<<hod<<endl;
            if(i%2==0){
                d[hod-1]='x';
            }else{
                d[hod-1]='o';
            }
            turn++;
        }
        doska_player();
        return 0;
    }
    Decision:
    #include<iostream>
    #include<string>
    using namespace std;
    char d[9]={};
    void clear(){
        for(int i=0; i<50; i++){
            cout<<endl;
        }
    }
    void clear_doska(){
        for(int i=0; i<9; i++){
            d[i]='-';
        }
    }
    void doska_player(string indent){
        cout<<indent<<"-"<<d[6]<<"-|-"<<d[7]<<"-|-"<<d[8]<<"-"<<endl;
        cout<<indent<<"-"<<d[3]<<"-|-"<<d[4]<<"-|-"<<d[5]<<"-"<<endl;
        cout<<indent<<"-"<<d[0]<<"-|-"<<d[1]<<"-|-"<<d[2]<<"-"<<endl;
    }
    int doska(){
        cout<<"подсказка хода"<<endl;
        cout<<"-7-|-8-|-9-"<<endl;
        cout<<"-4-|-5-|-6-"<<endl;
        cout<<"-1-|-2-|-3-"<<endl;
        doska_player("");
        int hod;    
        cout<<"ваш ход: ";
        cin>>hod;
        while(hod>9 || hod<1 || d[hod-1]!='-'){
            cout<<"введите правильный ход: ";
            cin>>hod;
        }
        return hod;
    }
    bool finish_win(char player){
        int win[][3]={{0,1,2},{3,4,5},{6,7,8},{0,3,6},{1,4,7},{2,5,8},{6,4,2},{0,4,8}};
        for(int i=0; i<8; i++){
            int count=0;
            for(int j=0; j<3; j++){
                if(d[win[i][j]]==player){
                    count++;
                }
            }
            if(count==3){
                return true;
            }
        }
        return false;
    }
    char play_and_get_winner(){
        int turn=1;
        while(!finish_win('x') && !finish_win('o')){
            clear();
            int hod=doska();
            cout<<"Вы ввели: "<<hod<<endl;
            if(turn%2==1){
                d[hod-1]='x';
                if(finish_win('x')){
                    cout<<"player X: поздравляю, вы выйграли"<<endl;
                    return 'x';
                }
            }else{
                d[hod-1]='o';
                if(finish_win('o')){
                    cout<<"player O: поздравляю, вы выйграли"<<endl;
                    return 'o';
                }
            }
            turn++;
            if(turn==10){
                cout<<"Ничья"<<endl;
            }
        }
        return 'D';
    }
    int main(){
        cout<<"Welcome"<<endl;
        string reply="y";
        int x_wins=0, o_wins=0, ties=0;
        while(reply=="y"){
            clear_doska();
            char winner=play_and_get_winner();
            doska_player("\t");
            switch(winner){
                case 'x':
                    x_wins++;
                    break;
                case 'o':
                    o_wins++;
                    break;
                case 'D':
                    ties++;
                    break;
            }
            cout<<" Статистика Игрока Х: " <<x_wins<<", Игрока О: "<<o_wins<<" И нeчьи "<<ties<<endl;
            cout<<"Хотите продолжить?(y/n) ";
            cin>>reply;
            while(reply!="y" && reply!="n"){
                cout<<"Пожалуйста, введите правильный ответ(y/n) ";
                cin>>reply;
            }
        }
        return 0;
    }
    Task:
    Сапер
    Мальчику Васе очень нравится знаменитая игра "Сапер" ("Minesweeper").
    Один человек играет в "Сапера". Игра ведется на клетчатом поле (далее мы будем называть это картой) N×M (N строк, M столбцов). В K ячейках поля находятся мины, в остальных ячейках либо записывается число от 1 до 8 — количество мин в соседних ячейках, либо ничего не записывается, если в соседних ячейках нет мин. Ячейки являются смежными, если у них есть хотя бы одна общая точка, в одной ячейке не может быть более одной мины. Изначально все ячейки поля закрыты. Игрок может открыть ячейку за один ход. Если в открытой им ячейке есть мина, он проигрывает, в противном случае игроку показывается число, которое стоит в этой ячейке, и игра продолжается. Цель игры состоит в том, чтобы открыть все ячейки, в которых нет мин.
    У Васи есть эта игра на компьютере, но ему кажется, что все карточки, которые в ней есть, некрасивые и неинтересные. Поэтому он решил нарисовать свой собственный. Однако у него богатое воображение, а времени мало, и он хочет успеть нарисовать как можно больше карточек. Поэтому он просто выбирает N, M и K и расставляет мины на поле, после чего все остальные ячейки могут быть однозначно идентифицированы. Однако он не хочет тратить свое драгоценное время на определение оставшихся ячеек. Помогите ему!
    Decision:
    #include<iostream>
    #include<fstream>
    #include<ctime>
    #include<cstdlib>
    using namespace std;
    ifstream in("input.txt");
    ofstream out("output.txt");
    int main()
    {

        char massive[10][10]={
                {'.','.','.','.','.','.','.','.','.','.'},
                {'.','.','.','.','.','.','.','.','.','.'},
                {'.','.','.','.','.','.','.','.','.','.'},
                {'.','.','.','.','.','.','.','.','.','.'},
                {'.','.','.','.','.','.','.','.','.','.'},
                {'.','.','.','.','.','.','.','.','.','.'},
                {'.','.','.','.','.','.','.','.','.','.'},
                {'.','.','.','.','.','.','.','.','.','.'},
                {'.','.','.','.','.','.','.','.','.','.'},
                {'.','.','.','.','.','.','.','.','.','.'}
                };
        time_t now = time(NULL);
        srand(now);
        int x, y;
        for (int i=0; i<10; ){
            x = rand()%10;
            y = rand()%10;
            if (massive[x][y]=='*'){
                continue;
            }
            else {
                massive[x][y] ='*';
            }
           i++;
        }
        for (int i=0; i<10; i++){
            for (int j=0;j<10;j++)
            cout << massive[i][j] << " ";
            cout << endl;
        }

        return 0;
    }
    Task:
    Лабиринт с помощью двумерных массивов
    Decision:
    #include <iostream>
    #include <math.h>
    #include <clocale>
    using namespace std;
    int main()
    {
        setlocale(LC_CTYPE, "rus");
        int mas[33][20] = {
                            {1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,}, 
                            {1,2,1,0,0,1,0,1,2,2,2,1,1,1,1,0,0,0,0,1,},
                            {1,2,1,1,0,1,0,1,2,1,2,2,2,2,1,0,1,1,0,1,},
                            {1,2,2,2,2,2,2,1,2,1,1,1,1,2,1,0,0,1,0,1,},
                            {1,1,1,1,1,1,2,1,2,1,0,0,1,2,1,1,0,1,0,1,},
                            {1,0,0,1,0,0,2,2,2,1,1,0,0,2,0,0,0,1,0,1,},
                            {1,0,1,1,0,1,1,1,1,1,0,0,1,2,1,1,1,1,0,1,},
                            {1,0,0,0,0,0,0,0,0,1,1,1,1,2,1,0,0,0,0,1,},
                            {1,1,1,1,1,1,0,1,1,1,2,2,2,2,1,0,1,1,1,1,},
                            {1,1,0,0,0,1,0,0,1,1,2,1,1,1,1,0,0,0,0,1,},
                            {1,0,0,1,0,0,0,0,0,1,2,2,2,2,1,1,1,1,0,1,},
                            {1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,0,0,0,0,1,},
                            {1,2,2,2,2,2,2,2,2,2,2,2,2,2,1,0,1,1,1,1,},
                            {1,2,1,1,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,},
                            {1,2,1,0,0,0,1,2,2,2,1,0,0,0,0,0,1,1,0,1,},
                            {1,2,1,1,1,1,1,2,1,2,1,1,1,0,1,0,0,0,0,1,},
                            {1,2,1,2,2,2,1,2,1,2,2,2,1,1,1,1,1,1,1,1,},
                            {1,2,1,2,1,2,1,2,1,0,1,2,2,2,2,2,2,2,2,1,},
                            {1,2,1,2,1,2,1,2,1,0,1,1,1,1,1,1,1,1,2,1,},
                            {1,2,1,2,1,2,1,2,1,0,0,0,0,0,0,0,0,0,2,1,},
                            {1,2,1,2,1,2,2,2,1,0,1,1,1,1,1,1,0,1,2,1,},
                            {1,2,1,2,1,1,1,1,1,0,0,0,1,0,1,0,0,1,2,1,},
                            {1,2,1,2,2,1,0,0,1,1,1,0,0,0,1,0,1,1,2,1,},
                            {1,2,1,1,2,1,1,0,0,0,0,0,1,0,1,0,0,1,2,1,},
                            {1,2,1,1,2,1,0,0,1,1,1,1,1,1,1,1,1,1,2,1,},
                            {1,2,1,1,2,1,1,0,1,2,2,2,2,2,2,2,2,2,2,1,},
                            {1,2,1,1,2,1,0,0,1,2,1,1,1,1,1,1,1,1,1,1,},
                            {1,2,1,1,2,1,0,1,1,2,1,1,1,1,1,1,1,1,2,2,},
                            {1,2,1,1,2,1,0,0,1,2,1,1,2,2,2,2,2,2,2,1,},
                            {1,2,1,1,2,1,0,1,1,2,1,1,2,1,1,1,1,1,1,1,},
                            {1,2,1,1,2,1,0,0,1,2,1,1,2,1,0,0,0,1,0,1,},
                            {1,2,2,2,2,1,0,1,1,2,2,2,2,0,0,1,0,0,0,1,},
                            {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,}
        };
        for (int i = 0; i < 33; i++)
        {
            for (int j = 0; j < 20; j++)
            {
                if (mas[i][j] == 1)
                {
                    cout <<"j";
                    cout <<"j";
                } else{
                     cout << "  ";
                }
            }
            cout << endl;
        }
        return 0;
    }    

Клавиатура
    Task:
    Keyboard. For this letter of the English alphabet, you need to print the letter on the right on a standard keyboard. At the same time, the keyboard is closed, i.e. to the right of the letter «p» is the letter «a», from the letter «l» is the letter «z», and from the letter «m» — the letter
    Input: Первая строка входного файла INPUT.TXT содержит один символ — маленькую букву английского алфавита.
    Output: В выходной файл OUTPUT.TXT следует вывести букву стоящую справа от заданной буквы, с учетом замкнутости клавиатуры.
    Decision:
    #include<iostream>
    #include<fstream>
    #include<cmath>
    using namespace std;
    ifstream in("input.txt");
    ofstream out("output.txt");
    int main()
    {
        const char massive=26;
        char a[massive]={
            'q','w','e','r','t','y','u','i','o','p','a',
            's','d','f','g','h','j','k','l','z','x','c',
            'v','b','n','m'
        };
        char symbol;
        in>>symbol;
        if(symbol=='m'){
            out<<a[0];
        }
        else{
            for(int i=0; i<massive; i++){
                if(symbol==a[i]){
                    out<<a[i+1];
                }

            }
        }
        return 0;
    }
    Source:
    1. https://acmp.ru/index.asp?main=tasks

Сортировка
    Task:
    Поиск числа в отсортированном массиве
    Decision:
    $ cat Cpp-SearchingForANumberInASortedArray.cpp
    #include<iostream>
    #include<fstream>
    using namespace std;
    int main(){
        
        fstream f("Cpp-SearchingForANumberInASortedArray.txt");
        const int n=100;
        int a[n];
        for (int i=0; i<n; ++i){
            f>>a[i];
        }
        int x;
        cout<<"VVedite iskonoe chislo";
        cin>>x;
        for (int i=0; i<n; ++i){
            if (x==a[i]){
                cout<<"chislo" << x << " nahoditsia po indeksu "
                    <<i;
                break;
            }
        }
    }
    $ cat Cpp-SearchingForANumberInASortedArray.txt
    23
    3234
    45345
    34
    534
    5
    345
    34
    54
    35
    34
    5
    345
    34
    534
    5
    34
    55
    435
    4
    45
    34
    534
    5
    34
    5
    34
    43545
    34
    5345
    34
    5
    345
    34454323
    3
    2
    2
    3
    1
    34234
    23
    324
    23
    43
    4
    234
    23
    423
    4
    324
    23
    432
    4
    234
    23
    4
    234
    23
    423
    4
    23
    423
    4
    234
    23
    4
    234
    23
    4
    23
    423
    4
    23
    423
    4
    23
    423
    4
    23
    423
    465
    43
    4
    654
    6
    456
    45
    645
    6
    456
    5
    656
    4
    56
    46
    457
    6
    7
    454

Time
    Task:
    Часы
    Decision:
    $ cat Clock.cpp
    #include<GL/glut.h>
    #include<cmath>
    #include<ctime>
    void display(){
            glClear(GL_COLOR_BUFFER_BIT);
            glBegin(GL_LINES);
        for(int i=0; i<12; ++i){
            float x=sin(2*M_PI/12*i);
            float y=cos(2*M_PI/12*i);
            glVertex2f(400*x, 400*y);
            glVertex2f(380*x, 380*y);
        }
        time_t t=time(0);
        tm *lt=localtime(&t);//kosiyak
        int h=lt -> tm_hour;
        int m=lt -> tm_min;
        int s=lt -> tm_sec;
        float x=sin(2*M_PI*(h*60+m)/12/60);
            float y=cos(2*M_PI*(h*60+m)/12/60);
            glVertex2f(0, 0);
            glVertex2f(250*x, 250*y);
        x=sin(2*M_PI*m/60);
            y=cos(2*M_PI*m/60);
            glVertex2f(0, 0);
            glVertex2f(350*x, 350*y);
        x=sin(2*M_PI*s/60);
            y=cos(2*M_PI*s/60);
            glVertex2f(0, 0);
            glVertex2f(370*x, 370*y);
        glEnd();
            glutSwapBuffers();
    }
    void timer(int=0){
            display();
            glutTimerFunc(10,timer,0);
    }
    int main(int argc, char **argv){
        glutInit(&argc, argv);
            glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB);
            glutInitWindowSize(400,400);
            glutInitWindowPosition(20,1050-400-20);
            glutCreateWindow("Clock");
            glClearColor(0,0,0,1.0);
            glMatrixMode(GL_PROJECTION);
            glLoadIdentity();
            glOrtho(-400,400,-400,400,-400,400);
            glutDisplayFunc(display);
            timer();
            glutMainLoop();
    }
    $ g++ Clock.cpp -o main -lglut -lGLU -lGL
    $ ./main
    Source:
    1. https://www.youtube.com/playlist?list=PL30625C8F5ADD5BB4
    Task:
    День программиста отмечается в 255-й день года (при этом 1 января считается нулевым днем). Требуется написать программу, которая определит дату (месяц и число григорианского календаря), на которую приходится День программиста в заданном году.
    В григорианском календаре високосным является:
    1. год, номер которого делится нацело на 400
    2. год, номер которого делится на 4, но не делится на 100
    В единственной строке входного файла INPUT.TXT записано целое число от 1 до 9999 включительно, которое обозначает номер года нашей эры. В единственную строку выходного файла OUTPUT.TXT нужно вывести дату Дня программиста в формате DD/MM/YYYY, где DD — число, MM — номер месяца (01 — январь, 02 — февраль, ..., 12 — декабрь), YYYY — год в десятичной записи.
    Примеры
    №    INPUT.TXT    OUTPUT.TXT
    1    2000        12/09/2000
    2    2009        13/09/2009     
    Decision:
    #include <iostream>
    #include <fstream>
    #include <cmath>
    #include <vector>
    #include <ctime>
    #include <cstdlib>
    using namespace std;
    ifstream in("Cpp-ProgrammesDay.txt");
    ofstream out("output.txt");
    int main() {
        int y;
            in>>y;
            if((y%400==0)||(y%100!=0&&y%4==0)) {
                if(y<10) {
                    out<<"12"<<"/"<<"09/000"<<y;
                }
                else if(y<100) {
                    out<<"12"<<"/"<<"09/00"<<y;
                }
                else if(y<1000) {
                    out<<"12"<<"/"<<"09/0"<<y;
                }
                else if(y<10000) {
                    out<<"12"<<"/"<<"09/"<<y;
                }
            }
            else{
                if(y<10){
                    out<<"13"<<"/"<<"09/000"<<y;
                }
                else if(y<100) {
                    out<<"13"<<"/"<<"09/00"<<y;
                }
                else if(y<1000) {
                        out<<"13"<<"/"<<"09/0"<<y;
                }
                else if(y<10000) {
                    out<<"13"<<"/"<<"09/"<<y;
                }
            }
        return 0;
    }
    Task:
    Доработаем класс CppStudio так, чтобы в нём можно было хранить дату в формате дд.мм.гг. Для изменения и просмотра даты реализуем соответственно set и get функции.
    Decision:
    #include <iostream>
    using namespace std;
    class CppStudio // имя класса
    {
    private: // спецификатор доступа private
        int day, // день
            month, // месяц
            year; // год
    public: // спецификатор доступа public
        void message() // функция (метод класса) выводящая сообщение на экран
        {
            cout << "\nwebsite: cppstudio.comntheme: Classes and Objects in C + +\n";
        }
        void setDate(int date_day, int date_month, int date_year) // установка даты в формате дд.мм.гг
        {
            day   = date_day; // инициализация день
            month = date_month; // инициализация месяц
            year  = date_year; // инициализация год
        }
        void getDate() // отобразить текущую дату
        {
            cout << "Date: " << day << "." << month << "." << year << endl;
        }
    }; // конец объявления класса CppStudio
    int main(int argc, char* argv[])
    {
        int day, month, year;
        cout << "Введите текущий день месяц и год!\n";
        cout << "день: ";     cin >> day;
        cout << "месяц: ";    cin >> month;
        cout << "год: ";  cin >> year;
        CppStudio objCppstudio; // объявление объекта
        objCppstudio.message(); // вызов функции класса message
        objCppstudio.setDate(day, month, year); // инициализация даты
        objCppstudio.getDate(); // отобразить дату
        return 0;
    }
    Task:
    Пример с классом Counter, который представляет секундомер и хранит количество секунд
    Decision:
    #include <iostream>
    using namespace std;
    class Counter{
    public:
        Counter(int sec)
        {
            seconds = sec;
        }
        void display()
        {
            cout << seconds << " seconds" << endl;
        }
        int seconds;
    };
    Counter operator + (Counter c1, Counter c2){
        return Counter(c1.seconds + c2.seconds);
    }
    int main(){
        Counter c1(20);
        Counter c2(10);
        Counter c3 = c1 + c2;
        c3.display();   // 30 seconds
        return 0;
    }
    Decision:
    #include <iostream>
    using namespace std;
    class Counter{
    public:
        Counter(int sec){
            seconds = sec;
        }
        void display(){
            cout << seconds << " seconds" << endl;
        }
        Counter operator + (Counter c2){
            return Counter(this->seconds + c2.seconds);
        }
        int operator + (int s){
            return this->seconds + s;
        }
        int seconds;
    };
    int main(){
        Counter c1(20);
        Counter c2(10);
        Counter c3 = c1 + c2;
        c3.display();           // 30 seconds
        int seconds = c1 + 25;  // 45
        cout << seconds << endl;
        return 0;
    }

Минимум и максимум
    Task:
    Вывести из массива минимум и еще минимум
    Decision:
    #include <iostream>
    #include <stdlib.h>
    using namespace std;
    int main()
    {
        system("chcp 1251>0");
        const int arraysize = 5;
        int a [arraysize] = {18, 3, 4, 7, 7};
        int min=a[0], k=0, min2=a[1], k2=1, q;
        if (min>min2){
            q=min;
            min=min2;
            min2=q;

            q=k;
            k=k2;
            k2=q;
        }

        for (int i = 2; i < arraysize; i++){
            if (a[i]<min){
                min2=min;
                k2=k;
                min=a[i];
                k=i;
            }
            else{
                if(a[i]<min2){
                    min2=a[i];
                    k2=i;
                }

            }
        }
         cout << "min2=" << min2 << endl;
         cout << "k2=" << k2 << endl;
         cout << "min=" << min << endl;
         cout << "k=" << k << endl;
        return 0;
    }

Генерация
    Task:
    пытаемся отгадать число у компа
    Decision:
    #include<iostream>
    #include<cstdlib>
    #include<ctime>
    using namespace std;
    int main (){
            srand(time(0));
            bool done;
            do{
                    int j, i=rand()%100;
                    while (true){
                            cout<<"Какое число вы загадали?";
                            cin>>j;
                            if(i>j){
                                    cout<<"Мое число больше"<<endl;
                            }
                            else{
                                    if(i<j){
                                            cout<<"Мое число меньше"<<endl;
                                    }
                                    else{
                                            cout<<"Ты угадал"<<endl;
                                            break;
                                    }
                            }
                    }
                    cout<<"Продолжить? (y/n) ";
                    char c;
                    done=(c!='y');
                    cin>>c;
            }while(!done);
    }
    Task:
    Теперь наоборот комп пытаеmся угадать у нас число
    Decision:
    #include<iostream>
    #include<cmath>
    using namespace std;
    float f(float x){
            cout<<(int)x<<endl;
            while (true){
                    cout<<"Правильно? (+/-/=) ";
                    char c;
                    cin>>c;
                    switch (c){
                            case '+': return +1;
                            case '-': return -1;
                            case '=': return 0;
                    }
                    cout<<"Вы ввели не правильный символ, повторите"<<endl;
            }
    }
    float n(float x1, float x2){
            float x=(x1+x2)/2;
            float y=f(x);
            while(abs(y)>0.001){
                    if(y>0){
                            x1=x;
                    }else{
                            x2=x;
                    }
                    x=(x1+x2)/2;
                    y=f(x);
            }
            return x;
    }
    int main(){
            cout<<"Вы загадали "<< (int)n(0,100);
    }
    Task:
    Заполнить матрицу 6*6 случайными целыми числами в диапазоне от 0 до 200. Вывести матрицу на экран в виде таблицы. После этого вывести матрицу в транспонированном виде. 
    Decision:
    #include<stdio.h>
    #include<stdlib.h>
    void main()
    {
        int i,j,m[6][6];
        for(i=0;i<6;i++)
        {
            for(j=0;j<6;j++)
            {
                m[i][j]=rand()%200;
                printf("%d\t",m[i][j]);
            }
            printf("\n");
        }
        printf("\n");
            for(i=0;i<6;i++)
            {
                    for(j=0;j<6;j++)
                    {
                printf("%d\t",m[j][i]);
                    }
                    printf("\n");
            }
    }
    Decision:
    #include<stdio.h>
    #include<stdlib.h>
    void main()
    {
        int i,j,m[6][6];
        for(i=0;i<6;i++)
        {
            for(j=0;j<6;j++)
            {
                m[i][j]=rand()%200;
                printf("%d\t",m[i][j]);
            }
            printf("\n");
        }
        /*printf("\n");
            for(j=0;j<6;j++)
            {
                    for(i=0;i<6;i++)
                    {
                printf("%d\t",m[i][j]);
                    }
                    printf("\n");
            }*/
    }
    Decision:
    #include<stdio.h>
    void main()
    {
        int i,j, matrix[6][6];
        for(i=0;i<6;i++)
        {
            for(j=0;j<6;j++)
            {
                printf("x");
            }
            printf("\n");
        }
    }
    Task:
    Заполнить вещественный массив из 20 элементов случайными вещественными числами в диапазoне от - 3.0 до +3.0. Вывести на экран пронумерованный столбец значений элементов массива. Определить и вывести номер и значение наибольшего элемента массива.
    Decision:
    #include<stdio.h>
    #include<stdlib.h>
    void main()
    {
        double arr[20];
        int i;
        srand(time(0));
        for(i=0;i<20;i++){
            arr[i]=-3.0+6.0*rand()/(float)RAND_MAX;
            printf("%d %5.2lf\n",i+1,arr[i]);
        }
        printf("\n");
        float max=arr[0];
        int number;
        for(i=0;i<20;i++){
            if (max<arr[i])
            {
                max=arr[i];
                number=i+1;
            }
        }
        printf("%5.2lf\t%d\n",max,number);
    }    
    Decision:
    #include<stdio.h>
    #include<stdlib.h>
    void main()
    {
        float arr[20];
        int i;
        for(i=0;i<20;i++){
            arr[i]=rand()%(3+3+1)-3;
            printf("%d %5.2lf\n",i+1,arr[i]);
        }
        printf("\n");
        float max=arr[0];
        for(i=0;i<20;i++){
            if (max<arr[i])
            {
                max=arr[i];
            }
        }
        printf("%lf\n",max);
    }    
    Decision:
    #include<stdio.h>
    #include<stdlib.h>
    void main()
    {
        float arr[20];
        int i;
        for(i=0;i<20;i++){
            arr[i]=rand()%(3+3+1)-3;
            printf("%d %5.2lf\n",i,arr[i]);
        }
    } 
    Decision:
    #include<stdio.h>
    #include<stdlib.h>
    void main()
    {
        float arr[20];
        int i;
        for(i=0;i<20;i++){
            arr[i]=rand()%(3+3+1)-3;
            printf("Array=%5.2lf\n",arr[i]);
        }
    } 
    Task:
    Пользуясь только указателями, заполнить массив десятью целыми случайными числами в диапазоне от 0 до 10. Вывести пронумерованный массив значений в столбец на экран. После этого напечатать номера, значения и адреса тех элементов, которые оказались четными. Использовать операцию %.
    Decision:
    #include<stdio.h>
    #include<stdlib.h>
    void main()
    {
        int i, arr[10];
        for(i=0; i<10; i++){
            arr[i]=rand()%11;
            printf("%d\t%d\n",i+1,*(arr+i));
        }
    }    
    Decision:
    #include<stdio.h>
    #include<stdlib.h>
    void main()
    {
        int i, arr[10];
        for(i=0; i<10; i++){
            arr[i]=rand()%11;
            if ((arr[i]%2)==0)
            {
                printf("%d\t%d\t%p\n",i+1,*(arr+i),arr+i);
            }
        }
    }    
    Decision:
    #include<stdio.h>
    #include<stdlib.h>
    void main()
    {
        int i, arr[10];
        for(i=0; i<10; i++){
            arr[i]=rand()%11;
            printf("%d\n",arr[i]);
        }
    }    
    Decision:
    #include<stdio.h>
    #include<stdlib.h>
    void main()
    {
        int i, arr[10];
        for(i=0; i<10; i++){
            arr[i]=rand()%11;
            printf("%d\t%d\t%p\n",i+1,*(arr+i),arr+i);
        }
    }    
    Task:
    Генерация псевдослучайных чисел
    Decision:
    #include <iostream>
    #include <fstream>
    #include <cmath>
    #include <vector>
    #include <ctime>
    #include <cstdlib>
    using namespace std;
    int main() {
           time_t now = time(NULL); // сколько секунд прошло с 01.01.1970 до текущего момента
            srand(now);
        cout << rand() << endl; // генерация и печать случайного числа от 0 до   RAND_MAX
        return 0;
    }
    Task:
    Разработаем программу, в которой создадим одномерный динамический массив, заполненный случайными числами.
    Decision:
    #include <iostream>
    #include <ctime>
    using namespace std;
    int main()
    {
        srand(time(0)); // генерация случайных чисел
            int *ptrarray = new int [10]; // создание динамического массива вещественных чисел на десять элементов
            for (int count = 0; count < 10; count++)
                    ptrarray[count] = (rand() % 10 + 1) / int((rand() % 10 + 1)); //заполнение массива случайными числами с масштабированием от 1 до 10
            cout << "array = ";
            for (int count = 0; count < 10; count++)
                    cout << ptrarray[count] << "    ";
            delete [] ptrarray; // высвобождение памяти
            cout << endl;
        return 0;
    }
    Task:
    Заполнить выделенную память случайными целыми числами двумя способами:
    1. работая с выделенной памятью как с обычным массивом (переменными с индексом),
    2. используя только указатели. В обоих случаях вывести результат на экран.
    Освободить выделенную память и снова вывести массив на экран.
    Decision:
    #include <iostream>
    using namespace std;
    int main()
    {
        //Распределить динамически память под N чисел целого типа, где N – значение, вводимое с клавиатуры.
        int N, *block, i;
        cin >> N;
        block = new int[N];
        cout << block << endl;
        /*Заполнить выделенную память случайными целыми числами двумя способами (В обоих случаях вывести результат на экран):
        а) работая с выделенной памятью как с обычным массивом (переменными с индексом)*/
        for (i=0; i<N; i++)
        {
            block[i]=rand();
            cout << block[i] << endl;
        }
        //б) используя только указатели.
        for (int i=0; i<N; i++)
        {
            *(block+i)=rand();
            cout << *(block+i) << endl;
        }
        //Освободить выделенную память
        delete block;
        // и снова вывести массив на экран
        for (int i=0; i<N; i++)
        {
            cout << block[i] << "   ";
        }
        return 0;
    }

Пароли и Шифрование
    Task:
    Функция ввода пароля.
    Decision:
    #include <iostream>
    #include <string>
    using namespace std;
    void check_pass (string password){
        string valid_pass="qwerty123";
        if (password==valid_pass){
            cout<<"Доступ разрешен." << endl;
        } else {
            cout << "Неверный пароль!" << endl;
        }
    }
    int main()
    {
        setlocale(LC_CTYPE, "rus");
        string user_pass;
        cout<< "Введите пароль: ";
        getline(cin, user_pass);
        check_pass(user_pass);
        return 0;
    }
    Task:
    Шифрование ключевых фраз с помощью функции crypt    
    Decision:
    $ ./project hunter2 '$1$42'
    $1$42$7l6Y3xT5282XmZrtDOF9f0
    $ ./project hunter2 '$6$42' $6$42$OqFFAVnI3gTSYG0yI9TZWX9cpyQzwIop7HwpG1LLEsNBiMr4w6OvLX1KDa./UpwXfrFk1i...
    $ ./project hunter2 '$1$hunter2'
    $1$hunter2$YVxrxDmidq7Xf8Gdt6qM2.
    $ gcc C-EncryptionOfKeyPhrasesUsingCrypt.c -o project -lcrypt
    $ ./project
    $ cat C-EncryptionOfKeyPhrasesUsingCrypt.c
    #include <stdio.h>
    #define __USE_XOPEN
    #include <unistd.h>
    int main(int argc, char** argv)
    {
     if(argc==3)
       {
           printf("%s\n", crypt(argv[1],argv[2]));
       }
       else
       {
           printf("Использование: MyCrypt $пароль $salt\n" );
       }
      return 0;
    }

Инструменты для разработчика
    Task:
    Компиляция программ с помощью команд ./configure и make
    Давайте что-нибудь скомпилируем. Для этого нам понадобятся некоторые инструменты, такие как компилятор, компоновщик и утилита make . Практически во всех системах Linux используется один и тот же компилятор языка C с именем gcc (GNU C Compiler). Проверить его присутствие в системе можно так
    Decision:
    $ which gcc
        /usr/bin/gcc
    Task:
    Получение исходного кода
    Ckомпилируем программу с названием diction из проекта GNU. Эта маленькая удобная программка проверяет качество и стиль содержимого текстовых файлов. А поскольку она невелика, она легко компилируется.
    Следуя соглашениям, мы сначала создадим каталог src для исходного кода и затем загрузим в него исходный код с помощью команды ftp
    Decision:
    $ mkdir src
    $ cd src/
    /src$ ftp ftp.gnu.org
        Name (ftp.gnu.org:server): anonymous
        ...
        230 Login successful.
        Remote system type is UNIX.
        Using binary mode to transfer files.
    ftp> cd gnu/diction
        250 Directory successfully changed.
    ftp> ls
        200 PORT command successful. Consider using PASV.
        150 Here comes the directory listing.
        -rw-r--r--    1 3003     65534       68940 Aug 28  1998 diction-0.7.tar.gz
        -rw-r--r--    1 3003     65534       90957 Mar 04  2002 diction-1.02.tar.gz
        -rw-r--r--    1 3003     65534      141062 Sep 17  2007 diction-1.11.tar.gz
        -rw-r--r--    1 3003     65534         189 Sep 17  2007 diction-1.11.tar.gz.sig
        226 Directory send OK.
    ftp> get diction-1.11.tar.gz
    ftp> bye
        221 Goodbye.
    Task:
    Поскольку мы сами управляем процессом компиляции исходного кода, поместим его в каталог ~/src. Исходный код, устанавливаемый дистрибутивом, помещается в каталог /usr/src, а исходный код, предназначенный для использования множеством пользователей, обычно устанавливается в /usr/local/src.
    Исходный код обычно распространяется в виде сжатого tar-файла. Подключившись к FTP-сайту, мы получили список доступных tar-файлов и выбрали для загрузки самую свежую версию. При помощи команды get программы ftp скопировали файл с сервера FTP на локальную машину.
    После загрузки tar-файла его нужно распаковать. Программа diction , подобно всем программам из проекта GNU, следует определенным стандартам упаковки исходного кода. Большая часть других исходных кодов, доступных в экосистеме Linux, также следует этому стандарту. Одним из элементов стандарта является создание каталога с деревом исходных текстов и именем project-x.xx после распаковывания tar-файла, то есть с именем, содержащим имя проекта и номер версии. Такая схема упрощает установку нескольких версий одной и той же программы. Однако перед распаковыванием хорошо бы исследовать организацию дерева. При распаковывании некоторых проектов каталог не создается, а файлы помещаются непосредственно в текущий каталог, что может вызвать неразбериху и путаницу в хорошо организованном каталоге src. Чтобы избежать этого, пользуйтесь следующей командой для исследования содержимого tar-файла
    Decision:
    /src$ tar tzvf diction-1.11.tar.gz | head
        -rw-r--r-- michael/user  35068 2007-07-30 14:47 diction-1.11/COPYING
        -rw-r--r-- michael/user   9416 2007-08-03 01:03 diction-1.11/INSTALL
        -rw-r--r-- michael/user   3920 2007-08-03 04:05 diction-1.11/Makefile.in
        -rw-r--r-- michael/user   1448 2007-08-30 04:20 diction-1.11/README
        -rw-r--r-- michael/user    152 2007-08-30 02:08 diction-1.11/NEWS
        -rwxr-xr-x michael/user 144080 2007-08-30 02:06 diction-1.11/configure
        -rwxr-xr-x michael/user  13184 2007-08-03 01:03 diction-1.11/install-sh
        -rw-r--r-- michael/user   2621 2007-03-30 15:45 diction-1.11/de
        -rw-r--r-- michael/user  24830 2007-03-30 15:45 diction-1.11/en
        -rw-r--r-- michael/user  25043 2007-03-30 15:45 diction-1.11/en_GB
    /src$ tar xzf diction-1.11.tar.gz
    /src$ ls -l
        total 144
        drwxrwxr-x 3 s s   4096 Jan  3 20:55 diction-1.11
        -rw-rw-r-- 1 s s 141062 Jan  3 20:47 diction-1.11.tar.gz
    Task:
    Исследование дерева исходных текстов
    Decision:
    /src$ cd diction-1.11
    /src/diction-1.11$ ls -l
        config.guess  de            diction.spec.in  getopt.c      misc.c  sentence.c
        config.h.in   de.po         diction.texi.in  getopt.h      misc.h  sentence.h
        config.sub    diction.1.in  en               getopt_int.h  NEWS    style.1.in
        configure     diction.c     en_GB            INSTALL       nl      style.c
        configure.in  diction.pot   en_GB.po         install-sh    nl.po   test
        COPYING       diction.spec  getopt1.c        Makefile.in   README
    /src/diction-1.11$ ls *.c
        diction.c  getopt1.c  getopt.c  misc.c  sentence.c  style.c
    /src/diction-1.11$ ls *.h
        getopt.h  getopt_int.h  misc.h  sentence.h
    Decision:
    /src/diction-1.11$ ls /usr/include
        aio.h        fnmatch.h       mcheck.h        pty.h          sysexits.h
        aliases.h    fstab.h         memory.h        pwd.h          syslog.h
        alloca.h     fts.h           misc            python3.8      tar.h
        argp.h       ftw.h           mlocate         rdma           termio.h
        argz.h       gcalc-2         mntent.h        re_comp.h      termios.h
        ar.h         gci-2           monetary.h      regex.h        tgmath.h
        arpa         gconv.h         mqueue.h        regexp.h       thread_db.h
        asm-generic  getopt.h        mtd             reglib         threads.h
        assert.h     GL              net             resolv.h       time.h
        byteswap.h   glob.h          netash          rpc            ttyent.h
        c++          gnumake.h       netatalk        rpcsvc         uchar.h
        clif.h       gnu-versions.h  netax25         sched.h        ucontext.h
        complex.h    grp.h           netdb.h         scsi           ulimit.h
        cpio.h       gshadow.h       neteconet       search.h       unistd.h
        crypt.h      iconv.h         netinet         semaphore.h    utime.h
        ctype.h      ifaddrs.h       netipx          setjmp.h       utmp.h
        dirent.h     inttypes.h      netiucv         sgtty.h        utmpx.h
        dlfcn.h      iproute2        netpacket       shadow.h       values.h
        drm          KHR             netrom          signal.h       video
        elf.h        langinfo.h      netrose         sound          wait.h
        endian.h     lastlog.h       nfs             spawn.h        wchar.h
        envz.h       libdrm          nl_types.h      stab.h         wctype.h
        err.h        libgen.h        nss.h           stdc-predef.h  wordexp.h
        errno.h      libintl.h       obstack.h       stdint.h       X11
        error.h      libsync.h       openvpn         stdio_ext.h    x86_64-linux-gnu
        execinfo.h   limits.h        paths.h         stdio.h        xcb
        fcntl.h      link.h          poll.h          stdlib.h       xen
        features.h   linux           printf.h        string.h       xf86drm.h
        fenv.h       locale.h        proc_service.h  strings.h      xf86drmMode.h
        finclude     malloc.h        protocols       sudo_plugin.h  xorg
        fmtmsg.h     math.h          pthread.h       syscall.h
    Task:
    Сборка программ
    Давайте запустим configure . Так как эта программа находится не там, где командная оболочка обычно ищет выполняемые файлы, нужно явно сообщить ей местоположение программы, добавив в команду префикс ./ . Он указывает, что программа находится в текущем рабочем каталоге
    Decision:
    /src/diction-1.11$ ./configure
        ...
        configure: creating ./config.status
        config.status: creating Makefile
        config.status: creating diction.1
        config.status: creating diction.texi
        config.status: creating diction.spec
        config.status: creating style.1
        config.status: creating test/rundiction
        config.status: creating config.h
    /src/diction-1.11$ cat Makefile
    ...
    CC=     gcc
    ...
    diction:    diction.o sentence.o misc.o getopt.o getopt1.o
            $(CC) -o $@ $(LDFLAGS) diction.o sentence.o misc.o \
            getopt.o getopt1.o $(LIBS)
    ...
    .c.o:
            $(CC) -c $(CPPFLAGS) $(CFLAGS) $<
            ...
    #{{{ dependencies
    diction.o:  diction.c config.h getopt.h misc.h sentence.h
    getopt.o:   getopt.c getopt.h getopt_int.h
    getopt1.o:  getopt1.c getopt.h getopt_int.h
    misc.o: misc.c config.h misc.h
    sentence.o: sentence.c config.h misc.h sentence.h
    style.o:    style.c config.h getopt.h misc.h sentence.h
    #}}}
    Task:
    давайте запустим make и соберем наши программы:
    Decision:
    /src/diction-1.11$ make
    /src/diction-1.11$ ls
        config.guess   de.po            diction.texi.in  INSTALL      README
        config.h       diction          en               install-sh   sentence.c
        config.h.in    diction.1        en_GB            Makefile     sentence.h
        config.log     diction.1.in     en_GB.po         Makefile.in  sentence.o
        config.status  diction.c        getopt1.c        misc.c       style
        config.sub     diction.o        getopt1.o        misc.h       style.1
        configure      diction.pot      getopt.c         misc.o       style.1.in
        configure.in   diction.spec     getopt.h         NEWS         style.c
        COPYING        diction.spec.in  getopt_int.h     nl           style.o
        de             diction.texi     getopt.o         nl.po        test
    Task:
    Мы только что скомпилировали первые программы из исходного кода! Но, исключительно ради любопытства, запустим make еще раз
    Decision:
    /src/diction-1.11$ make
        make: Nothing to be done for 'all'.
    Task:
    Во всем виновата make . Вместо того чтобы просто собрать все заново, make собирает только то, что нужно собрать. Так как все целевые файлы уже присутствуют в каталоге, make решила, что ничего больше делать не требуется. Продемонстрировать это можно, удалив одну из собранных целей и запустив make снова.
    Decision:
    /src/diction-1.11$ rm getopt.o
    /src/diction-1.11$ make
        ...
        gcc -o diction -g diction.o sentence.o misc.o \
            getopt.o getopt1.o
        gcc -o style -g style.o sentence.o misc.o \
            getopt.o getopt1.o -lm
    Task:
    Воспользуемся программой touch , чтобы «обновить» один из файлов с исходным кодом, и посмотрим, к чему это приведет
    Decision:
    /src/diction-1.11$ ls -l diction getopt.c
        -rwxrwxr-x 1 s s 68128 Jan  3 21:22 diction
        -rw-r--r-- 1 s s 33125 Mar 30  2007 getopt.c
    /src/diction-1.11$ touch getopt.c
    /src/diction-1.11$ ls -l diction getopt.c
        -rwxrwxr-x 1 s s 68128 Jan  3 21:22 diction
        -rw-r--r-- 1 s s 33125 Jan  3 21:24 getopt.c
    /src/diction-1.11$ make
        gcc -c -I. -DSHAREDIR=\"/usr/local/share\" -DLOCALEDIR=\"/usr/local/share/locale\" -g -O2 -pipe -Wno-unused -Wshadow -Wbad-function-cast -Wmissing-prototypes -Wstrict-prototypes -Wcast-align -Wcast-qual -Wpointer-arith -Wcast-align -Wwrite-strings -Wmissing-declarations -Wnested-externs -Wundef -pedantic -fno-common getopt.c
        gcc -o diction -g diction.o sentence.o misc.o \
            getopt.o getopt1.o
        gcc -o style -g style.o sentence.o misc.o \
            getopt.o getopt1.o -lm
    /src/diction-1.11$ ls -l diction getopt.c
        -rwxrwxr-x 1 s s 68128 Jan  3 21:24 diction
        -rw-r--r-- 1 s s 33125 Jan  3 21:24 getopt.c
    Task:
    Установка программ
    Старательно упакованный исходный код часто включает специальную цель для make , которая называется install (установить). Эта цель выполняет установку готового программного продукта в системный каталог. Обычно это каталог /usr/local/bin, традиционное место для установки программного обеспечения, собранного в локальной системе. Однако этот каталог, как правило, недоступен рядовым пользователям для записи, поэтому, чтобы выполнить установку, вам потребуются привилегии суперпользователя. После установки проверим готовность программы к использованию
    Decision:
    /src/diction-1.11$ sudo make install
    /src/diction-1.11$ which diction
        /usr/local/bin/diction
    Source:
    1. Командная строка Linux
    Task:
    Установка g++
    Decision:
    $ sudo apt install build-essential
    $ g++ --version
        g++ (Ubuntu 9.3.0-10ubuntu2) 9.3.0
        Copyright (C) 2019 Free Software Foundation, Inc.
        This is free software; see the source for copying conditions.  There is NO
        warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    Task:
    Первый запуск
    Decision:
    $ vim hello.cc
    $ cat hello.cc
        #include <iostream>
        using namespace std;
        int main()
        {
            cout << "Hello, World!";
            return 0;
        }
    $ ls -l
        итого 28
        -rw-rw-r-- 1     100 Jul 20 20:13 hello.cc
    $ g++ -o hello hello.cc
    $ ls -l
        итого 48
        -rwxrwxr-x 1   17160 Jul 20 20:13 hello
        -rw-rw-r-- 1     100 Jul 20 20:13 hello.cc
    $ ./hello
        Hello, World!
    Decision:
    $ vim test.cpp
    $ cat test.cpp
        fint main(){
        }
    $ g++ test.cpp -o test
        test.cpp:1:1: error: ‘fint’ does not name a type; did you mean ‘int’?
            1 | fint main(){
              | ^~~~
              | int
    $ vim test.cpp
    $ cat test.cpp
        int main(){
        }
    $ g++ test.cpp -o test
    $ ls
        test  test.cpp
    $ gdb --annotate=3 test
        GNU gdb (Ubuntu 9.1-0ubuntu1) 9.1
        Copyright (C) 2020 Free Software Foundation, Inc.
        License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
        This is free software: you are free to change and redistribute it.
        There is NO WARRANTY, to the extent permitted by law.
        Type "show copying" and "show warranty" for details.
        This GDB was configured as "x86_64-linux-gnu".
        Type "show configuration" for configuration details.
        For bug reporting instructions, please see:
        <http://www.gnu.org/software/gdb/bugs/>.
        Find the GDB manual and other documentation resources online at:
            <http://www.gnu.org/software/gdb/documentation/>.
        For help, type "help".
        Type "apropos word" to search for commands related to "word"...
        Reading symbols from test...
        (No debugging symbols found in test)
        ��pre-prompt
        (gdb)
        ��prompt
    run
        ��post-prompt
        Starting program: /home/as/Документы/C++/C++ Open GL/test/test
        ��starting
        ��exited 0
        [Inferior 1 (process 8426) exited normally]
        ��thread-exited,id="1",group-id="i1"
        ��stopped
        ��pre-prompt
        (gdb)
        ��prompt
    quit
        ��post-prompt
    Task:
    Теперь попробуем добавить что-нибудь в программе. Чтобы добавить какой-нибудь текст, нужно подключить библиотеку iostream
    Decision:
    $ vim test.cpp
    $ cat test.cpp
        #include <iostream>
        int main(){
            std::cout<<"Hello"<<std::endl;
        }
    $ g++ test.cpp -o test
    $ gdb --annotate=3 test
        Copyright (C) 2020 Free Software Foundation, Inc.
        License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
        This is free software: you are free to change and redistribute it.
        There is NO WARRANTY, to the extent permitted by law.
        Type "show copying" and "show warranty" for details.
        This GDB was configured as "x86_64-linux-gnu".
        Type "show configuration" for configuration details.
        For bug reporting instructions, please see:
        <http://www.gnu.org/software/gdb/bugs/>.
        Find the GDB manual and other documentation resources online at:
            <http://www.gnu.org/software/gdb/documentation/>.
        For help, type "help".
        Type "apropos word" to search for commands related to "word"...
        Reading symbols from test...
        (No debugging symbols found in test)
        ��pre-prompt
        (gdb)
        ��prompt
    run
        ��post-prompt
        Starting program: /home/as/Документы/C++/C++ Open GL/test/test
        ��starting
        Hello
        ��exited 0
        [Inferior 1 (process 8581) exited normally]
        ��thread-exited,id="1",group-id="i1"
        ��stopped
        ��pre-prompt
        (gdb)
        ��prompt
    q
        ��post-prompt
    Decision:
    $ vim test.cpp
    $ cat test.cpp
        #include <iostream>
        using namespace std;
        int main(){
            int i=1;
            float f=1.1123;
            char c='f';
            cin>>i;
            cin>>f;
            cin>>c;
            cout<<i<<endl;
            cout<<f<<endl;
            cout<<c<<endl;
        }
    $ g++ test.cpp -o test
    $ gdb --annotate=3 test
        GNU gdb (Ubuntu 9.1-0ubuntu1) 9.1
        Copyright (C) 2020 Free Software Foundation, Inc.
        License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
        This is free software: you are free to change and redistribute it.
        There is NO WARRANTY, to the extent permitted by law.
        Type "show copying" and "show warranty" for details.
        This GDB was configured as "x86_64-linux-gnu".
        Type "show configuration" for configuration details.
        For bug reporting instructions, please see:
        <http://www.gnu.org/software/gdb/bugs/>.
        Find the GDB manual and other documentation resources online at:
            <http://www.gnu.org/software/gdb/documentation/>.
        For help, type "help".
        Type "apropos word" to search for commands related to "word"...
        Reading symbols from test...
        (No debugging symbols found in test)
        ��pre-prompt
        (gdb)
        ��prompt
    run
        ��post-prompt
        Starting program: /home/as/Документы/C++/C++ Open GL/test/test
        ��starting
        32
        15.04
        g
        32
        15.04
        g
        ��exited 0
        [Inferior 1 (process 9164) exited normally]
        ��thread-exited,id="1",group-id="i1"
        ��stopped
        ��pre-prompt
        (gdb)
        ��prompt
    q
        ��post-prompt
    Source:
    1. https://linuxconfig.org/how-to-install-g-the-c-compiler-on-ubuntu-20-04-lts-focal-fossa-linux
    Task:
    Установка OpenGl
    Task:
    Настроим утилиту для OpenGl в ubuntu 20.04
    Decision:
    $ sudo apt-get update
    $ sudo apt-get install libglu1-mesa-dev freeglut3-dev mesa-common-dev
    Task:
    Первый запуск OpenGl
    Decision:$ vim main.cpp
    $ cat main.cpp
      #include <GL/glut.h>
      void displayMe(void)
      {
          glClear(GL_COLOR_BUFFER_BIT);
          glBegin(GL_POLYGON);
              glVertex3f(0.5, 0.0, 0.5);
              glVertex3f(0.5, 0.0, 0.0);
              glVertex3f(0.0, 0.5, 0.0);
              glVertex3f(0.0, 0.0, 0.5);
          glEnd();
          glFlush();
      }
      int main(int argc, char** argv)
      {
          glutInit(&argc, argv);
          glutInitDisplayMode(GLUT_SINGLE);
          glutInitWindowSize(400, 300);
          glutInitWindowPosition(100, 100);
          glutCreateWindow("Hello world!");
          glutDisplayFunc(displayMe);
          glutMainLoop();
          return 0;
      }
    $ g++ main.cpp -o firstOpenGlApp -lglut -lGLU -lGL
    $ ./firstOpenGlApp
    Source:
    1. http://www.codebind.com/linux-tutorials/install-opengl-ubuntu-linux/
    Установка Qt Creator под Windows
    Decision:
        https://visualstudio.microsoft.com/ru/downloads/ -> Инструменты для Visual Studio 2022 -> Инструменты сборки для Visual Studio 2022 -> aka.ms

    C:\Users\...\Downloads\qt C++ installer> vs_buildtools.exe --layout offline --lang en-us --add Microsoft.VisualStudio.Workload.VCTools --includeRecommended

        ...\offline\vs_setup.exe

        https://developer.microsoft.com/en-US/windows/downloads/windows-sdk/-> Getting started -> https://go.microsoft.com/fwlink/?linkid=2173746-> ...\22000.194.210911-1543.co_release_svc_prod1_WindowsSDK.iso -> Извлечь в текущую папку -> ...\22000.194.210911-1543.co_release_svc_prod1_WindowsSDK\Installers\X64 Debuggers And Tools-x64_en-us.exe -> ...\22000.194.210911-1543.co_release_svc_prod1_WindowsSDK\Installers\X86 Debuggers And Tools-x86_en-us.exe

        https://cmake.org/download/-> Binary distributions: -> Windows x64 Installer: Installer tool has changed. Uninstall CMake 3.4 or lower first! -> https://github.com/Kitware/CMake/releases/download/v3.22.0/cmake-3.22.0-windows-x86_64.msi

        ...\cmake-3.22.0-windows-x86_64.msi -> Add CMake to the system PATH for all users

        https://www.qt.io/offline-installers -> Windows Host -> \qt-opensource-windows-x86-5.12.11.exe -> Select Components -> Qt 5.12 -> MSVC 2017 32-bit -> MSVC 2017 64-bit -> Launch QT Creator -> Компьютер -> Свойства -> Дополнительные параметры системы -> Переменные среды ->  Системные переменные -> Path -> Изменить -> Создать -> C:\Qt\Qt5.12.11\Tools\QtCreator\bin -> Пуск -> QT Creator Community -> Инструменты -> Параметры
    Source:
    1. https://www.youtube.com/watch?v=2Scwa8KuNQU&t=79s
    Task:
    Установка Qt Creator под Ubuntu 20.04
    Decision:
    https://www.qt.io/download-qt-installer - Download:
    $ chmod u+x qt-unified-linux-x64-4.1.1-online.run
    $ ./qt-unified-linux-x64-4.1.1-online.run
    нужно выбрать компоненты
    Source:
    1. https://prognote.ru/articles/how-to-install-qt-5-on-linux-ubuntu
    Первый запуск на языке Си
    Decision:
    Начало (Welcome) - проекты - создаем проект - проект без Qt - приложение на языке Си - qmake - ok - проекты - запуск - запуск в терминале - ок - запуск (зеленый треугольник внизу или ctrl+r)
    Создание проекта QML
    Task:
    Создание плитки пятнашек
    Decision:
    Создать->приложение (qt quick)->application empty->qmake->ok->/->add new->qt->файл qml->ok
        Tile.qml:
    Rectangle {
        id: root
        color: "lightgreen"
        radius: 10
        border.color: "black"
        border.width: 1
        Text {
            id: _firstText
            anchors.centerIn: root
            text: "1"
            font {
                pointSize: Math.min(root.width, root.height) / 3
                bold: true
            }
        }
    }
        main.qml:
    Window {
        id: root
        width: 640
        height: 480
        visible: true
        title: qsTr("Hello World")
        Tile {
            width: root.width / 4
            height: root.height / 4
        }
    }
    Task:
    C:\Users\...\OneDrive\Документы\Projects\Cpp\Test\CMakeLists.txt:3: ошибка: The CMAKE_CXX_COMPILER: cl is not a full path and was not found in the PATH. To use the JOM generator with Visual C++, cmake must be run from a shell that can use the compiler cl from the command line.  This environment is unable to invoke the cl compiler.  To fix this problem, run cmake from the Visual Studio Command Prompt (vcvarsall.bat). Tell CMake where to find the compiler by setting either the environment variable "CXX" or the CMake cache entry CMAKE_CXX_COMPILER to the full path to the compiler, or to the compiler name if it is in the PATH.
    :-1: ошибка: Процесс CMake завершился с Решением 1.
    Decision:
        Панель управления -> visual studio 2022 -> Удаление программы -> my.visualstudio.com-> Build Tools for Visual Studio 2019 (version 16.9) -> Download
    C:\Users\...\Downloads\qt C++ installer> vs_buildtools.exe --layout offline --lang en-us --add Microsoft.VisualStudio.Workload.VCTools --includeRecommended

        ...\offline\vs_setup.exe
    Task:
        qrc:/main.qml:13:9: Unable to assign [undefined] to double
        qrc:/main.qml:12:9: Unable to assign [undefined] to QColor
        QQmlApplicationEngine failed to load component
        qrc:/main.qml:3 module "StyleSettings" is not installed
    Task:
    Подгрузим нашу папку StyleSettings в qml
    Decision:
        main.cpp
    ...
        QQmlApplicationEngine engine;
        engine.addImportPath(":/qml");
        const QUrl url(QStringLiteral("qrc:/main.qml")
    ...

        main.qml
    import QtQuick 2.12
    import QtQuick.Window 2.12
    import StyleSettings 1.0
    Window {
        width: 640
        height: 480
        visible: true
        title: qsTr("Hello World")
        Rectangle {
            id: _background
            z: -100
            anchors.fill: parent
            color: Style.backgroundColor
            opacity: Style.emphasisOpacity
        }
        /*Style {
            id: _style
        }*/
        Component.onCompleted: {
            console.log(Style)
        }
    }

        qmdir
    module StyleSettings
    singleton Style 1.0 Style.qml
        Addressbook.pro
    ...
        # Additional import path used to resolve QML modules in Qt Creators code model
        QML_IMPORT_PATH += $$PWD/qml
    ...
    Task:
    После того как написали програамму сервера на классическм процессоре, подключим CPU ядра
    Decision:
        https://developer.nvidia.com/opencl - OpenCL Multi Threads - Download - Windows (x64) - излечь - C:\Users\david\Downloads\NVIDIA GPU Computing SDK\OpenCL\common\inc\CL - Копируем CL - Вставляем в наш проект - C:\Users\david\Downloads\NVIDIA GPU Computing SDK\OpenCL\common\lib\x64\ - Копируем OpenCL.lib - вставляем в наш проект - Поиск - opencl.dll - C:\Windows\SysWOW64 - коипруем OpenCL.dll и вставляем в наш проект \build-main-Desktop_Qt_5_12_11_MSVC2017_32bit-Debug\debug\-
    ...
    //#pragma comment (lib, "Mswsock.lib")
    #pragma comment(lib, "OpenCL.lib")
    #include "CL\cl.h"
    struct TPot{
    ...
    Task:
    :-1: error: LNK1104: cannot open file 'OpenCL.lib'
    Decision:
        main.pro
    ...
    CONFIG -= app_bundle
    LIBS += C:\Users\...\Documents\Projects\Cpp\Git\CPP-WebServer0\main\OpenCL.lib
    # You can make your code fail to compile if it uses deprecated APIs

Mini-Projects
    Task:
    Добавление и удаление имен в списке
    Decision:
    #include <iostream>
    #include <cmath>
    #include <fstream>
    #include <cstring>
    #include <vector>
    using namespace std;
    int main() {
        int q;
        string w;
        vector <string> name;
        for (;true;){ // besconechni cikl
            cout<<"1-dobavit\n"<<"2-udalit\n"<<"3-pechay\n";
            cin>>q;
            if(q==1){
                cout<<"vvedite imya:";
                cin>>w;
                name.push_back(w);
            }
            else{
                if(q==2){
                    cout<<"vvedite imya:";
                    cin>>q;
                    name.erase(name.begin() + (q-1));
                }
                else{
                    if(q==3){
                        for(int i=0;i<name.size();i++){
                            cout<<i+1<<" "<<name[i]<<endl;
                        }
                    }
                }
            }
        }
        return 0;
    }
    Task:
    Преобразовать следующую программу:
    #include<stdio.h>
    #include<conio.h>
    void main()
    {
     int j; char k; double a;
     j=21; k=’m’; a=3.1415926;
     printf("PRINT INTEGER j =%d\n",j);
     printf("PRINT SYMBOL k=%c\n" ,k);
     printf("PRINT LONG FLOAT a=%lf \n",a);
     printf("PRINT STRING");
     getch();
    }
    так, чтобы в первой строке было напечатано:
    Value of symbol k = R, Value of integer j = -14,
     во второй строке:
    Value of float variable а is 1.652730E+02
    в экспоненциальной форме (по формату %е), а в третьей строке текст:
     END of PROGRAMM.
    Decision:
    #include<stdio.h>
    #include<curses.h>
    void main()
    {
      int j; char k; double a;
      j=21; k='R'; a=1.652730E+02;
      printf("Value of symbol k=%c\n",k);
      printf("Value of float variable a is %e\n",a);
      printf("End of programm\n");
      getch();
    } 
    Task:
    Составить программу, печатающую таблицу факториалов от 0 до 7. В программе должна быть создана и использована функция, вычисляющая факториал своего аргумента
    Decision:
    #include<stdio.h>
    /*void main()
    {
        int n;
        for (int i=1;i<=7;i++)
        {
            //printf("%d\n",i);
            f=f*i;
            printf("%d!\t%d\n",i,f);
        }
    }*/
    int fact(int n, int j)
    {
        /*n=n*j;
        return n;*/
        return n*j;
    }
    void main(void)
    {
        int f=1, i;
        for (i=1;i<=7;i++)
        {
            f=fact(f,i);
            printf("%d!\t%d\n",i,f);
        }
    }
    Task:
    Составить программу вычисления факториала n! = 1*2*3*...*n тремя способами - с использованием цикла while, цикла do-while и цикла for.
    Decision:
    #include<stdio.h>
    void main()
    {
      int n,j=1,i=1;
      printf("Введите число: ");scanf("%d",&n);
      while (i<=n)
      {
        j*=i;
        i++;
      }
      printf("%d!=%d\n",n,j);
    } 
    Decision:
    #include<stdio.h>
    void main()
    {
      int n,j,i;
      printf("Введите число: ");scanf("%d",&n);
      for (j=1,i=1; i<=n; i++)
      {       
        j*=i;
      }
      printf("%d!=%d\n",n,j);
    }
    Decision:
    #include<stdio.h>
    void main()
    {
      int n,j=1,i=1;
      printf("Введите число: ");scanf("%d",&n);
      do
      {
        j*=i; i++;
      }
      while (i<=n);
      printf("%d!=%d\n",n,j);
    } 
    Task:
    Написать программу, которая формирует единичную матрицу и выводит ее на экран
    Decision:
    #include<stdio.h>
    #include<string.h>
    void main()
    {
        int i,j,M[5][5];
        for(i=0;i<5;i++){
            for(j=0;j<5;j++){
                if(i==j){
                    M[i][j]=1;
                } else{
                    M[i][j]=0;
                }
            }
        }
        for(i=0;i<5;i++){
            for(j=0;j<5;j++){
                printf("%d",M[i][j]);
            }
            printf("\n");
        }
    }
    Task:
    Напишите программу, которая отсортирует числа формата double хранящихся в текстовом файле размером 1Гб (одно число в одной строке).
    Пример
    ●   8.33891e+307
    ●   1.26192e+308
    ●   
    ●   8.19572e+307    
    ●   ...
    ●   0
    1.64584e+304
    Программа должна использовать не более 100Мб оперативной памяти, и работать не дольше 25-30 минут (на 2Гц современном одноядерном процессоре).
    Обязательные параметры: <имя файла не отсортированного> <имя файла отсортированного> 
    Также должен быть написан генератор не отсортированного 1Гб файла с числами формата double
    Task:
    Написать собственную реализацию shared_mutex поддерживающий рекурсию. Не используя C14. 
    Использовать платформонезависимый код – средства stl и boost (но не использовать  shared_mutex).
    Task:
    Написать алгоритм поиска текста по маске с wildcards (можно просто функцию куда передается два параметра - строка поиска и строка с маской). Wildcards содержит символы * и ?
    Task:
    Представим что есть интерфейс к БД: 
    struct i_db
    {
        bool begin_transaction();
        bool commit_transaction();
        bool abort_transaction();
        std::string get(const std::string& key);
        std::string set(const std::string& key, const std::string& data);
        std::string delete(const std::string& key);
    }
    Написать реализацию кеша для БД, обратить внимание на многопоточность и на транзакционную модель работы с БД. 