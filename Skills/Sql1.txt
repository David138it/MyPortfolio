Mail for feedback: David138it@gmail.com

Администрирование базы данных
	Task:
	Установить PostgreSql
	Decision:
	$ sudo dnf install -y https://download.postgresql.org/pub/repos/yum/reporpms/EL-9-x86_64/pgdg-redhat-repo-latest.noarch.rpm
  	$ sudo dnf -qy module disable postgresql
  	$ sudo dnf install -y postgresql15-server
  	$ sudo /usr/pgsql-15/bin/postgresql-15-setup initdb
  	$ sudo systemctl enable postgresql-15
  	$ sudo -S sudo systemctl start postgresql-15
  	Source:
  	https://www.postgresql.org/download/linux/redhat/
  	Task:
  	Install PgAdmin 4
  	Decision:
  	$ sudo rpm -i https://ftp.postgresql.org/pub/pgadmin/pgadmin4/yum/pgadmin4-redhat-repo-2-1.noarch.rpm
  	$ sudo yum install -y pgadmin4
  	$ sudo yum install -y pgadmin4-desktop
  	$ sudo yum install -y pgadmin4-web
  	$ sudo /usr/pgadmin4/bin/setup-web.sh
  	$ sudo yum upgrade -y pgadmin4
  	Source:
  	https://www.pgadmin.org/download/pgadmin-4-rpm/
	Task:
	Работа с пользователями в PostgreSQL
	Decision:
	sudo -u postgres -H -- psql -d template1 -c "CREATE USER YOUR-USERNAME WITH PASSWORD 'USERSPASSWORD';"
	sudo -u postgres -H -- psql -d template1 -c "CREATE database NAMEDB;"
	sudo -u postgres -H -- psql -d template1 -c "GRANT ALL PRIVILEGES ON DATABASE "NAMEDB" to YOUR-USERNAME;"
	sudo -u postgres -H -- psql -d template1 -c "\c NAMEDB;"
	sudo -u postgres -H -- psql -d template1 -c "GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO "YOUR-USERNAME";"
	Source:
	https://www.dmosk.ru/miniinstruktions.php?mini=postgresql-users&ysclid=lig0a2xuou515754413#create
	Task:
	выполнить подключение к удаленной БД с помощью инструмента администрирования
	Decision:
	$ mysql -host=ubuntu-VirtualBox
	Task:
	выполнить корректную остановку, старт БД
	Decision:
	$ sudo systemctl stop mysql
	Task:
	проверка состояния БД
	Decision:
	$ sudo systemctl status mysql
	Task:
	оценить заполненность табличного пространства
	Decision:
	mysql> show databases;	
	Task:
	$ sudo apt-get -y install postgresql
	    E: Could not get lock /var/lib/dpkg/lock-frontend. It is held by process 4927 (unattended-upgr)
	    N: Be aware that removing the lock file is not a solution and may break your system.
	    E: Unable to acquire the dpkg frontend lock (/var/lib/dpkg/lock-frontend), is another process using it?
	Decision:
	$ ps aux | grep -i apt
	    root        4891  0.0  0.0   2616   536 ?        Ss   19:52   0:00 /bin/sh /usr/lib/apt/apt.systemd.daily install
	    root        4896  0.0  0.0   2616  1652 ?        S    19:52   0:00 /bin/sh /usr/lib/apt/apt.systemd.daily lock_is_held install
	    ubuntu      6172  0.0  0.0  19396   660 pts/1    S+   19:56   0:00 grep --color=auto -i apt
	$ sudo killall apt apt-get
	    apt: no process found
	    apt-get: no process found
	$ ps aux | grep -i apt
	    ubuntu      6233  0.0  0.0  19396   660 pts/1    S+   19:59   0:00 grep --color=auto -i apt
	$ sudo apt -y install postgresql
	Task:
	$ sudo sh -c 'echo "deb https://ftp.postgresql.org/pub/pgadmin/pgadmin4/apt/$(lsb_release -cs) pgadmin4 main" > /etc/apt/sources.list.d/pgadmin4.list && apt update'
	    ...                                   
	    Err:12 http://ppa.launchpad.net/wireshark-dev/stable/ubuntu focal
	    ...
	    All packages are up to date.
	    W: Failed to fetch http://ppa.launchpad.net/wireshark-dev/stable/ubuntu/dists/focal/InRelease  Temporary failure resolving 'ppa.launchpad.net'
	    W: Some index files failed to download. They have been ignored, or old ones used instead.
	Decision:
	$ cat /etc/apt/sources.list.d/pgadmin4.list
	deb https://ftp.postgresql.org/pub/pgadmin/pgadmin4/apt/focal pgadmin4 main
	$ sudo vim /etc/apt/sources.list.d/pgadmin4.list
	$ cat /etc/apt/sources.list.d/pgadmin4.list
	#deb https://ftp.postgresql.org/pub/pgadmin/pgadmin4/apt/focal pgadmin4 main
	$ sudo apt-get clean
	$ sudo apt-get update
	    ...                   
	    Reading package lists... Done
	$ sudo sh -c 'echo "deb https://ftp.postgresql.org/pub/pgadmin/pgadmin4/apt/$(lsb_release -cs) pgadmin4 main" > /etc/apt/sources.list.d/pgadmin4.list && apt update'
	Task:
	Ошибки в время установки и настройки postgresql
	    Skipping acquire of configured file 'main/binary-i386/Packages' as repository 'http://apt.postgresql.org/pub/repos/apt focal-pgdg InRelease' doesn't support architecture 'i386'
	$ sudo sh -c 'echo "deb http://apt.postgresql.org/pub/repos/apt $(lsb_release -cs)-pgdg main" > /etc/apt/sources.list.d/pgdg.list'
	$ wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | sudo apt-key add -
	    OK
	$ sudo apt-get update
	    ...                    
	    Reading package lists... Done
	    N: Skipping acquire of configured file 'main/binary-i386/Packages' as repository 'http://apt.postgresql.org/pub/repos/apt focal-pgdg InRelease' doesn't support architecture 'i386'
	Decision:
	$ cat /etc/apt/sources.list.d/pgdg.list
	deb http://apt.postgresql.org/pub/repos/apt focal-pgdg main
	$ sudo vim /etc/apt/sources.list.d/pgdg.list
	$ cat /etc/apt/sources.list.d/pgdg.list
	deb [arch=amd64] http://apt.postgresql.org/pub/repos/apt/ focal-pgdg main
	$ sudo apt-get update
	    ...                                      
	    Reading package lists... Done
	Task:
	    Could not get lock /var/lib/dpkg/lock-frontend. It is held by process 4927 (unattended-upgr). Be aware that removing the lock file is not a solution and may break your system. Unable to acquire the dpkg frontend lock (/var/lib/dpkg/lock-frontend), is another process using it?
	$ sudo apt-get -y install postgresql
	    E: Could not get lock /var/lib/dpkg/lock-frontend. It is held by process 4927 (unattended-upgr)
	    N: Be aware that removing the lock file is not a solution and may break your system.
	    E: Unable to acquire the dpkg frontend lock (/var/lib/dpkg/lock-frontend), is another process using it?
	Decision:
	$ ps aux | grep -i apt
	    root        4891  0.0  0.0   2616   536 ?        Ss   19:52   0:00 /bin/sh /usr/lib/apt/apt.systemd.daily install
	    root        4896  0.0  0.0   2616  1652 ?        S    19:52   0:00 /bin/sh /usr/lib/apt/apt.systemd.daily lock_is_held install
	    ubuntu      6172  0.0  0.0  19396   660 pts/1    S+   19:56   0:00 grep --color=auto -i apt
	$ sudo killall apt apt-get
	    apt: no process found
	    apt-get: no process found
	$ ps aux | grep -i apt
	    ubuntu      6233  0.0  0.0  19396   660 pts/1    S+   19:59   0:00 grep --color=auto -i apt
	$ sudo apt -y install postgresql
	    Reading package lists... Done
	    Building dependency tree       
	    Reading state information... Done
	    ...
	    Selecting previously unselected package libjson-perl.
	Task:
	    Failed to fetch http://ppa.launchpad.net/wireshark-dev/stable/ubuntu/dists/focal/InRelease  Temporary failure resolving 'ppa.launchpad.net'. Some index files failed to download. They have been ignored, or old ones used instead.
	$ sudo curl https://www.pgadmin.org/static/packages_pgadmin_org.pub | sudo apt-key add
	      % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
	                                     Dload  Upload   Total   Spent    Left  Speed
	    100  3935  100  3935    0     0    633      0  0:00:06  0:00:06 --:--:--   824
	    OK
	$ sudo sh -c 'echo "deb https://ftp.postgresql.org/pub/pgadmin/pgadmin4/apt/$(lsb_release -cs) pgadmin4 main" > /etc/apt/sources.list.d/pgadmin4.list && apt update'
	    Hit:1 http://archive.ubuntu.com/ubuntu focal InRelease
	    Hit:2 http://ru.archive.ubuntu.com/ubuntu bionic InRelease
	    Get:11 https://ftp.postgresql.org/pub/pgadmin/pgadmin4/apt/focal pgadmin4/main all Packages [1957 B]                                     
	    Err:12 http://ppa.launchpad.net/wireshark-dev/stable/ubuntu focal InRelease                                                              
	      Temporary failure resolving 'ppa.launchpad.net'
	    Fetched 338 kB in 10s (33.3 kB/s)
	    Reading package lists... Done
	    Building dependency tree       
	    Reading state information... Done
	    All packages are up to date.
	    W: Failed to fetch http://ppa.launchpad.net/wireshark-dev/stable/ubuntu/dists/focal/InRelease  Temporary failure resolving 'ppa.launchpad.net'
	    W: Some index files failed to download. They have been ignored, or old ones used instead.
	Decision:
	$ cat /etc/apt/sources.list.d/pgadmin4.list
	deb https://ftp.postgresql.org/pub/pgadmin/pgadmin4/apt/focal pgadmin4 main
	$ sudo vim /etc/apt/sources.list.d/pgadmin4.list
	$ cat /etc/apt/sources.list.d/pgadmin4.list
	#deb https://ftp.postgresql.org/pub/pgadmin/pgadmin4/apt/focal pgadmin4 main
	$ sudo apt-get clean
	$ sudo apt-get update
	    ...                   
	    Reading package lists... Done
	$ sudo sh -c 'echo "deb https://ftp.postgresql.org/pub/pgadmin/pgadmin4/apt/$(lsb_release -cs) pgadmin4 main" > /etc/apt/sources.list.d/pgadmin4.list && apt update'
	    ...
	    Reading package lists... Done
	    Building dependency tree       
	    Reading state information... Done
	    All packages are up to date.
	Task:
	$ sudo mysql -u root
	    [sudo] password for ar:
	    ERROR 2002 (HY000): Can't connect to local MySQL server through socket '/var/run/mysqld/mysqld.sock' (2)
	Decision:
	$ sudo service mysql status
	     * MySQL is stopped.
	$ sudo service mysql start
	     * Starting MySQL database server mysqld                                                                                su: warning: cannot change directory to /nonexistent: No such file or directory
	                                                                                                                     [ OK ]
	$ sudo service mysql status
	     * /usr/bin/mysqladmin  Ver 8.0.28-0uu0.20.04.3 for Linux on x86_64 ((uu))
	    Copyright (c) 2000, 2022, Oracle and/or its affiliates.
	    Oracle is a registered trademark of Oracle Corporation and/or its
	    affiliates. Other names may be trademarks of their respective
	    owners.
	    Server version          8.0.28-0uu0.20.04.3
	    Protocol version        10
	    Connection              Localhost via UNIX socket
	    UNIX socket             /var/run/mysqld/mysqld.sock
	    Uptime:                 24 sec
	    Threads: 2  Questions: 8  Slow queries: 0  Opens: 436  Flush tables: 3  Open tables: 27  Queries per second avg: 0.333
	$ sudo mysql -u root
	    Welcome to the MySQL monitor.  Commands end with ; or \g.
	    Your MySQL connection id is 12
	    Server version: 8.0.28-0uu0.20.04.3 (uu)
	    Copyright (c) 2000, 2022, Oracle and/or its affiliates.
	    Oracle is a registered trademark of Oracle Corporation and/or its
	    affiliates. Other names may be trademarks of their respective
	    owners.
	    Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.
	Task:
	Создание и подключение к БД
	Decision:
	postgres-# \! chcp 1251
	postgres-# \l
	postgres-# CREATE DATABASE starter;
	postgres-# DROP DATABASE starter;
	postgres-# CREATE DATABASE starter;
	postgres-# \c starter
	Task:
	После отключения света в здании служба OracleServiceНАЗВАНИЕСИСТЕМЫ не запускается. При подключении к БСР клиента на сервере выходит следующая ошибка:
	ОШИБКА ORA-01033. ORACLE INITIALIZATION OR SHUTDOWN IN PROGRESS
	Не помогает перезапуск службы ORACLE и перезагрузка сервера.
	Также пробовали подключиться и настроить базу в командной строке через sql plus. После ввода команды выдает ошибку:
	C:\>sqlplus
	Enter user-name: СОКРАЩЕННОЕОЕИМЯПОЛЬЗОВАТЕЛЯ as ПОЛНОЕИМЯПОЛЬЗОВАТЕЛЯ
	SQL> alter pluggable database all open;
	alter pluggable database all open
	*
	ERROR at line 1:
	ORA-00940: invalid ALTER command
	Нужно сделать рестарт базы
	Decision:
	C:\>sqlplus /nolog
	SQL> connect СОКРАЩЕННОЕОЕИМЯПОЛЬЗОВАТЕЛЯ/pass@НАЗВАНИЕСИСТЕМЫ as ПОЛНОЕИМЯПОЛЬЗОВАТЕЛЯ
	ERROR:
	ORA-01017: invalid username/password; logon denied
	SQL> conn СОКРАЩЕННОЕОЕИМЯПОЛЬЗОВАТЕЛЯ/oracle@НАЗВАНИЕСИСТЕМЫ as ПОЛНОЕИМЯПОЛЬЗОВАТЕЛЯ
	SQL> startup mount
	ORA-01081: cannot start already-running ORACLE - shut it down first
	SQL> shutdown immediate
	ORA-01109: database not open
	Database dismounted.
	ORACLE instance shut down.
	SQL> startup mount
	SQL> col file format a5;
	SQL> col name format a20;
	SQL> col status format a10;
	SQL> select file#,name,status from v$datafile;
	     FILE# NAME                 STATUS
	---------- -------------------- ----------
	         1 C:\ORACLE\ORADATA\GA SYSTEM
	           S\SYSTEM01.DBF
	         2 C:\ORACLE\ORADATA\GA ONLINE
	           S\UNDOTBS01.DBF
	         3 C:\ORACLE\ORADATA\GA ONLINE
	           S\CWMLITE01.DBF
	         4 C:\ORACLE\ORADATA\GA ONLINE
	           S\DRSYS01.DBF
	     FILE# NAME                 STATUS
	---------- -------------------- ----------
	         5 C:\ORACLE\ORADATA\GA ONLINE
	           S\EXAMPLE01.DBF
	         6 C:\ORACLE\ORADATA\GA ONLINE
	           S\INDX01.DBF
	         7 C:\ORACLE\ORADATA\GA ONLINE
	           S\ODM01.DBF
	         8 C:\ORACLE\ORADATA\GA ONLINE
	     FILE# NAME                 STATUS
	---------- -------------------- ----------
	           S\TOOLS01.DBF
	         9 C:\ORACLE\ORADATA\GA ONLINE
	           S\USERS01.DBF
	        10 C:\ORACLE\ORADATA\GA ONLINE
	           S\XDB01.DBF
	        11 C:\ORACLE\ORADATA\GA ONLINE
	           S\TBLS_BSR.ORA
	     FILE# NAME                 STATUS
	---------- -------------------- ----------
	        12 C:\ORACLE\ORADATA\GA ONLINE
	           S\DELO_D.DAT
	        13 C:\ORACLE\ORADATA\GA ONLINE
	           S\DELO_I.DAT
	        14 C:\ORACLE\ORADATA\GA ONLINE
	           S\DELO_O.DAT
	        15 C:\ORACLE\ORADATA\GA ONLINE
	           S\KADR_D.DAT
	     FILE# NAME                 STATUS
	---------- -------------------- ----------
	        16 C:\ORACLE\ORADATA\GA ONLINE
	           S\KADR_I.DAT
	        17 C:\ORACLE\ORADATA\GA ONLINE
	           S\KADR_O.DAT
	        18 C:\ORACLE\ORADATA\GA ONLINE
	           S\ARCH_D.DAT
	        19 C:\ORACLE\ORADATA\GA ONLINE
	     FILE# NAME                 STATUS
	---------- -------------------- ----------
	           S\ARCH_I.DAT
	        20 C:\ORACLE\ORADATA\GA ONLINE
	           S\EDS_D.DAT
	        21 C:\ORACLE\ORADATA\GA ONLINE
	           S\EDS_I.DAT
	        22 C:\ORACLE\ORADATA\GA ONLINE
	           S\EDS_O.DAT
	     FILE# NAME                 STATUS
	---------- -------------------- ----------
	        23 C:\ORACLE\ORADATA\GA ONLINE
	           S\.ORA
	        24 C:\ORACLE\ORADATA\GA SYSTEM
	           S\SYSTEM02.ORA
	        25 C:\ORACLE\ORADATA\GA SYSTEM
	           S\SYSTEM03.ORA
	25 rows selected.
	SQL> recover datafile 1;
	SQL> select file#,name,status from v$datafile;
	     FILE# NAME                 STATUS
	---------- -------------------- ----------
	         1 C:\ORACLE\ORADATA\GA SYSTEM
	           S\SYSTEM01.DBF
	         2 C:\ORACLE\ORADATA\GA ONLINE
	           S\UNDOTBS01.DBF
	         3 C:\ORACLE\ORADATA\GA ONLINE
	           S\CWMLITE01.DBF
	         4 C:\ORACLE\ORADATA\GA ONLINE
	           S\DRSYS01.DBF
	     FILE# NAME                 STATUS
	---------- -------------------- ----------
	         5 C:\ORACLE\ORADATA\GA ONLINE
	           S\EXAMPLE01.DBF
	         6 C:\ORACLE\ORADATA\GA ONLINE
	           S\INDX01.DBF
	         7 C:\ORACLE\ORADATA\GA ONLINE
	           S\ODM01.DBF
	         8 C:\ORACLE\ORADATA\GA ONLINE
	     FILE# NAME                 STATUS
	---------- -------------------- ----------
	           S\TOOLS01.DBF
	         9 C:\ORACLE\ORADATA\GA ONLINE
	           S\USERS01.DBF
	        10 C:\ORACLE\ORADATA\GA ONLINE
	           S\XDB01.DBF
	        11 C:\ORACLE\ORADATA\GA ONLINE
	           S\TBLS_BSR.ORA
	     FILE# NAME                 STATUS
	---------- -------------------- ----------
	        12 C:\ORACLE\ORADATA\GA ONLINE
	           S\DELO_D.DAT
	        13 C:\ORACLE\ORADATA\GA ONLINE
	           S\DELO_I.DAT
	        14 C:\ORACLE\ORADATA\GA ONLINE
	           S\DELO_O.DAT
	        15 C:\ORACLE\ORADATA\GA ONLINE
	           S\KADR_D.DAT
	     FILE# NAME                 STATUS
	---------- -------------------- ----------
	        16 C:\ORACLE\ORADATA\GA ONLINE
	           S\KADR_I.DAT
	        17 C:\ORACLE\ORADATA\GA ONLINE
	           S\KADR_O.DAT
	        18 C:\ORACLE\ORADATA\GA ONLINE
	           S\ARCH_D.DAT
	        19 C:\ORACLE\ORADATA\GA ONLINE
	     FILE# NAME                 STATUS
	---------- -------------------- ----------
	           S\ARCH_I.DAT
	        20 C:\ORACLE\ORADATA\GA ONLINE
	           S\EDS_D.DAT
	        21 C:\ORACLE\ORADATA\GA ONLINE
	           S\EDS_I.DAT
	        22 C:\ORACLE\ORADATA\GA ONLINE
	           S\EDS_O.DAT
	     FILE# NAME                 STATUS
	---------- -------------------- ----------
	        23 C:\ORACLE\ORADATA\GA ONLINE
	           S\.ORA
	        24 C:\ORACLE\ORADATA\GA SYSTEM
	           S\SYSTEM02.ORA
	        25 C:\ORACLE\ORADATA\GA SYSTEM
	           S\SYSTEM03.ORA
	25 rows selected.
	SQL> alter database open;
	Task:
	В ПОДСИСТЕМА не грузятся на сайт 200 дел. Смотрим лог файл:
	$ cat importer.log.xml
	...
	  <Error ReadableDateTime="23.01.2023 12:51:31" FileTimeUtc="133189230912753002">
	    <Message>Îøèáêà ïðè âûïîëíåíèè çàïðîñà:
	BEGIN BSR.PK_BSR.CTX_Sinxronize; END;
	Òåêñò îøèáêè:
	ORA-20000: Oracle Text error:
	DRG-50857: oracle error in dreii0fsh
	ORA-01653: unable to extend table BSR.DR$CTX_SRH$I by 8192 in tablespace SYSTEM
	ORA-06512: at "CTXSYS.DRUE", line 157
	ORA-06512: at "CTXSYS.CTX_DDL", line 1328
	ORA-06512: at "BSR.PK_BSR", line 313
	ORA-06512: at line 1
	</Message>
	    <Details>System.Exception: Îøèáêà ïðè âûïîëíåíèè çàïðîñà:
	BEGIN BSR.PK_BSR.CTX_Sinxronize; END;
	Òåêñò îøèáêè:
	ORA-20000: Oracle Text error:
	DRG-50857: oracle error in dreii0fsh
	ORA-01653: unable to extend table BSR.DR$CTX_SRH$I by 8192 in tablespace SYSTEM
	ORA-06512: at "CTXSYS.DRUE", line 157
	ORA-06512: at "CTXSYS.CTX_DDL", line 1328
	ORA-06512: at "BSR.PK_BSR", line 313
	ORA-06512: at line 1
	&#xD;
	   â ImpFunktions.Database.DbaseIns(String cmdString)&#xD;
	   â ImpFunktions.Importer.synchronize()</Details>
	  </Error>
	пуск - все программы - oracle orahome92 - enterprize manager console - ок - databases - gas -  system - oracle - storage - tablespaces
	Проблема из за того, что у Вас закончилось свободное оракловое ТП SYSTEM и Tbls_bsr, которые надо увеличить вручную путем добавления DATA файла. "Флаг" в чек боксе Авторасширение не поможет.
	Decision:
	Обязательно делайте бэкап перед любыми действиями с базой. Дважды щелкните ЛКМ табличное пространство SYSTEM и добавьте в него второй файл. Oracle автоматически подставит расширение ORA. Исправьте его на DBF перед сохранением. 
	system - add datafile - name - SYSTEM04.ORA - file size - 4096MB - storage - automatically extend datafile when full - increment - 10240KB - value - 32767MB - ok - перезапустить службу BSRImport - В админке обновлять авоматический импорт из СДП
	Task:
	Можно сделать это в командной строке, добавив дополнительный файл данных к табличному пространству и изменив размер текущего файла данных, Некоторые версии Oracle не позволяют такого!
	Decision:
	ALTER TABLESPACE USERS ADD DATAFILE '/u01/oradata/orcl/users02.dbf' size 25m;
	ALTER DATABASE DATAFILE '/u01/oradata/orcl/users01.dbf' resize 50M;
	Необходимо добавить новый датафайл к табличному пространству SYSTEM.


Выборка данных
	Task:
	Схема базы данных на MSSQL сервер состоит из 4 таблиц:
	1. ORGANIZATIONS – список организаций
	2. CREDIT_Portfolio – кредитный портфель
	3. DOCS_Numbers – номера документов организации
	4. DOCS_Data – данные из документов
	Таблица ORGANIZATIONS содержит: номер организации (ID_ORG), ИНН (INN), наименование организации (CLIENT_NAME),
	Таблица CREDIT_Portfolio содержит: номер кредита(ID_CREDIT), код подразделения, выдавшего кредит (DIVISION), ИНН (INN), тип кредита (CREDIT_TYPE), сумму кредита (CREDIT_SUM) и процентную ставку (CREDIT_RATE)
	Таблица DOCS_Numbers содержит: номер документа (ID_DOCS), номер организации (CODE), тип документа(DOCS_TYPE) и дата документа (DOCS_DATE)
	Таблица DOCS_Data содержит: уникальный номер записи (ID_DATA), номер документа (ID_DOCS), строка документа (ROW_DOCS), значение строки (NM)
	Условие запроса: Требуется получить среднюю процентную ставку для организации и вывести значение из документа «Финансовая отчетность» из строки с номером «2000».
	Task:
	осуществить выборку из произвольной таблицы
	Decision:
	mysql> SELECT * FROM users;
	Task:
	посчитать количество записей в таблице
	Decision:
	mysql> SELECT COUNT(*) FROM users;
	Task:
	Написать запрос, отображающий список покупателей, которые заказывали один и тот же продукт более 3-х раз за указанный период времени. Запрос должен отображать наименование покупателя, наименование продукта и количество раз, которое данный продукт был заказан. Отсортировать запрос по полю, которое отображает количество раз закупленного продукта.
	Task:
	Написать запрос, который отображает список объектов БД NorthWind, в которых встречается заданный фрагмент текста. Запрос должен отображать наименование объекта и его тип.
	Task:
	Запрос SQL:
	SELECT a.ln, b.zip, c.city 
	FROM a, b, c 
	WHERE a.ln = b.ln;
	Каждая из таблиц «a», «b» и «c» содержит по 100 строк; первичным ключом для таблиц «a» и «b» является столбец «ln». Максимальное количество строк, которое может возвратить данный запрос, = …
	1. 100
	2. 100000
	3. 1
	4. 1000000
	5. 10000
	Task:
	Вы хотите найти сотрудников-однофамильцев. Какой запрос позволит решить поставленную задачу?
	1. select first_name, last_name, department_id, job_id
	from employees
	where last_name=last_name;
	2. select e.first_name, e.last_name, e.department_id, e.job_id
	from  employees e, employees p
	where e.last_name=p.last_name;
	3. select e.first_name, e.last_name, e.department_id, e.job_id
	from  employees e, employees p
	where e.last_name=p.last_name
	and e.employee_id=p.employee_id;
	4. select e.first_name, e.last_name, e.department_id, e.job_id
	from  employees e, employees p
	where e.last_name=p.last_name
	and e.employee_id<>p.employee_id;
	5. select e.first_name, e.last_name, e.department_id, e.job_id
	from  employees e, employees p
	where e.employee_id<>p.employee_id;
	Task:
	База данных содержит следующие таблицы и поля: employees(employee_id, first_name, last_name, salary, manager_id, department_id), departments(department_id, department_name, manager_id, location_id). Необходимо составить отчет, содержащий имена всех сотрудников, и названия отделений, в которых они работают. В этот отчет должны быть включены те сотрудники, которые не приписаны ни к одному из отделений. Однако отчет НЕ должен содержать названий отделений без сотрудников. Какой запрос позволит решить поставленную задачу?
	1. select first_name||last_name name, department_name
	from employees left join departments on (department_id);
	2. select first_name||last_name name, department_name
	from employees full join departments using (department_id);
	3. select first_name||last_name name, department_name
	from employees cross join departments using (department_id);
	4. select first_name||last_name name, department_name
	from employees e right join departments on (e.department_id=d.department_id);
	5. select first_name||last_name name, department_name
	from employees e, departments d
	where e.department_id=d.department_id(+);
	Task:
	Запрос SQL:
	SELECT dept_no, AVG(MONTHS_BETWEEN(SYSDATE, hiredate)) 
	FROM emp
	WHERE AVG(MONTHS_BETWEEN(SYSDATE, hiredate)) > 60
	GROUP BY dept_no 
	ORDER BY AVG(MONTHS_BETWEEN(SYSDATE, hiredate));
	Причина, вследствие которой запрос SQL вызывает ошибку:
	1. групповые функции не могут содержать вложенные однострочные функции
	2. групповые функции нельзя использовать в предложении WHERE
	3. групповые функции нельзя использовать в предложении ORDER BY
	4. групповые функции нельзя использовать в списке выборки команды SELECT
	Task:
	Выборка данных
	Decision:
	starter=# SELECT * FROM travelers LIMIT 25;
	starter=# SELECT surname FROM travelers OFFSET 15;
	starter=# SELECT name, email FROM travelers FETCH FIRST 20 ROW ONLY;
	starter=# SELECT name, surname FROM travelers ORDER BY name ASC;
	starter=# SELECT name, email FROM travelers WHERE gender = 'Female';
	starter=# SELECT * FROM travelers WHERE name IN ('Mark', 'Trisha', 'Raymond');
	starter=# SELECT country, email FROM travelers WHERE name BETWEEN 'A' AND 'S';
	starter=# SELECT email, surname FROM travelers WHERE email LIKE '%.net';
	Task:
	В целях конфиденциальности авиакомпания потребовала не выгружать номера телефонов целиком. Выведите идентификаторы пассажиров и номера их телефонов, заменив в номерах телефонов все цифры, кроме первой и последних двух, на звездочки, сформировав таким образом строку '+7********35'.
	В выборке должны присутствовать два атрибута — id, phone.
	Decision:
	select id, phone,
	    --phone
	    --substr(phone,-2) as p1,
	    --substr(phone,1,2) as p2,
	    substr(phone,1,2) || '********' || substr(phone,-2) as phone
	from clients
	Task:
	Найдите билеты на рейсы из аэропорта Саратова (код аэропорта RTW). В выборке должен присутствовать один атрибут - id.
	Decision:
	/*select id as id_trips, departure
	from trips
	where departure = 'RTW' and status = 'Arrived';*/
	select id --, trip_id
	from tickets
	--where trip_id = 'LL4S1G8PQW';
	where trip_id = (select id as id_trips
	    from trips
	    where departure = 'RTW' and status = 'Arrived');
	Task:
	Найдите самолеты, построенные позже 1990 года и хотя бы раз слетавшие в Домодедово (код аэропорта DME). В выборке должны присутствовать три атрибута: id, model_name, production_year.
	Decision:
	select id, model_name, production_year
	from airliners 
	where id in (select airliner_id --, status, arrival
	    from trips
	    where arrival = 'DME' and status='Arrived');
	Task:
	Определите клиентов, которые пользуются оператором МТС в Мурманской области (коды оператора 911, 981) и летали первым классом на самолетах, зарегистрированных не в России.
	В выборке должен присутствовать один атрибут: id.
	Decision:
	select id/*, 
	    phone,
	    substr(phone,3,3) as newphone*/
	from clients
	where substr(phone,3,3)='911' or substr(phone,3,3)='981'
	Task:
	Найдите задержанные рейсы на самолеты с дальностью полета меньше 10000 километров. В выборке должен присутствовать один атрибут - id.
	Decision:
	/*select id, model_name, range
	from airliners
	where range<10000;*/
	select id--, status, airliner_id
	from trips
	where airliner_id=(select id
	    from airliners
	    where range<10000) and status = 'Delayed';
	Task:
	Выведите возрастную категорию пассажиров, купивших билет в бизнес- или первый класс. Возрастные категории следующие: < 18 - Ребенок; 18-50 - Взрослый; > 50 - Пожилой.
	В выборке должны присутствовать два атрибута: id, age_category. 
	Decision:
	/*select id--, 
	    --service_class, 
	    --client_id
	from tickets
	where (service_class='FirstClass' or service_class='Business') ;*/
	select id,
	    --age, 
	    case 
	        when age>0 and age<18 then  'Ребенок' 
	        when age>=18 and age<50  then  'Взрослый' 
	        else 'Пожилой'
	    end as age_category
	from clients
	where id in (select client_id
	    from tickets
	    where (service_class='FirstClass' or service_class='Business'));
	Task:
	Вывести имя сотрудников из таблицы employees
	Decision:
	SELECT 
	    first_name as nm
	FROM employees emp
	Task:
	Вывести имена сотрудников из таблицы employees, зарплата которых больше или равна 9000
	Decision:
	SELECT 
	    first_name
	FROM employees
	WHERE salary >= 9000
	Task:
	Вывести имена сотрудников из таблицы employees, зарплата которых находится в диапазоне от 9000 до 20000
	Decision:
	SELECT 
	    first_name as nm
	FROM employees
	WHERE salary between 9000 and 20000
	Decision:
	select first_name, last_name, salary 
	from employees
	where salary not between 5000 and 10000;
	Decision:
	select first_name, last_name, salary
	from employees 
	where salary!=9000 
	    and salary!=6000 
	    and salary!=4000;
	Decision:
	select first_name, last_name, salary, salary*0.5 bonus
	from employees
	where salary not in (9000, 6000, 4000);
	Decision:
	select first_name, last_name, salary, salary*0.5 bonus
	from employees
	where first_name in ('Steven', 'lex');
	Decision:
	SELECT LAST_NAME
	FROM employees
	WHERE last_name not like 'K%';
	Decision:
	select * 
	from employees;
	Task:
	Вывести всех сотрудников с ЗП, не равной 10 тыс
	Decision:
	select * 
	from employees 
	where salary != 10000;
	Task:
	Найти в таблице jobs должности с минимальной ЗП больше 8 тыс
	Decision:
	select job_title
	from jobs 
	where min_salary>8000;
	Task:
	Найти в таблице jobs должности с минимальной ЗП от 8 тыс до 10 тыс включительно
	Decision:
	select job_title
	from jobs
	where min_salary between 8000 and 10000;
	Decision:
	select job_title
	from jobs
	where min_salary >= 8000 and min_salary <= 10000;
	Task:
	Вывести всех сотрудников с ЗП меньше 10 тыс и больше 20 тыс (2 способа)
	Decision:
	select * 
	from employees
	where salary < 10000 or salary > 20000;
	Decision:
	select * 
	from employees
	where salary not between 10000 and 20000;
	Task:
	Вывести имя, фамилию и идентификатор департамента для сотрудников НЕ из департаментов 30, 60 и 80
	Decision:
	select first_name,last_name,department_id
	from employees
	where department_id not in (30,60,80)
	Task:
	Вывести все локации, кроме Токио, Пекин (Beijing) и Лондон
	Decision:
	select *
	from locations
	where city not in ('Tokyo','Beijing','London')
	Task:
	Вывести всех сотрудников, у которых имя начинается на A
	Decision:
	select*
	from employees
	where first_name like 'A%'
	Task:
	Вывести всех сотрудников, у которых предпоследняя буква в имени e
	Decision:
	select * from employees where first_name like '%e_'
	Task:
	Вывести множество сотрудников, у которых в имени есть две буквы l подряд 
	Decision:
	select * 
	from employees
	where first_name like '%ll%'
	Task:
	Вывести сотрудников из таблицы employees, у которых не заполнено значение премии
	Decision:
	SELECT 
	    *
	FROM employees
	Where commission_pct is NULL
	Task:
	Вывести всех сотрудников, у которых не указан размер премии
	Decision:
	select *
	FROM employees
	where commission_pct is not null;
	Task:
	Вывести всех департаменты, у которых указан идентификатор менеджера
	Decision:
	select *
	from departments
	where manager_id is not NULL
	Decision:
	select employee_id, last_name, first_name, salary, 12 bonus
	FROM employees
	where salary>9000 -- and commission_pct is not null
	order by bonus
	Task:
	Вывести сотрудников из таблицы employees в порядке возрастания их идентификаторов
	Decision:
	SELECT 
	    *
	FROM employees
	Order by employee_id 
	Task:
	Отсортировать все локации в порядке возрастания идентификатора локации
	Task:
	Отсортировать все локации в порядке убывания наименования города
	Task:
	Вывести адреса, находящиеся в Японии в сортировке по возрастанию по location_id
	Decision:
	select street_address 
	from locations
	where country_id = 'JP'
	order by location_id;
	Task:
	Получить список всех сотрудников из 50 и 80 отделов, у которых есть бонус
	Decision:
	select *
	from employees 
	where department_id in (50,80)
	and commission_pct > 0
	Task:
	Получить список всех сотрудников из 100 отдела с зарплатой в интервале от 8 до 10 тысяч
	Task:
	Получить список всех уникальных кодов руководителей
	Decision:
	select distinct manager_id
	from employees
	where manager_id is not null
	union
	select manager_id
	from departments
	where manager_id is not null
	Task:
	Вывести всех сотрудников у которых нет руководителей
	Task:
	вывести список городов и стран, в которых они находятся (таблица locations).
	Decision:
	SELECT city,
	CASE  country_id
	WHEN  'IT' THEN 'Италия'  
	WHEN  'JP' THEN 'Япония' 
	 ELSE 'Прочие’
	END as country  
	FROM locations;
	Decision:
	SELECT city,
	CASE
	WHEN country_id = 'IT' THEN 'Италия'  
	WHEN country_id = 'JP' THEN 'Япония' 
	 ELSE 'Прочие’
	END as country  
	FROM  locations;
	Task:
	Классификация сотрудников (таблица employees)
	Зарплата до 4000 – junior,
	Зарплата от 4000 до 8000 – middle,  
	Зарплата от 8000 до 20000 – senior,  
	Зарплата от 20000 – top management.
	Выведите фамилию, имя работника, зарплату и его классификацию.
	Decision:
	SELECT first_name, last_name, salary,
	    CASE
	        WHEN salary > 0 AND salary <= 4000 THEN 'junior1'
	        WHEN salary > 0 AND salary <= 4000 THEN 'junior2'
	        WHEN salary > 4000 AND salary <= 10000 THEN 'middle'
	        WHEN salary > 10000 AND salary <= 20000 THEN 'senior'
	        WHEN salary > 20000 THEN 'top management'
	        WHEN salary is NULL or salary = 0 THEN 'Not Defined'
	        WHEN salary < 0 THEN 'Nagative salary'
	        ELSE 'Something goes wrong'
	     END AS classification
	FROM employees;
	Task:
	Выведите все департаменты, их название и код начальника. Если это  начальника нет – вывести «Без начальника»
	Decision:
	select department_id, department_name, 
	    case when manager_id is null then 'Без начальника' 
	    else manager_id end manager_id
	from departments;
	Task:
	Выведите всех сотрудников и их категорию работы:
	- Сотрудник администрации
	- Менеджер
	- Служащий
	Правило для категорий придумываем сами
	Decision:
	select case 
	    when job_id like 'AD_%' THEN 'Администрация'
	    WHEN job_id LIKE '%_MAN' OR job_id LIKE '%_MGR'  THEN 'Менеджер'
	    WHEN job_id IS NULL THEN 'Нет job_id'
	    ELSE 'Служащий'
	from employees;
	Task:
	Вывести на экран сначала адреса Канады и Америки, затем Японии и Китая, а затем всех остальных стран, при этом в каждой из групп сначала должны идти адреса имеющие непустое значение в поле Провинция
	Decision:
	select  street_address
	from locations
	order by case when country_id in ('CA','US') then 1
	    when country_id in ('JP','CH') then 2
	    else 3 end, state_province nulls last;
	Task:
	Рассчитайте ежемесячную зарплату для каждого сотрудника с переводом в рубли по курсу 1$ - 62 рубля
	Decision:
	select first_name, last_name, salary, salary*62 salary_rub
	from employees
	Task:
	Рассчитайте размер годового бонуса для каждого сотрудника
	Decision:
	select first_name, salary, commission_pct, 
	    salary*12*coalesce(commission_pct, 0) bonus
	from employees
	Task:
	Выведите имя, фамилию и размер ежемесячного бонуса сотрудника, 
	округленный по сотых.
	Decision:
	select first_name, last_name, salary, commission_pct,
	          coalesce(round(salary*commission_pct,2),'Нет бонуса') bonus
	from employees
	Task:
	Считаем, что медиана зарплаты в компании – 10000.
	Для каждого сотрудника вывести его имя, фамилию, 
	зарплату и абсолютную величину отклонения от медианы
	Decision:
	select first_name, last_name, salary, abs(salary-10000) deviation
	from employees 
	Task:
	Строковые функции
	Decision:
	select UPPER('Vasya') up_name, LOWER('Vasya') lo_name,
	          '!'||'    Vasya     '||'!' no_trim,
	          '!'||TRIM('    Vasya     ')||'!' tr_name, 
	          '!'||LTRIM('    Vasya     ')||'!' ltr, 
	          '!'||RTRIM('    Vasya     ')||'!' rtr,
	          'Vasya'||' '||'Petrov' name
	Decision:    
	select substr('123456',2) sub_1,
	          substr('123456',2,3) sub_2,
	          substr('123456',-2) sub_3,
	          substr('123456',4,-2) sub_4
	Decision:     
	select replace('HeLLo worlld','ll','!!') rep, length('123456') len
	Decision:
	select *
	from locations
	where country_id in (select country_id from countries c where country_name='Japan');
	Task:
	Получить имена сотрудников в нижнем регистре без первой и последней буквы в имени
	Task:
	Вывести имя сотрудника, его фамилию, а также поле, которое указывает последние 4 цифры номера телефона сотрудника из таблицы EMPLOYEE
	Decision:
	select first_name, last_name, phone_numeric ,
	         substr(replace(phone_numeric,'.',''),-4) num
	from employees
	Decision:
	select *
	from (select first_name, last_name, salary, div
	         from (select first_name, last_name, salary, abs(10000-salary) div
	                  from employees)
	         where salary > div*2)
	order by;
	Task:
	Вывести все департаменты, где есть сотрудники, у которых длина имени равна 6 и начинается на S
	Task:
	Для каждого сотрудника из таблицы employee выведите идентификатор сотрудника, его номер телефона и тип номера телефона, если длина равна 12, то 'короткий', если  18, то 'длинный';
	Decision:
	select employee_id, 
	  phone_NUMERIC,
	  case 
	    when length(phone_NUMERIC)=12 
	      then 'короткий'
	    when length(phone_NUMERIC)=18 
	      then 'длинный'
	    when phone_NUMERIC is null 
	      then 'номер не указан'
	    else 'ошибка в записи'
	  end type_number
	from employees;
	Task:
	Выведите для каждого клиента из таблицы purchases полные ФИО (фамилия, имя и  отчество должны находиться в одном поле) и адрес клиента (все адресные  атрибуты также должны находиться в одном поле). Не забудьте выполнить проверку  на пробелы;
	Decision:
	starter=# select
	starter-#   surname || ' ' || name || ' ' || second_name as FIO,
	starter-# CASE
	starter-#     when trim(region) = trim(city)
	starter-#       then city ||', '|| street_type ||' '|| street_nm || ', '|| house_num
	starter-#     else region ||', '|| city ||', '|| street_type ||' '|| street_nm || ', '|| house_num
	starter-#   end as address
	starter-# from purchases;
	                 fio                 |                            address
	-------------------------------------+---------------------------------------------------------------
	 Смирнов Александр Александрович     | Москва, улица Шмидте, 2
	 Иванов Сергей Алексеевич            | Московская область, Химки, проспект 50 лет октября, 17
	 Кузнецов Владимир Анатольевич       | Ростовская область, Ростов-на-Дону, переулок Дружбы, 51
	 Соколова Елена Андреевна            | Свердловская область, Екатеринбург, бульвар Цветной, 64
	 Попова  Татьяна Александровна       | Санкт-Петербург, улица Ленина, 11
	 Лебедев Андрей Аркадьевич           | Ростовская область, Ростов-на-Дону, переулок Смирновский, 100
	 Козлов Алексей Артемович            | Москва, улица Ленина, 3
	 Новикова Ольга Андреевна            | Санкт-Петербург, бульвар Петровский, 45
	  Морозов Николай Богданович         | Рязанская область, Рязань, проспект Московский, 67
	 Петров Наталья Александровна        | Ростовская область, Ростов-на-Дону, улица Ленина, 65
	 Волкова Анна Валентиновна           | Москва, улица Ленина, 73
	 Соловьёв Иван Валерьевич            | Москва, переулок Глинки, 33
	 Васильев Дмитрий Васильевич         | Ростовская область, Ростов-на-Дону, улица Ленина, 25
	 Зайцева Ирина Викторовна            | Санкт-Петербург, бульвар Волжский, 74
	 Павлова  Мария Витальевна           | Москва, проспект Свободы, 81
	 Семёнов Михаил Владимирович         | Свердловская область, Екатеринбург, переулок Некрасовский, 44
	 Голубева Светлана Владиславовна     | Ростовская область, Ростов-на-Дону, улица Ленина, 44
	 Виноградова Екатерина Владиславовна | Москва, бульвар Победы, 85
	 Богданов Евгений Вячеславович       | Санкт-Петербург, проспект Революции, 3
	 Воробьёв Виктор Геннадиевич         | Ростовская область, Ростов-на-Дону, улица Дзержинского, 20
	 Фёдорова Анастасия Георгиевна       | Рязанская область, Рязань, улица Победы, 55
	 Михайлов Юрий Григорьевич           | Москва, переулок Лермонтовский, 45
	 Беляева Юлия Валентиновна           | Рязанская область, Рязань, бульвар Гагарина, 50
	 Тарасова Валентина Денисовна        | Москва, улица Ленина, 54
	 Белова Галина Валентиновна          | Санкт-Петербург, проспект Невский, 30
	 Комарова Людмила Евгеньевна         | Рязанская область, Рязань, улица Ленина, 15
	 Орлов Василий Егорович              | Ростовская область, Ростов-на-Дону, бульвар Дзержинского, 19
	 Киселёв Игорь Ефимович              | Москва, проспект Красный, 10
	 Макаров Анатолий Иванович           | Санкт-Петербург, улица Ленина, 27
	 Андреев  Олег Иваныч                | Москва, переулок Тургеневский, 79
	(30 строк)
	Task:
	Выведите для каждого клиента из таблицы purchases его фамилию и инициалы, номер   телефона, а также его категорию: если вторая цифра телефона = 9, то телефон мобильный, иначе городской;
	Decision:
	starter-# select  
	  surname || ' ' || substr(name, 1, 1) || '. ' || substr(second_name, 1, 1) as client,
	  phone_number, 
	  case 
	    when phone_number like '_9%' 
	      then 'мобильный'
	    when phone_number not like '_9%' 
	      then 'городской'
	    when phone_number is NULL
	      then 'значение не задано'
	  end as type 
	from purchases;
	client  phone_number    type
	Смирнов А. А    74950054758 городской
	Иванов С. А 79061793723 мобильный
	Кузнецов В. А   79036038662 мобильный
	Соколова Е. А   74951752838 городской
	Попова Т. А 79209217902 мобильный
	Лебедев А. А    74999545208 городской
	Козлов А. А 74999545205 городской
	Новикова О. А   74999545202 городской
	Морозов Н. Б    NULL    значение не задано
	Петров Н. А 74999937334 городской
	Волкова А. В    74950692731 городской
	Соловьёв И. В   77767813970 городской
	Васильев Д. В   74951662623 городской
	Зайцева И. В    79093871696 мобильный
	Павлова М. В    74953740142 городской
	Семёнов М. В    NULL    значение не задано
	Голубева С. В   74995861301 городской
	Виноградова Е. В    74995860591 городской
	Богданов Е. В   74995861296 городской
	Воробьёв В. Г   74953741652 городской
	Фёдорова А. Г   74950097648 городской
	Михайлов Ю. Г   74992166013 городской
	Беляева Ю. В    78002220480 городской
	Тарасова В. Д   73432203735 городской
	Белова Г. В 73432203718 городской
	Комарова Л. Е   74993506931 городской
	Орлов В. Е  79031193345 мобильный
	Киселёв И. Е    74996382013 городской
	Макаров А. И    79253628473 мобильный
	Андреев О. И    74951203035 городской
	Task:
	Выведите для каждого клиента из таблицы purchases его фамилию и инициалы, а  также его email и домен электронной почты:
	        ya.ru или yandex.ru -> яндекс
	        mail.com -> мейл
	        gmail.com -> гугл
	        yahoo.com -> яху
	Decision:
	starter=#  SELECT TRIM(surname) ||' '|| SUBSTR(LTRIM(name), 1, 1) ||'. '|| SUBSTR(LTRIM(second_name), 1, 1) ||'. ' AS full_name, email,
	starter-# CASE
	starter-#     WHEN TRIM(LOWER(email)) LIKE '%@ya.ru' OR TRIM(LOWER(email)) LIKE '%@yandex.ru' THEN 'яндекс'
	starter-#         WHEN TRIM(LOWER(email)) LIKE '%@mail.com'  THEN 'мейл'
	starter-#         WHEN TRIM(LOWER(email)) LIKE '%@gmail.com'  THEN 'гугл'
	starter-#         WHEN TRIM(LOWER(email)) LIKE '%@yahoo.com'  THEN 'яху'
	starter-#         WHEN email IS NULL OR email = 'NULL' THEN  'пусто'
	starter-#         ELSE 'не известный'
	starter-#    END AS domen
	starter-# FROM purchases;
	     full_name      |        email        | domen
	--------------------+---------------------+--------
	 Смирнов А. А.      | smirnov@ya.ru       | яндекс
	 Иванов С. А.       | ivanov@gmail.com    | гугл
	 Кузнецов В. А.     | kuznecov@yandex.ru  | яндекс
	 Соколова Е. А.     | sokolova@mail.com   | мейл
	 Попова Т. А.       | popova@yahoo.com    | яху
	 Лебедев А. А.      | lebedev@yahoo.com   | яху
	 Козлов А. А.       | kozlov@ya.ru        | яндекс
	 Новикова О. А.     | novikova@yandex.ru  | яндекс
	 Морозов Н. Б.      | morozov@gmail.com   | гугл
	 Петров Н. А.       | PETROV@GMAIL.COM    | гугл
	 Волкова А. В.      | volkova@gmail.com   | гугл
	 Соловьёв И. В.     | soloviyev@gmail.com | гугл
	 Васильев Д. В.     | vasiliyev@mail.com  | мейл
	 Зайцева И. В.      | zayceva@ya.ru       | яндекс
	 Павлова М. В.      | PAVLOVA@GMAIL.COM   | гугл
	 Семёнов М. В.      | semenov@mail.com    | мейл
	 Голубева С. В.     | golubeva@gmail.com  | гугл
	 Виноградова Е. В.  | vinogradova@ya.ru   | яндекс
	 Богданов Е. В.     | BOGDANOV@gmail.com  | гугл
	 Воробьёв В. Г.     | vorobiyev@gmail.com | гугл
	 Фёдорова А. Г.     | NULL                | пусто
	 Михайлов Ю. Г.     | mikhaylov@mail.com  | мейл
	 Беляева Ю. В.      | NULL                | пусто
	 Тарасова В. Д.     | belova@gmail.com    | гугл
	 Белова Г. В.       | NULL                | пусто
	 Комарова Л. Е.     |  KOMAROVA@MAIL.COM  | мейл
	 Орлов В. Е.        | orlov@gmail.com     | гугл
	 Киселёв И. Е.      | NULL                | пусто
	 Макаров А. И.      | makarov@mail.com    | мейл
	 Андреев О. И.      | andreev@gmail.com   | гугл
	(30 строк)
	Task:
	Из таблицы purchases отобрать только тех клиентов, которые:
	        совершили покупку в ноябре 2021 года;
	        на суммы свыше 5 тысяч рублей (с учетом текущей скидки)
	        известен полный адрес и номер телефона
	    Вывести     фамилию, имя и отчество, 
	        номер телефона,
	        текста sms-сообщения: 
	    “Уважаемый/ая (имя клиента), рады сообщить, что в нашем магазине начинается     распродажа товаров. Ждем Вас каждый день с 9.00 до 20.00!”
	Decision:
	select 
	    surname || ' ' || substr(name, 1, 1) || '. ' || substr(second_name, 1, 1) as client,
	    phone_number,
	    'Уважаемый/ая ' ||surname || ' ' || substr(name, 1, 1) || '. ' || substr(second_name, 1, 1)||', 
	    рады сообщить, что в нашем магазине начинается  
	    распродажа товаров. Ждем Вас каждый день с 9.00 до 20.00!' as sms
	    --purchase_amt_rub*(1-current_discount)
	from purchases
	where 
	    purchase_dt like '%11.2021'
	    and region is not NULL 
	    and city is not NULL 
	    and street_type is not NULL 
	    and street_nm is not NULL 
	    and house_num is not NULL 
	    and phone_number is not NULL
	    and
	    (case currency_nm 
	        when 'US' 
	            then  60.5
	        when 'EUR' 
	            then 60.6
	        when 'CNY' 
	            then 8.7 
	        else 1
	    end *purchase_amt)*(1-
	    replace(coalesce(case current_discount
	          when 'NULL'
	              then 0 
	          else current_discount
	      end,0),'%','')*0.01) > 5000
	client  phone_number    sms
	Смирнов А. А    74950054758 Уважаемый/ая Смирнов А. А, рады сообщить, что в нашем магазине начинается распродажа товаров. Ждем Вас каждый день с 9.00 до 20.00!
	Иванов С. А 79061793723 Уважаемый/ая Иванов С. А, рады сообщить, что в нашем магазине начинается распродажа товаров. Ждем Вас каждый день с 9.00 до 20.00!
	Кузнецов В. А   79036038662 Уважаемый/ая Кузнецов В. А, рады сообщить, что в нашем магазине начинается распродажа товаров. Ждем Вас каждый день с 9.00 до 20.00!
	Волкова А. В    74950692731 Уважаемый/ая Волкова А. В, рады сообщить, что в нашем магазине начинается распродажа товаров. Ждем Вас каждый день с 9.00 до 20.00!
	Васильев Д. В   74951662623 Уважаемый/ая Васильев Д. В, рады сообщить, что в нашем магазине начинается распродажа товаров. Ждем Вас каждый день с 9.00 до 20.00!
	Виноградова Е. В    74995860591 Уважаемый/ая Виноградова Е. В, рады сообщить, что в нашем магазине начинается распродажа товаров. Ждем Вас каждый день с 9.00 до 20.00!
	Богданов Е. В   74995861296 Уважаемый/ая Богданов Е. В, рады сообщить, что в нашем магазине начинается распродажа товаров. Ждем Вас каждый день с 9.00 до 20.00!
	Орлов В. Е  79031193345 Уважаемый/ая Орлов В. Е, рады сообщить, что в нашем магазине начинается распродажа товаров. Ждем Вас каждый день с 9.00 до 20.00!
	Макаров А. И    79253628473 Уважаемый/ая Макаров А. И, рады сообщить, что в нашем магазине начинается распродажа товаров. Ждем Вас каждый день с 9.00 до 20.00!
	Decision:
	select 
	    first_name, 
	    last_name, 
	    department_id, 
	    (select 
	        distinct department_name 
	     from departments 
	     where departments.department_id=employees.department_id) as department_name
	from employees 
	Task:
	отобрать только клиентов из городов Москва, Санкт-Петербург и     Ростов-на-Дону и изменить текст sms-сообщения на:
	    “Уважаемый (имя клиента), рады сообщить, что в нашем магазине начинается    распродажа товаров. Ждем Вас по адресу: 
	    (для Москвы: Москва, Ленинградский проспект 7)
	    (для Санкт-Петербурга: Санкт-Петербург, Невский проспект 23) 
	    (для Ростова-на-Дону: Ростов-на-Дону, ул. Садовая 101), каждый день с 9.00 до 20.00!”
	Task:
	Для каждого клиента из таблицы purchases выведите размер новой скидки, рассчитанной на основе объемов его покупок:
	        Если клиент купил более 10 единиц товаров, то скидка 10%
	        Если клиент потратил на покупки с учетом текущей скидки более 7 тыс. рублей (или эквивалентной сумме в иной валюте), то скидка 20%
	     Выведите идентификатор клиента и размер его скидки в формате 'm %'
	Task:
	Выведите из таблицы purchase только те записи, для которых в поле current_discount содержится символ % и запишите эти записи в новую таблицу purchases_bag
	Task:
	Используя функцию type(), попробуйте выполнить следующие операции и посмотрите что выведется на экран:
	    type(None)
	    type(True)
	    type(False)
	    type(1)
	    type(5.3)
	    type(5 + 4j)
	    type([1, 5.3, False, 4])
	    type((1, True, 3, 5+4j))
	    type(range(5))
	    type('Hello')
	    type(b'a')
	    type(bytearray([1,2,3]))
	    type(memoryview(bytearray('XYZ', 'utf-8')))
	    type({'a', 3, True})
	    type(frozenset({1, 2, 3}))
	    type({'a' : 32})
	Decision:
	>>> type(None)
	<class 'NoneType'>
	>>> type(True)
	<class 'bool'>
	>>> type(1)
	<class 'int'>
	>>> type([1, 5.3, False, 4])
	<class 'list'>
	>>> type((1, True, 3, 5+4j))
	<class 'tuple'>
	>>> type(range(5))
	<class 'range'>
	>>> type(bytearray([1,2,3]))
	<class 'bytearray'>
	>>> type(memoryview(bytearray('XYZ', 'utf-8')))
	<class 'memoryview'>
	>>> type({'a', 3, True})
	<class 'set'>
	>>> type(frozenset({1, 2, 3}))
	<class 'frozenset'>
	>>> type({'a' : 32})
	<class 'dict'>
	Task:
	Выведите только тех, у кого класс изменился
	Decision:
	select *
	from (
	    select
	        first_name , 
	        last_name ,
	        salary ,
	        commission_pct , 
	        coalesce(salary + 1000000 * commission_pct, salary) as new_salary,
	        case 
	            when salary < 4000 then 'бедные'
	            when salary < 8000 then 'средний класс'
	            when salary < 20000 then 'богатые'
	            when salary > 20000 then 'очень богатые'
	        end as classification_1 ,
	        case 
	            when coalesce(salary + 1000000 * commission_pct, salary) < 4000 then 'бедные'
	            when coalesce(salary + 1000000 * commission_pct, salary) < 8000 then 'средний класс'
	            when coalesce(salary + 1000000 * commission_pct, salary) < 20000 then 'богатые'
	            when coalesce(salary + 1000000 * commission_pct, salary) > 20000 then 'очень богатые'
	        end as classification_2
	    from hr.employees e
	    ) t
	where classification_1 <> classification_2 
	Task:
	Руководитель хочет выплатить премию всем сотрудникам подразделений, перечисленных в таблице hr.dep_bonus. 
	Выведите список таких сотрудников из таблицы hr.employees, воспользовавшись только подзапросами.
	Decision:
	select * 
	from hr.employees 
	where department_id in (
	    select department_id 
	    from hr.departments
	    where department_name in (
	        select department_name
	        from hr.dep_bonus
	        )
	    )
	Task:
	Сколько сотрудников с именем David?
	Decision:
	select count(*)
	from hr.employees e 
	where first_name = 'David'
	Task:
	Сколько всего регионов в Великобритании?
	Decision
	select count(*)
	from hr.locations l 
	where country_id = 'UK'
	Task:
	Какова средняя зарплата в компании? 
	Decision:
	select avg(salary), sum(salary)/count(salary)
	from hr.employees e 
	Task:
	Выведите всех сотрудников, имеющих заработную плату ниже средней.
	Decision
	select * 
	from hr.employees e 
	where salary < (
	    select avg(salary)
	    from hr.employees ) 
	Task:
	Введите в предыдущий запрос колонку «Самая маленькая зарплата» и если у сотрудника самая маленькая зарплата – пишите «Да», иначе – «Нет».
	Decision:
	select e.*,
	    case 
	        when salary = (select min(salary) from hr.employees) then 'yes'
	        else 'no'
	    end as smallest_salary
	from hr.employees e
	where salary < (
	    select avg(salary)
	    from hr.employees )
	Task:   
	Среди работников, не имеющих процента от прибыли, какова максимальная зарплата?
	Decision:
	select max(salary)
	from hr.employees
	where commission_pct is null 
	Task:
	Пересчитайте зарплату работникам. Если работник из IT отдела – добавьте 15%. Выведите всех сотрудников компании.
	Decision:
	select e.*,
	    case 
	        when department_id = (
	            select department_id
	            from hr.departments d 
	            where department_name = 'IT') then salary*1.15
	        else salary
	    end as new_salary
	from hr.employees e 
	Task:
	Выведите название отделов с количеством сотрудников больше среднего.
	Decision
	select department_name 
	from hr.departments d 
	where department_id in (
	    select department_id 
	    from hr.employees e 
	    group by department_id 
	    having  count(*) > (
	        select avg(cnt)
	        from (
	            select department_id , count(*) cnt
	            from hr.employees e 
	            group by department_id  
	            ) t 
	        )
	    )

Создание, изменение, удаление таблиц
	Task:
	создание/изменение/удаление записи в произвольной таблице
	Decision:
	mysql> CREATE DATABASE company;
	mysql> INSERT INTO users
	mysql> DROP DATABASE company;
	Task:
	Каким будет результат выполнения функций:
	1 substr(‘123ABCD567EF’,4,7)
	2 ceil(-1.76)
	3 trim(0 from ‘000456GJ000’)
	1. 1 BCD567E
	2 -2
	3 000456GJ
	2. 1 ABCD567
	2 -2
	3 GJ
	3. 1 ABCD567
	2 -1
	3 000456GJ
	4. 1 BCD567E
	2 -1
	3 GJ
	5. 1 ABCD567
	2 -1
	3 456GJ
	Task:
	Создание и удаление таблиц
	Decision:
	starter-# CREATE TABLE student_auto (
	    id INT,
	    name VARCHAR(50),
	    surname VARCHAR(50),
	    gender VARCHAR(50),
	    mobile VARCHAR(50),
	    birthday DATE
	);
	starter-# DROP TABLE student_auto;
	starter-# CREATE TABLE student_auto (
	    id INT,
	    name VARCHAR(50),
	    surname VARCHAR(50),
	    gender VARCHAR(50),
	    mobile VARCHAR(50),
	    birthday DATE
	);
	starter-# \d student_auto;
	Task:
	Наполнение данными
	Decision:
	starter=# SELECT * FROM student;
	starter=# INSERT INTO student(name, surname) VALUES ('Michael', 'Scott');
	starter=# SELECT * FROM student;
	Task:
	Базовая арифметика
	Decision:
	starter=# SELECT min(price) FROM booking_n WHERE name LIKE '%sia';
	starter=# SELECT max(price) FROM booking_n WHERE surname BETWEEN 'S' AND 'X';
	starter=# SELECT avg(price) from booking_n;
	starter=# SELECT sum(price) FROM booking_n;
	Task:
	Дата и время
	Decision:
	starter=# SELECT * FROM NOW();
	starter=# SELECT EXTRACT (SECOND FROM NOW());
	Task:
	Первичный ключ
	Decision:
	starter=# ALTER TABLE travelers ADD login VARCHAR(25);
	starter=# ALTER TABLE travelers DROP login;
	Task:
	Ограничения
	Decision:
	starter=# ALTER TABLE travelers ADD CONSTRAINT id_unique UNIQUE(id);
	starter=# ALTER TABLE travelers ADD CONSTRAINT gender_check CHECK(gender = 'Female' OR gender = 'Male');
	Task:
	UPSERT и обновление таблиц
	Decision:
	starter=# UPDATE booking_n SET name  = 'Max' WHERE id = 1;
	starter=# UPDATE booking_n SET departure_from  = 'Russia', arriving_to = 'Kazakhstan' WHERE id = 1;
	starter=# INSERT INTO booking_n (id,name,surname,departure_from,arriving_to,price) VALUES (1,'John','Doe','USA','UK','$200') ON CONFLICT (id) DO NOTHING;
	starter=# INSERT INTO booking_n (id,name,surname,departure_from,arriving_to,price) VALUES (1,'John','Doe','USA','UK','$200') ON CONFLICT (id) DO UPDATE SET departure_from = 'EXCLUDED.departure_from;
	Task:
	Внешние ключи
	Decision:
	starter=# ALTER TABLE booking_n ADD new_booking_id BIGSERIAL REFERENCES booking(id);
	Task:
	Соединение таблиц
	Decision:
	starter=# SELECT * FROM travelers RIGHT JOIN booking_n ON travelers.id = booking_n.id;
	starter=# SELECT * FROM travelers LEFT JOIN booking_n ON travelers.id = booking_n.id;
	starter=# SELECT * FROM travelers FULL JOIN booking_n ON travelers.id = booking_n.id;
	Task:
	Экспорт в CSV
	Decision:
	starter=# SELECT * FROM travelers WHERE id < 50;
	starter=# \copy (SELECT * FROM travelers WHERE id < 50) TO 'C:\Users\david\Documents\EngineerOfThe2ndCategory\Sberbank\Basics of the PostgreSQL language'  DELIMITER ','  CSV HEADER;
	starter=# \copy (SELECT * FROM travelers WHERE id < 50) TO 'C:/Users/david/Documents/EngineerOfThe2ndCategory/Sberbank/Basics of the PostgreSQL language/sample.csv'  DELIMITER ','  CSV HEADER;
	Task:
	Аналитическое подразделение решило уточнить у авиакомпании количество билетов не бизнес-класса. Напишите запрос, который выведет id билетов, класс обслуживания в которых отличен от бизнес-класса (Business).
	В выборке должен присутствовать один атрибут — id.
	Decision:
	select id from tickets where service_class is not 'Business'
	Task:
	Определите билеты бизнес-класса, цена которых не находится в диапазоне от 9100 до 70 400 включительно. В выборке должны присутствовать два атрибута — id и price.
	Decision:
	select id, price from tickets where (price not between 9100 and 70400) and service_class='Business';
	Task:
	Определите имена и фамилии пассажиров, чьи идентификаторы заканчиваются на RCB или FCV, а номера телефонов не начинаются на +705. В выборке должен присутствовать один атрибут — name.
	Decision:
	select name from clients where (id like '%_RCB' or id like '%_FCV') and (phone not like '%+705%') ;
	Task:
	После каждого рейса проходит плановая уборка салона. Результаты уборки вносятся в отчет-лист. Авиакомпания получила отчет, в котором указано, что во всех самолетах все места чистые, а спинки кресел исправные. Выведите бортовой номер самолета, cформировав для каждой строки поле index с значением 'clean'.
	В выборке должны присутствовать два атрибута — side_number и index.
	Decision:
	--alter table airliners add 'index' varchar(30) default 'clean'; select side_number from airliners;
	select side_number, 'clean' as 'index' from airliners;
	Task:
	Составьте в запросе выборку, основанную на конкатенации имени и возраста пассажиров, задав новое имя name_with_age. Отсортируйте сформированное поле по алфавиту.
	В выборке должен присутствовать один атрибут — name_with_age.
	Decision:
	select /*name, age,*/ (name || ' '|| age) as name_with_age 
	from clients
	order by name_with_age;
	Task:
	Владельцам аэропорта необходимо возместить ущерб пассажирам, чей багаж намок по вине его сотрудников. Возврату подлежат 2500 рублей за один купленный билет. Определите номер билета и разницу от его стоимости и той суммы, которую получит пассажир. Известно, что нет билетов дешевле 2500 рублей. Идентификатор рейса — 87RVI5T7A2.
	В выборке должны присутствовать два атрибута — id, returns.
	Decision:
	select id, price-2500 as returns
	from tickets
	where trip_id='87RVI5T7A2'
	Task:
	Выведите длину строки поля model_name, назвав поле len_model_name, только для самолетов, название модели которых начинается на S. В выборке должен присутствовать один атрибут — len_model_name.
	Decision:
	select length(model_name) as len_model_name
	from airliners
	where model_name like 'S_%';
	Task:
	Определите идентификаторы пассажиров, длины имен которых находятся в диапазоне от 10 до 13 символов включительно. В выборке должен присутствовать один атрибут — id.
	Decision:
	select id--, name
	from clients
	where length(name) between 10 and 13
	Task:
	Экспорт данных из разных источников показал, что некоторые имена записаны в нижнем регистре. При помощи строковых функций сформируйте новое поле newname, где первая буква имени должна быть представлена в верхнем регистре. В выборке должны присутствовать два атрибута — id, newname.
	Decision:
	select id, 
	    --substr(upper(name),2, -1) as newname
	    --substr(name,2) as newname
	    substr(upper(name),2, -1) || '' || substr(name,2) as newname
	from clients
	Task:
	Экспорт данных из разных источников показал, что некоторые номера телефонов записаны с лишними пробелами. Уберите их и приведите данные к единому виду. В выборке должны присутствовать два атрибута — id, newphone.
	Decision:
	select id, --phone,
	    replace(phone,' ','') as newphone
	from clients
	Task:
	Создадим таблицу students, задав атрибуты group_id  (числовое значение), name (строковый тип) и dept_id (числовое значение) 
	Decision:
	starter=# create table students (
	starter(#   group_id integer,
	starter(#   name varchar(50),
	starter(#   dept_id int);
	Task:
	Создать таблицу da_course 
	с 5 полями:
	course_nm -> тип строка
	student_id -> тип число
	course_begin_dt -> тип дата
	course_end_dt -> тип дата
	schedule_time -> тип время
	Decision:
	starter=# create table da_course (
	starter(#   cours_nm varchar,
	starter(#   student_id int,
	starter(#   course_begin_dt date,
	starter(#   cours_end_dt date,
	starter(#   shedule_time time);
	Task:
	Создать таблицу da_course_new, по аналогии с da_course, но сразу заполнить строку данными. 
	Decision:
	starter=# create table
	starter-#   da_course_new_1 as select
	starter-#     'DE13 SQL' course_nm,
	starter-#     100 student_id,
	starter-#     '2022-11-18' course_begin_dt,
	starter-#     null course_end_dt,
	starter-#     '19:00' schedule_time;
	SELECT 1
	starter=# select * from da_course_new_1;
	 course_nm | student_id | course_begin_dt | course_end_dt | schedule_time
	-----------+------------+-----------------+---------------+---------------
	 DE13 SQL  |        100 | 2022-11-18      |               | 19:00
	(1 строка)
	Task:
	Создать таблицу students_new по аналогии с таблицей students и загрузить в нее сотрудников из таблицы employees, работающих в 30 и 60 департаментах. Зачислить их в группу номер 1.
	Decision:
	create table 
	    students_new as select 
	        1 group_id, 
	        first_name name,  
	        department_id dept_id
	from employees
	where dept_id in (30, 60);
	Task:
	Добавьте в таблицу da_course поле my_name тип строка длиной 50 и значением по умолчанию;
	Decision:
	alter table da_course add my_name varchar(50) default 'unnamed';
	Task:
	Переименуйте поле my_name в student_nm;
	Decision:
	starter=# alter table da_course
	starter-# rename column my_name to student_nm;
	Task:
	Переименуйте табличку da_course в da08_course
	Decision:
	starter=# alter table da_course
	starter-# rename to da08_course;
	Task:
	Добавить в таблицу students студента по имени Alex из 100 департамента и зачислить его во 2 группу
	Decision:
	INSERT INTO students 
	(group_id, name, dept_id) 
	VALUES (2, 'Alex', 100)
	Task:
	Вставьте в таблицу da08_course  1 строку 
	course_nm -> 'SQL Base'
	student_cnt -> 30
	course_begin_dt -> '2022-10-10'
	course_end_dt -> '5999-12-31'
	schedule_time -> '10:00:00'
	Придумайте и вставьте еще одну строку
	Decision:
	starter=# insert into da08_course (cours_nm, student_id, course_begin_dt, cours_end_dt, shedule_time)
	starter-#  values ('SQL Base', 30, '2022-10-10', '2999-12-31', '10:00');
	starter=# insert into da08_course (cours_nm, student_id, course_begin_dt, cours_end_dt, shedule_time)
	starter-# values ('SQL Edv', 40, '2022-11-18', '2999-12-31', '19:00');
	starter=# insert into da08_course (cours_nm, student_id, course_begin_dt, cours_end_dt, shedule_time)
	starter-# values ('Python Base', 30, '2022-12-10', '2999-12-31', '10:00'),
	starter-# ('Python Edv', 40, '2023-01-18', '2999-12-31', '19:00');
	Task:
	Изменить группу, в которой обучается Алекс, на 3 (таблица students) 
	Decision:
	UPDATE students 
	SET group_id = 3 
	WHERE name = 'Alex';
	Task:
	В таблице da08_course обновите название курса 'SQL Base' на 'Base SQL'
	Decision:
	starter=# update da08_course
	starter-# set cours_nm = 'Base SQL'
	starter-# where cours_nm='SQL Base';
	Task:
	В таблице da08_course обновите для всех строк поле окончания курса на '2999-12-31'
	Decision:
	starter=# update da08_course set cours_end_dt = '2888-12-31';
	Task:
	Вставим в таблицу students новую запись (3, 'Barankin', 10);
	Удалим из таблицы students все строки, где номер департамента больше 30;
	Decision:
	starter=# insert into students
	starter-# values (3, 'Barankin', 10);
	starter=# delete from students
	starter-# where dept_id>30;
	Task:
	Удалите из таблицы da08_course все записи
	Decision:
	starter=# delete from da08_course;
	Task:
	необходимо создать таблицу persons с полями:
	-id,
	-name,
	-age, 
	-order_total
	-добавьте 5 записей;
	удалите записи, в которых возраст менее 18 лет ;
	для конкретного id увеличьте order_total на 500;
	уменьшите возраст на 2 года всем тем, у кого последняя буква в имени а;
	удалите таблицу persons;
	Decision:
	starter=# create table persons (
	starter(#   id serial,
	starter(#   name varchar(50),
	starter(#   age smallint,
	starter(#   order_total int
	starter(# );
	starter=# insert into persons
	starter-#     (name,
	starter(#     age,
	starter(#     order_total)
	starter-# values
	starter-#     ('Dmitry', 34, 200),
	starter-#     ('Monika', 24, 205),
	starter-#     ('Moko', 45, 234),
	starter-#     ('Yoko', 52, 213),
	starter-#     ('Amy', 27, 231);
	starter=# delete from persons where age<30;
	starter=# update persons
	starter-# set order_total = order_total + 500
	starter-# where id = 2;
	starter=# UPDATE persons SET age = age - 2 WHERE name like '%o' ;
	Task:
	Создать таблицу alphabet c полем letter char(1);
	    Вставить в нее все буквы русского алфавита;
	    Добавить новое поле letter_type varchar(20);
	    Заполните это поле типом буквы (гласная или согласная);
	Decision:
	starter=# create table alphabet (letter char(1));
	starter=# insert into alphabet (letter) values ('А');
	starter=# insert into alphabet (letter) values ('Б');
	starter=# insert into alphabet (letter) values ('В');
	starter=# insert into alphabet (letter) values ('Г');
	starter=# insert into alphabet (letter) values ('Д');
	starter=# insert into alphabet (letter) values ('Ё');
	starter=# insert into alphabet (letter) values ('Е');
	starter=# insert into alphabet (letter) values ('Ж');
	starter=# insert into alphabet (letter) values ('З');
	starter=# insert into alphabet (letter) values ('И');
	starter=# insert into alphabet (letter) values ('Й');
	starter=# insert into alphabet (letter) values ('К');
	starter=# insert into alphabet (letter) values ('Л');
	starter=# insert into alphabet (letter) values ('М');
	starter=# insert into alphabet (letter) values ('Н');
	starter=# insert into alphabet (letter) values ('О');
	starter=# insert into alphabet (letter) values ('П');
	starter=# insert into alphabet (letter) values ('Р');
	starter=# insert into alphabet (letter) values ('С');
	starter=# insert into alphabet (letter) values ('Т');
	starter=# insert into alphabet (letter) values ('У');
	starter=# insert into alphabet (letter) values ('Ф');
	starter=# insert into alphabet (letter) values ('Х');
	starter=# insert into alphabet (letter) values ('Ц');
	starter=# insert into alphabet (letter) values ('Ч');
	starter=# insert into alphabet (letter) values ('Ш');
	starter=# insert into alphabet (letter) values ('Щ');
	starter=# insert into alphabet (letter) values ('Ъ');
	starter=# insert into alphabet (letter) values ('Ы');
	starter=# insert into alphabet (letter) values ('Ь');
	starter=# insert into alphabet (letter) values ('Э');
	starter=# insert into alphabet (letter) values ('Ю');
	starter=# insert into alphabet (letter) values ('Я');
	starter=# ALTER TABLE alphabet
	starter-#   add letter_type varchar(20);
	starter=# select * from alphabet;
	 letter | letter_type
	--------+-------------
	 А      | гласная
	 Б      | согласная
	 В      | согласная
	 Г      | согласная
	 Д      | согласная
	 Ё      | гласная
	 Е      | гласная
	 Ж      | согласная
	 З      | согласная
	 И      | гласная
	 Й      | согласная
	 К      | согласная
	 Л      | согласная
	 М      | согласная
	 Н      | согласная
	 О      | гласная
	 П      | согласная
	 Р      | согласная
	 С      | согласная
	 Т      | согласная
	 У      | гласная
	 Ф      | согласная
	 Х      | согласная
	 Ц      | согласная
	 Ч      | согласная
	 Ш      | согласная
	 Щ      | согласная
	 Ъ      | нет звуков
	 Ы      | гласная
	 Ь      | нет звуков
	 Э      | гласная
	 Ю      | гласная
	 Я      | гласная
	(33 строки)
	Task:
	Создать таблицу classes;
	    Вставьте в нее все записи из приложенного файла (для таблицы classes);
	    Для каждого класса выведите уровень успеваемости. Если среднегодовая отметка    выше 3, то уровень успеваемости принимает значение 'выше среднего', иначе 'ниже     среднего';
	Decision:
	starter=# create table classes
	starter-#   (class_num varchar(4),
	starter(#   avg_year_mark int,
	starter(#   avg_month_mark int,
	starter(#   avg_term_mark int);
	starter=# insert into classes (class_num, avg_year_mark, avg_month_mark, avg_term_mark) values ('1 А', 4, 4, 5);
	starter=# insert into classes (class_num, avg_year_mark, avg_month_mark, avg_term_mark) values ('1 Б', 5, 5, 4);
	starter=# insert into classes (class_num, avg_year_mark, avg_month_mark, avg_term_mark) values ('2 А', 5, 5, 4);
	starter=# insert into classes (class_num, avg_year_mark, avg_month_mark, avg_term_mark) values ('2 Б', NULL, 5, 5);
	starter=# insert into classes (class_num, avg_year_mark, avg_month_mark, avg_term_mark) values ('3 А', 4, 4, 5);
	starter=# insert into classes (class_num, avg_year_mark, avg_month_mark, avg_term_mark) values ('3 Б', 4, 3, 4);
	starter=# insert into classes (class_num, avg_year_mark, avg_month_mark, avg_term_mark) values ('4 А', 5, 4, 3);
	starter=# insert into classes (class_num, avg_year_mark, avg_month_mark, avg_term_mark) values ('4 Б', 5, 4, 4);
	starter=# insert into classes (class_num, avg_year_mark, avg_month_mark, avg_term_mark) values ('5 А', 5, 4, 5);
	starter=# insert into classes (class_num, avg_year_mark, avg_month_mark, avg_term_mark) values ('5 Б', 4, 5, 3);
	starter=# insert into classes (class_num, avg_year_mark, avg_month_mark, avg_term_mark) values ('6 А', 3, 3, 3);
	starter=# insert into classes (class_num, avg_year_mark, avg_month_mark, avg_term_mark) values ('6 Б', 4, 5, 4);
	starter=# insert into classes (class_num, avg_year_mark, avg_month_mark, avg_term_mark) values ('7 А', 5, 5, 4);
	starter=# insert into classes (class_num, avg_year_mark, avg_month_mark, avg_term_mark) values ('7 Б', 4, 3, 4);
	starter=# insert into classes (class_num, avg_year_mark, avg_month_mark, avg_term_mark) values ('8 А', 3, 3, 4);
	starter=# insert into classes (class_num, avg_year_mark, avg_month_mark, avg_term_mark) values ('8 Б', 5, 4, 5);
	starter=# insert into classes (class_num, avg_year_mark, avg_month_mark, avg_term_mark) values ('9 А', 3, 3, 4);
	starter=# insert into classes (class_num, avg_year_mark, avg_month_mark, avg_term_mark) values ('9 Б', NULL, 5, 5);
	starter=# insert into classes (class_num, avg_year_mark, avg_month_mark, avg_term_mark) values ('10 А', 3, 4, 3);
	starter=# insert into classes (class_num, avg_year_mark, avg_month_mark, avg_term_mark) values ('10 Б', 5, 5, 4);
	starter=# insert into classes (class_num, avg_year_mark, avg_month_mark, avg_term_mark) values ('11 А', 5, 4, 4);
	starter=# insert into classes (class_num, avg_year_mark, avg_month_mark, avg_term_mark) values ('11 Б', 5, 5, 5);
	starter=# select * from classes;
	 class_num | avg_year_mark | avg_month_mark | avg_term_mark
	-----------+---------------+----------------+---------------
	 1 А       |             4 |              4 |             5
	 1 Б       |             5 |              5 |             4
	 2 А       |             5 |              5 |             4
	 2 Б       |               |              5 |             5
	 3 А       |             4 |              4 |             5
	 3 Б       |             4 |              3 |             4
	 4 А       |             5 |              4 |             3
	 4 Б       |             5 |              4 |             4
	 5 А       |             5 |              4 |             5
	 5 Б       |             4 |              5 |             3
	 6 А       |             3 |              3 |             3
	 6 Б       |             4 |              5 |             4
	 7 А       |             5 |              5 |             4
	 7 Б       |             4 |              3 |             4
	 8 А       |             3 |              3 |             4
	 8 Б       |             5 |              4 |             5
	 9 А       |             3 |              3 |             4
	 9 Б       |               |              5 |             5
	 10 А      |             3 |              4 |             3
	 10 Б      |             5 |              5 |             4
	 11 А      |             5 |              4 |             4
	 11 Б      |             5 |              5 |             5
	(22 строки)
	starter=# select
	starter-#   class_num,
	starter-#   avg_year_mark,
	starter-#   case
	starter-#     when avg_year_mark>3 and avg_year_mark<=5
	starter-#       then 'выше среднего'
	starter-#     when avg_year_mark<=3 and avg_year_mark>=1
	starter-#       then 'ниже среднего'
	starter-#     when avg_year_mark is null
	starter-#       then 'отметка не выставлена'
	starter-#     else 'ошибка значения'
	starter-#   end as progress
	starter-# from classes;
	 class_num | avg_year_mark |       progress
	-----------+---------------+-----------------------
	 1 А       |             4 | выше среднего
	 1 Б       |             5 | выше среднего
	 2 А       |             5 | выше среднего
	 2 Б       |               | отметка не выставлена
	 3 А       |             4 | выше среднего
	 3 Б       |             4 | выше среднего
	 4 А       |             5 | выше среднего
	 4 Б       |             5 | выше среднего
	 5 А       |             5 | выше среднего
	 5 Б       |             4 | выше среднего
	 6 А       |             3 | ниже среднего
	 6 Б       |             4 | выше среднего
	 7 А       |             5 | выше среднего
	 7 Б       |             4 | выше среднего
	 8 А       |             3 | ниже среднего
	 8 Б       |             5 | выше среднего
	 9 А       |             3 | ниже среднего
	 9 Б       |               | отметка не выставлена
	 10 А      |             3 | ниже среднего
	 10 Б      |             5 | выше среднего
	 11 А      |             5 | выше среднего
	 11 Б      |             5 | выше среднего
	(22 строки)
	Task:
	Для каждого класса из таблицы classes выведите наименьшее из трех средних   значений (Если число не заполнено, то вместо него используется число 3)
	Decision:
	starter=# select
	starter-#   class_num,
	starter-#   avg_year_mark,
	starter-#   avg_month_mark,
	starter-#   avg_term_mark,
	starter-#   case
	starter-#     when coalesce(avg_year_mark,3)<=coalesce(avg_month_mark ,3)
	starter-#       and coalesce(avg_year_mark,3)<=coalesce(avg_term_mark,3)
	starter-#         then coalesce(avg_year_mark,3)
	starter-#     when coalesce(avg_month_mark,3)<=coalesce(avg_year_mark ,3)
	starter-#       and coalesce(avg_month_mark,3)<=coalesce(avg_term_mark,3)
	starter-#         then coalesce(avg_month_mark,3)
	starter-#     else  coalesce(avg_term_mark,3)
	starter-#   end min_val
	starter-# from classes;
	 class_num | avg_year_mark | avg_month_mark | avg_term_mark | min_val
	-----------+---------------+----------------+---------------+---------
	 1 А       |             4 |              4 |             5 |       4
	 1 Б       |             5 |              5 |             4 |       4
	 2 А       |             5 |              5 |             4 |       4
	 2 Б       |               |              5 |             5 |       3
	 3 А       |             4 |              4 |             5 |       4
	 3 Б       |             4 |              3 |             4 |       3
	 4 А       |             5 |              4 |             3 |       3
	 4 Б       |             5 |              4 |             4 |       4
	 5 А       |             5 |              4 |             5 |       4
	 5 Б       |             4 |              5 |             3 |       3
	 6 А       |             3 |              3 |             3 |       3
	 6 Б       |             4 |              5 |             4 |       4
	 7 А       |             5 |              5 |             4 |       4
	 7 Б       |             4 |              3 |             4 |       3
	 8 А       |             3 |              3 |             4 |       3
	 8 Б       |             5 |              4 |             5 |       4
	 9 А       |             3 |              3 |             4 |       3
	 9 Б       |               |              5 |             5 |       3
	 10 А      |             3 |              4 |             3 |       3
	 10 Б      |             5 |              5 |             4 |       4
	 11 А      |             5 |              4 |             4 |       4
	 11 Б      |             5 |              5 |             5 |       5
	starter=# select
	starter-#   case
	starter-#     when avg_year_mark<=avg_month_mark
	starter-#       and coalesce(avg_year_mark,3)<=coalesce(avg_term_mark,3)
	starter-#         then coalesce(avg_year_mark,3)
	starter-#     when coalesce(avg_month_mark,3)<=coalesce(avg_year_mark ,3)
	starter-#       and coalesce(avg_month_mark,3)<=coalesce(avg_term_mark,3)
	starter-#         then coalesce(avg_month_mark,3)
	starter-#     when coalesce(avg_term_mark,3)<=coalesce(avg_month_mark ,3)
	starter-#       and coalesce(avg_term_mark,3)<=coalesce(avg_year_mark,3)
	starter-#         then  coalesce(avg_term_mark,3)
	starter-#   end min_val
	starter-# from
	starter-#   (select
	starter(#     class_num,
	starter(#     coalesce(avg_year_mark,3) as avg_year_mark,
	starter(#     coalesce(avg_month_mark,3) as avg_month_mark,
	starter(#     coalesce(avg_term_mark,3) as avg_term_mark
	starter(#   from classes) as minval;
	 min_val
	---------
	       4
	       4
	       4
	       3
	       4
	       3
	       3
	       4
	       4
	       3
	       3
	       4
	       4
	       3
	       3
	       4
	       3
	       3
	       3
	       4
	       4
	       5
	(22 строки)
	Task:
	Создать таблицу circles;
	    Вставьте в нее все записи из приложенного файла (для таблицы circles);
	    Для каждого круга рассчитайте и выведите требуемый показатель:
	    l (или L) – длина окружности (2*pi*R);
	    s (или S) – площадь круга (pi*R*R)
	    v (или V) – объем шара ((4/3)*pi*R*R*R)
	Decision:
	starter=# create table circles
	starter-#   (id varchar(20),
	starter(#   radius int,
	starter(#   value_cd varchar(5));
	starter=# insert into circles (id, radius, value_cd) values ('MU0000000020', 40, 's');
	starter=# insert into circles (id, radius, value_cd) values ('MU0000000060', 44, 'L');
	starter=# insert into circles (id, radius, value_cd) values ('MT0000000075', 15, 'V');
	starter=# insert into circles (id, radius, value_cd) values ('MT0000000010', 17, 's');
	starter=# insert into circles (id, radius, value_cd) values ('MU0000000048', 36, 'v');
	starter=# insert into circles (id, radius, value_cd) values ('MU0000000077', 33, 'l');
	starter=# insert into circles (id, radius, value_cd) values ('MU0000000088', 46, 's');
	starter=# insert into circles (id, radius, value_cd) values ('MU0000000056', 19, 'V');
	starter=# insert into circles (id, radius, value_cd) values ('MP0000000090', 42, 'v');
	starter=# insert into circles (id, radius, value_cd) values ('MU0000000084', 49, 'S');
	starter=# insert into circles (id, radius, value_cd) values ('MU0000000030', 45, 'v');
	starter=# insert into circles (id, radius, value_cd) values ('MP0000000018', 37, 'S');
	starter=# insert into circles (id, radius, value_cd) values ('MU0000000026', 37, 'l');
	starter=# insert into circles (id, radius, value_cd) values ('MU0000000053', 24, 'V');
	starter=# insert into circles (id, radius, value_cd) values ('MB0000000079', 8, 'NULL');
	starter=# insert into circles (id, radius, value_cd) values ('MU0000000042', 47, 's');
	starter=# insert into circles (id, radius, value_cd) values ('MU0000000056', 42, 'l');
	starter=# insert into circles (id, radius, value_cd) values ('MT0000000142', 40, 'v');
	starter=# insert into circles (id, radius, value_cd) values ('MT0000000065', 34, 'V');
	starter=# insert into circles (id, radius, value_cd) values ('MT000000006', 47, 's');
	starter=# insert into circles (id, radius, value_cd) values ('MU000000009', 28, 'S');
	starter=# insert into circles (id, radius, value_cd) values ('MU0000000039', 20, 'L');
	starter=# select * from circles;
	      id      | radius | value_cd
	--------------+--------+----------
	 MU0000000020 |     40 | s
	 MU0000000060 |     44 | L
	 MT0000000075 |     15 | V
	 MT0000000010 |     17 | s
	 MU0000000048 |     36 | v
	 MU0000000077 |     33 | l
	 MU0000000088 |     46 | s
	 MU0000000056 |     19 | V
	 MP0000000090 |     42 | v
	 MU0000000084 |     49 | S
	 MU0000000030 |     45 | v
	 MP0000000018 |     37 | S
	 MU0000000026 |     37 | l
	 MU0000000053 |     24 | V
	 MB0000000079 |      8 | NULL
	 MU0000000042 |     47 | s
	 MU0000000056 |     42 | l
	 MT0000000142 |     40 | v
	 MT0000000065 |     34 | V
	 MT000000006  |     47 | s
	 MU000000009  |     28 | S
	 MU0000000039 |     20 | L
	(22 строки)
	starter=# select
	starter-#   id,
	starter-#   case
	starter-#     when value_cd in ('l','L')
	starter-#       then radius*3.14*2
	starter-#     when value_cd in ('s','S')
	starter-#       then radius*radius*3.14
	starter-#     when value_cd in ('v','V')
	starter-#       then radius*radius*radius*3.14*(4/3)
	starter-#     else value_cd
	starter-#   end as result
	starter-# from circles;
	id  result
	MU0000000020    5024
	MU0000000060    276.32
	MT0000000075    10597.5
	MT0000000010    907.46
	MU0000000048    146499.84
	MU0000000077    207.24
	MU0000000088    6644.240000000001
	MU0000000056    21537.260000000002
	MP0000000090    232636.32
	MU0000000084    7539.14
	MU0000000030    286132.5
	MP0000000018    4298.66
	MU0000000026    232.36
	MU0000000053    43407.36
	MB0000000079    NULL
	MU0000000042    6936.26
	MU0000000056    263.76
	MT0000000142    200960
	MT0000000065    123414.56
	MT000000006 6936.26
	MU000000009 2461.76
	MU0000000039    125.60000000000001
	Task:
	Для таблицы circles определить систему источника данных и номер круга: MU0000000001
	MU - система источника, 1 - номер круга
	Decision:
	starter=# select
	starter-#   id,
	starter-#   rtrim(substr(id,1,2),'0') source_system,
	starter-#   ltrim(substr(id,3), '0') circle_number
	starter-# from circles;
	      id      | source_system | circle_number
	--------------+---------------+---------------
	 MU0000000020 | MU            | 20
	 MU0000000060 | MU            | 60
	 MT0000000075 | MT            | 75
	 MT0000000010 | MT            | 10
	 MU0000000048 | MU            | 48
	 MU0000000077 | MU            | 77
	 MU0000000088 | MU            | 88
	 MU0000000056 | MU            | 56
	 MP0000000090 | MP            | 90
	 MU0000000084 | MU            | 84
	 MU0000000030 | MU            | 30
	 MP0000000018 | MP            | 18
	 MU0000000026 | MU            | 26
	 MU0000000053 | MU            | 53
	 MB0000000079 | MB            | 79
	 MU0000000042 | MU            | 42
	 MU0000000056 | MU            | 56
	 MT0000000142 | MT            | 142
	 MT0000000065 | MT            | 65
	 MT000000006  | MT            | 6
	 MU000000009  | MU            | 9
	 MU0000000039 | MU            | 39
	(22 строки)
	starter=# SELECT
	starter-#   SUBSTR(LTRIM(id),1, 2) AS source_system,
	starter-#   cast(SUBSTR(id,3) as int) AS num_circle
	starter-# FROM circles;SELECT
	 source_system | num_circle
	---------------+------------
	 MU            |         20
	 MU            |         60
	 MT            |         75
	 MT            |         10
	 MU            |         48
	 MU            |         77
	 MU            |         88
	 MU            |         56
	 MP            |         90
	 MU            |         84
	 MU            |         30
	 MP            |         18
	 MU            |         26
	 MU            |         53
	 MB            |         79
	 MU            |         42
	 MU            |         56
	 MT            |        142
	 MT            |         65
	 MT            |          6
	 MU            |          9
	 MU            |         39
	(22 строки)
	Task:
	Создать таблицу purchases;
	    Вставьте в нее все записи из приложенного файла (для таблицы purchases);
	    Выведите уникальные города клиентов;
	Decision:
	starter=# create table purchases (
	starter(#   surname varchar(50),
	starter(#   name varchar(50),
	starter(#   second_name varchar(50),
	starter(#   region varchar(50),
	starter(#   city varchar(50),
	starter(#   street_type varchar(50),
	starter(#   street_nm varchar(50),
	starter(#   house_num varchar(10),
	starter(#   phone_number bigint,
	starter(#   email varchar(50),
	starter(#   purchase_dt varchar(50),
	starter(#   product_cnt int,
	starter(#   purchase_amt int,
	starter(#   currency_nm varchar(50),
	starter(#   current_discount varchar(50));
	starter=# insert into purchases (surname, name, second_name, region, city, street_type, street_nm, house_num, phone_number, email, purchase_dt, product_cnt, purchase_amt, currency_nm, current_discount) values ('Смирнов', 'Александр', 'Александрович', 'Москва', 'Москва', 'улица', 'Шмидте', '2', 74950054758, 'smirnov@ya.ru ', '01.11.2021', 4, 125, 'US', 'NULL');
	starter=# insert into purchases (surname, name, second_name, region, city, street_type, street_nm, house_num, phone_number, email, purchase_dt, product_cnt, purchase_amt, currency_nm, current_discount) values ('Иванов', 'Сергей', 'Алексеевич', 'Московская область', 'Химки', 'проспект', '50 лет октября', '17', 79061793723, 'ivanov@gmail.com', '02.11.2021', 5, 5679, 'RUR', 'NULL');
	starter=# insert into purchases (surname, name, second_name, region, city, street_type, street_nm, house_num, phone_number, email, purchase_dt, product_cnt, purchase_amt, currency_nm, current_discount) values ('Кузнецов', 'Владимир', 'Анатольевич', 'Ростовская область', 'Ростов-на-Дону', 'переулок', 'Дружбы', '51', 79036038662, 'kuznecov@yandex.ru', '03.11.2021', 10, 9211, 'RUR', 'NULL');
	starter=# insert into purchases (surname, name, second_name, region, city, street_type, street_nm, house_num, phone_number, email, purchase_dt, product_cnt, purchase_amt, currency_nm, current_discount) values ('Соколова', 'Елена', 'Андреевна', 'Свердловская область', 'Екатеринбург', 'бульвар', 'Цветной', '64', 74951752838, 'sokolova@mail.com', '01.01.2022', 12, 5476, 'RUR', 'NULL');
	starter=# insert into purchases (surname, name, second_name, region, city, street_type, street_nm, house_num, phone_number, email, purchase_dt, product_cnt, purchase_amt, currency_nm, current_discount) values ('Попова ', 'Татьяна', 'Александровна', 'Санкт-Петербург', 'Санкт-Петербург', 'улица', 'Ленина', '11', 79209217902, 'popova@yahoo.com', '03.02.2022', 6, 242, 'EUR', '10');
	starter=# insert into purchases (surname, name, second_name, region, city, street_type, street_nm, house_num, phone_number, email, purchase_dt, product_cnt, purchase_amt, currency_nm, current_discount) values ('Лебедев', 'Андрей', 'Аркадьевич', 'Ростовская область', 'Ростов-на-Дону', 'переулок', 'Смирновский', '100', 74999545208, 'lebedev@yahoo.com', '04.02.2022', 18, 9925, 'RUR', '12');
	starter=# insert into purchases (surname, name, second_name, region, city, street_type, street_nm, house_num, phone_number, email, purchase_dt, product_cnt, purchase_amt, currency_nm, current_discount) values ('Козлов', 'Алексей', 'Артемович', 'Москва', 'Москва', 'улица', 'Ленина', '3', 74999545205, 'kozlov@ya.ru', '05.02.2022', 8, 7218, 'RUR', '10');
	starter=# insert into purchases (surname, name, second_name, region, city, street_type, street_nm, house_num, phone_number, email, purchase_dt, product_cnt, purchase_amt, currency_nm, current_discount) values ('Новикова', 'Ольга', 'Андреевна', 'Санкт-Петербург', 'Санкт-Петербург', 'бульвар', 'Петровский', '45', 74999545202, 'novikova@yandex.ru', '06.02.2022', 11, 34, 'EUR', 'NULL');
	starter=# insert into purchases (surname, name, second_name, region, city, street_type, street_nm, house_num, phone_number, email, purchase_dt, product_cnt, purchase_amt, currency_nm, current_discount) values (' Морозов', 'Николай', 'Богданович', 'Рязанская область', 'Рязань', 'проспект', 'Московский', '67', NULL, 'morozov@gmail.com', '07.02.2022', 2, 4101, 'RUR', 'NULL');
	starter=# insert into purchases (surname, name, second_name, region, city, street_type, street_nm, house_num, phone_number, email, purchase_dt, product_cnt, purchase_amt, currency_nm, current_discount) values ('Петров', 'Наталья', 'Александровна', 'Ростовская область', 'Ростов-на-Дону', 'улица', 'Ленина', '65', 74999937334, 'PETROV@GMAIL.COM', '08.02.2022', 4, 8013, 'RUR', 'NULL');
	starter=# insert into purchases (surname, name, second_name, region, city, street_type, street_nm, house_num, phone_number, email, purchase_dt, product_cnt, purchase_amt, currency_nm, current_discount) values ('Волкова', 'Анна', 'Валентиновна', 'Москва', 'Москва', 'улица', 'Ленина', '73', 74950692731, 'volkova@gmail.com', '11.11.2021', 9, 7733, 'RUR', '10');
	starter=# insert into purchases (surname, name, second_name, region, city, street_type, street_nm, house_num, phone_number, email, purchase_dt, product_cnt, purchase_amt, currency_nm, current_discount) values ('Соловьёв', 'Иван', 'Валерьевич', 'Москва', 'Москва', 'переулок', 'Глинки', '33', 77767813970, 'soloviyev@gmail.com', '08.02.2022', 9, 7566, 'RUR', 'NULL');
	starter=# insert into purchases (surname, name, second_name, region, city, street_type, street_nm, house_num, phone_number, email, purchase_dt, product_cnt, purchase_amt, currency_nm, current_discount) values ('Васильев', 'Дмитрий', 'Васильевич', 'Ростовская область', 'Ростов-на-Дону', 'улица', 'Ленина', '25', 74951662623, 'vasiliyev@mail.com', '13.11.2021', 18, 2608, 'CNY', 'NULL');
	starter=# insert into purchases (surname, name, second_name, region, city, street_type, street_nm, house_num, phone_number, email, purchase_dt, product_cnt, purchase_amt, currency_nm, current_discount) values ('Зайцева', 'Ирина', 'Викторовна', 'Санкт-Петербург', 'Санкт-Петербург', 'бульвар', 'Волжский', '74', 79093871696, 'zayceva@ya.ru', '08.02.2022', 12, 8694, 'RUR', 'NULL');
	starter=# insert into purchases (surname, name, second_name, region, city, street_type, street_nm, house_num, phone_number, email, purchase_dt, product_cnt, purchase_amt, currency_nm, current_discount) values ('Павлова ', 'Мария', 'Витальевна', 'Москва', 'Москва', 'проспект', 'Свободы', '81', 74953740142, 'PAVLOVA@GMAIL.COM', '09.02.2022', 12, 5291, 'RUR', 'NULL');
	starter=# insert into purchases (surname, name, second_name, region, city, street_type, street_nm, house_num, phone_number, email, purchase_dt, product_cnt, purchase_amt, currency_nm, current_discount) values ('Семёнов', 'Михаил', 'Владимирович', 'Свердловская область', 'Екатеринбург', 'переулок', 'Некрасовский', '44', NULL, 'semenov@mail.com', '10.02.2022', 9, 7087, 'RUR', 'NULL');
	starter=# insert into purchases (surname, name, second_name, region, city, street_type, street_nm, house_num, phone_number, email, purchase_dt, product_cnt, purchase_amt, currency_nm, current_discount) values ('Голубева', 'Светлана', 'Владиславовна', 'Ростовская область', 'Ростов-на-Дону', 'улица', 'Ленина', '44', 74995861301, 'golubeva@gmail.com', '11.02.2022', 11, 3282, 'RUR', 'NULL');
	starter=# insert into purchases (surname, name, second_name, region, city, street_type, street_nm, house_num, phone_number, email, purchase_dt, product_cnt, purchase_amt, currency_nm, current_discount) values ('Виноградова', 'Екатерина', 'Владиславовна', 'Москва', 'Москва', 'бульвар', 'Победы', '85', 74995860591, 'vinogradova@ya.ru', '18.11.2021', 20, 123, 'US', 'NULL');
	starter=# insert into purchases (surname, name, second_name, region, city, street_type, street_nm, house_num, phone_number, email, purchase_dt, product_cnt, purchase_amt, currency_nm, current_discount) values ('Богданов', 'Евгений', 'Вячеславович', 'Санкт-Петербург', 'Санкт-Петербург', 'проспект', 'Революции', '3', 74995861296, 'BOGDANOV@gmail.com', '19.11.2021', 6, 6563, 'RUR', 'NULL');
	starter=# insert into purchases (surname, name, second_name, region, city, street_type, street_nm, house_num, phone_number, email, purchase_dt, product_cnt, purchase_amt, currency_nm, current_discount) values ('Воробьёв', 'Виктор', 'Геннадиевич', 'Ростовская область', 'Ростов-на-Дону', 'улица', 'Дзержинского', '20', 74953741652, 'vorobiyev@gmail.com', '20.11.2021', 8, 3867, 'RUR', 'NULL');
	starter=# insert into purchases (surname, name, second_name, region, city, street_type, street_nm, house_num, phone_number, email, purchase_dt, product_cnt, purchase_amt, currency_nm, current_discount) values ('Фёдорова', 'Анастасия', 'Георгиевна', 'Рязанская область', 'Рязань', 'улица', 'Победы', '55', 74950097648, 'NULL', '21.11.2021', 5, 56, 'EUR', 'NULL');
	starter=# insert into purchases (surname, name, second_name, region, city, street_type, street_nm, house_num, phone_number, email, purchase_dt, product_cnt, purchase_amt, currency_nm, current_discount) values ('Михайлов', 'Юрий', 'Григорьевич', 'Москва', 'Москва', 'переулок', 'Лермонтовский', '45', 74992166013, 'mikhaylov@mail.com ', '08.02.2022', 8, 6283, 'RUR', 'NULL');
	starter=# insert into purchases (surname, name, second_name, region, city, street_type, street_nm, house_num, phone_number, email, purchase_dt, product_cnt, purchase_amt, currency_nm, current_discount) values ('Беляева', 'Юлия', 'Валентиновна', 'Рязанская область', 'Рязань', 'бульвар', 'Гагарина', '50', 78002220480, 'NULL', '09.02.2022', 18, 7535, 'RUR', '10%');
	starter=# insert into purchases (surname, name, second_name, region, city, street_type, street_nm, house_num, phone_number, email, purchase_dt, product_cnt, purchase_amt, currency_nm, current_discount) values ('Тарасова', 'Валентина', 'Денисовна', 'Москва', 'Москва', 'улица', 'Ленина', '54', 73432203735, 'belova@gmail.com', '10.02.2022', 1, 2247, 'RUR', 'NULL');
	starter=# insert into purchases (surname, name, second_name, region, city, street_type, street_nm, house_num, phone_number, email, purchase_dt, product_cnt, purchase_amt, currency_nm, current_discount) values ('Белова', 'Галина', 'Валентиновна', 'Санкт-Петербург', 'Санкт-Петербург', 'проспект', 'Невский', '30', 73432203718, 'NULL', '25.11.2021', 15, 4612, 'RUR', 'NULL');
	starter=# insert into purchases (surname, name, second_name, region, city, street_type, street_nm, house_num, phone_number, email, purchase_dt, product_cnt, purchase_amt, currency_nm, current_discount) values ('Комарова', 'Людмила', 'Евгеньевна', 'Рязанская область', 'Рязань', 'улица', 'Ленина', '15', 74993506931, ' KOMAROVA@MAIL.COM', '08.02.2022', 7, 7808, 'RUR', '25%');
	starter=# insert into purchases (surname, name, second_name, region, city, street_type, street_nm, house_num, phone_number, email, purchase_dt, product_cnt, purchase_amt, currency_nm, current_discount) values ('Орлов', 'Василий', 'Егорович', 'Ростовская область', 'Ростов-на-Дону', 'бульвар', 'Дзержинского', '19', 79031193345, 'orlov@gmail.com', '27.11.2021', 17, 321, 'US', 'NULL');
	starter=# insert into purchases (surname, name, second_name, region, city, street_type, street_nm, house_num, phone_number, email, purchase_dt, product_cnt, purchase_amt, currency_nm, current_discount) values ('Киселёв', 'Игорь', 'Ефимович', 'Москва', 'Москва', 'проспект', 'Красный', '10', 74996382013, 'NULL', '08.02.2022', 1, 1207, 'RUR', 'NULL');
	starter=# insert into purchases (surname, name, second_name, region, city, street_type, street_nm, house_num, phone_number, email, purchase_dt, product_cnt, purchase_amt, currency_nm, current_discount) values ('Макаров', 'Анатолий', 'Иванович', 'Санкт-Петербург', 'Санкт-Петербург', 'улица', 'Ленина', '27', 79253628473, 'makarov@mail.com', '29.11.2021', 6, 7138, 'RUR', 'NULL');
	starter=# insert into purchases (surname, name, second_name, region, city, street_type, street_nm, house_num, phone_number, email, purchase_dt, product_cnt, purchase_amt, currency_nm, current_discount) values ('Андреев ', 'Олег', 'Иваныч', 'Москва', 'Москва', 'переулок', 'Тургеневский', '79', 74951203035, 'andreev@gmail.com ', '30.11.2021', 16, 1022, 'RUR', 'NULL');
	starter=# select distinct city
	starter-# from purchases
	starter-# where city is not null;
	      city
	-----------------
	 Химки
	 Рязань
	 Екатеринбург
	 Москва
	 Санкт-Петербург
	 Ростов-на-Дону
	(6 строк)

База данных "Курьерская служба"
	Task:
	There is a company delivering orders - a Courier Service.
	The order table contains information about the order that the courier will deliver.
	FIO –recipient's full name;
	address – delivery address;
	courier – code of the employee who delivered the shipment, null by default;
	price –delivery cost;
	The order tracking trace table contains the history of various order statuses.
	state – order status code: 1 – new; 2– accepted at the warehouse; 3– delivered; 4–not delivered
	datetime– date and time of the status;
	The courier table contains information about employees (couriers and managers).
	FIO – Full name of the courier
	manager – the courier contains the manager code, null by default
	Decision:
	# sudo -i -u postgres
	[postgres@i6 ~]$ psql
	postgres=# CREATE DATABASE CourierService;
	CREATE DATABASE
	postgres=# \c courierservice
	Вы подключены к базе данных "courierservice" как пользователь "postgres".
	courierservice=# CREATE TABLE employees (
	 id SERIAL PRIMARY KEY,
	 manager_id INT REFERENCES employees(id),
	 full_name VARCHAR,
	 address VARCHAR,
	 phone VARCHAR,
	 hired_at TIMESTAMP,
	 fired_at TIMESTAMP
	 );
	CREATE TABLE
	courierservice=# CREATE TABLE order_states (
	 id SERIAL PRIMARY KEY,
	 state VARCHAR
	 );
	CREATE TABLE
	courierservice=# CREATE TABLE orders (
	 id SERIAL PRIMARY KEY,
	 customer VARCHAR,
	 address VARCHAR,
	 courier_id INT REFERENCES employees(id),
	 price NUMERIC
	 );
	CREATE TABLE
	courierservice=# CREATE TABLE trace (
	 id BIGSERIAL PRIMARY KEY,
	 state_id INT REFERENCES order_states(id),
	 order_id INT REFERENCES orders(id),
	 updated_at TIMESTAMP
	 );
	CREATE TABLE
	courierservice=# INSERT INTO employees (manager_id, full_name, address, phone, hired_at, fired_at)
	 VALUES ('1', 'Иванов Иван Иванович', 'Невский проспект, 11', '+790865454', '2022-05-04 12:10:57', '2022-05-006 13:10:57'),
	 ('2', 'Иванова Анна Ивановна', 'Набережная реки Мойки, 48', '+790865454', '2022-05-04 12:10:57', '2022-05-006 13:10:57');
	INSERT 0 2
	courierservice=# SELECT * FROM employees;
	 id | manager_id |       full_name       |          address          |   phone    |      hired_at       |      fired_at       
	----+------------+-----------------------+---------------------------+------------+---------------------+---------------------
	  1 |          1 | Иванов Иван Иванович  | Невский проспект, 11      | +790865454 | 2022-05-04 12:10:57 | 2022-05-06 13:10:57
	  2 |          2 | Иванова Анна Ивановна | Набережная реки Мойки, 48 | +790865454 | 2022-05-04 12:10:57 | 2022-05-06 13:10:57
	(2 строки)
	courierservice=# INSERT INTO order_states (state)
	 VALUES ('новый'),
	 ('в доставке'),
	 ('доставлен'),
	 ('отменен');
	INSERT 0 4
	courierservice=# SELECT * FROM order_states;
	 id |   state    
	----+------------
	  1 | новый
	  2 | в доставке
	  3 | доставлен
	  4 | отменен
	(4 строки)
	courierservice=# INSERT INTO orders (customer, address, courier_id, price)
	 VALUES ('Иванов Алесандр Иванович', 'Баумана, 121', '2', '150'),
	 ('Иванов Андрей Иванович', 'Ленина, 122', '2', '200'),
	 ('Иванов Михаил Иванович', 'Ленина, 122', '1', '150');
	INSERT 0 3
	courierservice=# SELECT * FROM orders;
	 id |         customer         |   address    | courier_id | price
	----+--------------------------+--------------+------------+-------
	  1 | Иванов Алесандр Иванович | Баумана, 121 |          2 |   150
	  2 | Иванов Андрей Иванович   | Ленина, 122  |          2 |   200
	  3 | Иванов Михаил Иванович   | Ленина, 122  |          1 |   150
	(3 строки)
	courierservice=# INSERT INTO trace (state_id, order_id, updated_at)
	 VALUES ('4', '3', '2022-06-06 13:20:57'),
	 ('2', '2', '2022-07-07 13:20:58'),
	 ('3', '1', '2022-05-05 14:02:07');
	INSERT 0 3
	courierservice=# INSERT INTO trace (state_id, order_id, updated_at)
	 VALUES ('4', '3', '2022-06-06 13:20:57'),
	 ('4', '3', '2022-07-05 13:25:28'),
	 ('1', '3', '2022-06-05 14:01:07');
	INSERT 0 3
	courierservice=# SELECT * FROM trace;
	 id | state_id | order_id |     updated_at      
	----+----------+----------+---------------------
	  1 |        4 |        3 | 2022-06-06 13:20:57
	  2 |        2 |        2 | 2022-07-07 13:20:58
	  3 |        3 |        1 | 2022-05-05 14:02:07
	  4 |        4 |        3 | 2022-06-06 13:20:57
	  5 |        4 |        3 | 2022-07-05 13:25:28
	  6 |        1 |        3 | 2022-06-05 14:01:07
	(6 строк)
	Task:
	Выведите все доставленные заказы, которые не были приняты на склад.
	Decision:
	courierservice=# SELECT * FROM order_states;
	 id |   state    
	----+------------
	  1 | новый
	  2 | в доставке
	  3 | доставлен
	  4 | отменен
	(4 строки)
	courierservice=# SELECT * FROM orders;
	 id |         customer         |   address    | courier_id | price
	----+--------------------------+--------------+------------+-------
	  1 | Иванов Алесандр Иванович | Баумана, 121 |          2 |   150
	  2 | Иванов Андрей Иванович   | Ленина, 122  |          2 |   200
	  3 | Иванов Михаил Иванович   | Ленина, 122  |          1 |   150
	(3 строки)
	courierservice=# SELECT * FROM trace;
	 id | state_id | order_id |     updated_at      
	----+----------+----------+---------------------
	  1 |        4 |        3 | 2022-06-06 13:20:57
	  2 |        2 |        2 | 2022-07-07 13:20:58
	  3 |        3 |        1 | 2022-05-05 14:02:07
	(3 строки)
	courierservice=# SELECT orders.*
	 FROM orders
	 JOIN trace t ON t.order_id=orders.id AND t.state_id=3
	 LEFT JOIN trace t2 ON t2.order_id=orders.id AND t2.state_id=2
	 WHERE t2.id IS NULL;
	 id |         customer         |   address    | courier_id | price
	----+--------------------------+--------------+------------+-------
	  1 | Иванов Алесандр Иванович | Баумана, 121 |          2 |   150
	(1 строка)
	Task:
	Выведите курьеров доставивших больше заказов, чем их менеджеры.
	Decision:
	courierservice=# SELECT * FROM employees;
	 id | manager_id |       full_name       |          address          |   phone    |      hired_at       |      fired_at       
	----+------------+-----------------------+---------------------------+------------+---------------------+---------------------
	  1 |          1 | Иванов Иван Иванович  | Невский проспект, 11      | +790865454 | 2022-05-04 12:10:57 | 2022-05-06 13:10:57
	  2 |          2 | Иванова Анна Ивановна | Набережная реки Мойки, 48 | +790865454 | 2022-05-04 12:10:57 | 2022-05-06 13:10:57
	(2 строки)
	courierservice=# SELECT * FROM orders;
	 id |         customer         |   address    | courier_id | price
	----+--------------------------+--------------+------------+-------
	  1 | Иванов Алесандр Иванович | Баумана, 121 |          2 |   150
	  2 | Иванов Андрей Иванович   | Ленина, 122  |          2 |   200
	  3 | Иванов Михаил Иванович   | Ленина, 122  |          1 |   150
	(3 строки)
	courierservice=# SELECT * FROM trace;
	 id | state_id | order_id |     updated_at      
	----+----------+----------+---------------------
	  1 |        4 |        3 | 2022-06-06 13:20:57
	  2 |        2 |        2 | 2022-07-07 13:20:58
	  3 |        3 |        1 | 2022-05-05 14:02:07
	(3 строки)
	courierservice=# SELECT k.*
	FROM employees k
	WHERE k.manager_id
	IS NOT NULL AND
	(SELECT COUNT(*)
	    FROM orders
	    WHERE courier_id=k.id) >
	(SELECT COUNT(*)
	    FROM orders
	    WHERE courier_id=k.manager_id);
	Task:
	Выведите менеджеров и стоимость всех доставленных их курьерами заказов, за последний месяц.
	Decision:
	courierservice=# SELECT * FROM trace;
	 id | state_id | order_id |     updated_at      
	----+----------+----------+---------------------
	  1 |        4 |        3 | 2022-06-06 13:20:57
	  2 |        2 |        2 | 2022-07-07 13:20:58
	  3 |        3 |        1 | 2022-05-05 14:02:07
	(3 строки)
	courierservice=# SELECT * FROM orders;
	 id |         customer         |   address    | courier_id | price
	----+--------------------------+--------------+------------+-------
	  1 | Иванов Алесандр Иванович | Баумана, 121 |          2 |   150
	  2 | Иванов Андрей Иванович   | Ленина, 122  |          2 |   200
	  3 | Иванов Михаил Иванович   | Ленина, 122  |          1 |   150
	(3 строки)
	courierservice=# SELECT * FROM employees;
	 id | manager_id |       full_name       |          address          |   phone    |      hired_at       |      fired_at       
	----+------------+-----------------------+---------------------------+------------+---------------------+---------------------
	  1 |          1 | Иванов Иван Иванович  | Невский проспект, 11      | +790865454 | 2022-05-04 12:10:57 | 2022-05-06 13:10:57
	  2 |          2 | Иванова Анна Ивановна | Набережная реки Мойки, 48 | +790865454 | 2022-05-04 12:10:57 | 2022-05-06 13:10:57
	(2 строки)
	courierservice=# SELECT k2.*, SUM(o.price) AS price
	FROM trace t
	JOIN orders o ON o.id=t.order_id
	JOIN employees k ON k.id=o.courier_id
	JOIN employees k2 ON k2.id=k.manager_id
	WHERE t.state_id = 3 AND
	    t.updated_at>date_sub(current_date(), INTERVAL 1 MONTH)
	GROUP BY k2.id;
	Task:
	Выведите менеджеров, у которых не более трех курьеров.
	Decision:
	courierservice=# SELECT k.*, COUNT(k2.id)
	 FROM employees k
	 LEFT JOIN employees k2 ON k2.manager_id = k.id
	 WHERE k.manager_id IS NULL
	 GROUP BY k.id
	 HAVING COUNT(k2.id) < 4;
	Task:
	Выведите заказы и последний установленный у него статус. Оставить в отчете только статусы: новый и принят на склад.
	Decision:
	courierservice=# SELECT * FROM orders;
	 id |         customer         |   address    | courier_id | price
	----+--------------------------+--------------+------------+-------
	  1 | Иванов Алесандр Иванович | Баумана, 121 |          2 |   150
	  2 | Иванов Андрей Иванович   | Ленина, 122  |          2 |   200
	  3 | Иванов Михаил Иванович   | Ленина, 122  |          1 |   150
	(3 строки)
	courierservice=# SELECT * FROM trace;
	 id | state_id | order_id |     updated_at      
	----+----------+----------+---------------------
	  1 |        4 |        3 | 2022-06-06 13:20:57
	  2 |        2 |        2 | 2022-07-07 13:20:58
	  3 |        3 |        1 | 2022-05-05 14:02:07
	(3 строки)
	courierservice=# SELECT o.*,
	    (SELECT state_id
	    FROM trace WHERE order_id=o.id
	    ORDER BY updated_at DESC LIMIT 1) AS status
	FROM orders o
	HAVING status IN (1, 2);
	Decision:
	https://github.com/David138it/MyPortfolio/tree/main/TaskDecision/Engineer-Isu/Sql/
	Source:
	1. https://www.asozykin.ru/?ysclid=lk9eaatbqj18673257

База данных "Staff"
	Task:
	Сотрудники зарабатывают больше, чем их менеджеры
	Task:
	Table: Employee
	+-------------+---------+
	| Column Name | Type    |
	+-------------+---------+
	| id          | int     |
	| name        | varchar |
	| salary      | int     |
	| managerId   | int     |
	+-------------+---------+
	Напишите SQL-запрос, чтобы найти сотрудников, которые зарабатывают больше, чем их менеджеры. Верните таблицу результатов в любом порядке.
	Decision:
	postgres=# DROP TABLE IF EXISTS Employee;
	    ЗАМЕЧАНИЕ:  таблица "employee" не существует, пропускается
	    DROP TABLE
	postgres=# CREATE TABLE Employee(
	postgres(#   id INT,
	postgres(#   name VARCHAR,
	postgres(#   salary INT,
	postgres(#   managerid INT
	postgres(# );
	    CREATE TABLE
	postgres=# SELECT * FROM Employee;
	     id | name | salary | managerid
	    ----+------+--------+-----------
	    (0 строк)
	postgres=# INSERT INTO Employee(id, name, salary, managerid) VALUES (1, 'Joe', 70000, 3);
	    INSERT 0 1
	postgres=# INSERT INTO Employee(id, name, salary, managerid) VALUES (2, 'Henry', 80000, 4);
	    INSERT 0 1
	postgres=# INSERT INTO Employee(id, name, salary) VALUES (3, 'Sam', 60000);
	    INSERT 0 1
	postgres=# INSERT INTO Employee(id, name, salary) VALUES (4, 'Max', 90000);
	    INSERT 0 1
	postgres=# SELECT * FROM Employee;
	     id | name  | salary | managerid
	    ----+-------+--------+-----------
	      1 | Joe   |  70000 |         3
	      2 | Henry |  80000 |         4
	      3 | Sam   |  60000 |
	      4 | Max   |  90000 |
	    (4 строки)
	postgres=# SELECT * FROM Employee AS e JOIN Employee AS m
	postgres-# ON e.managerid = m.id;
	     id | name  | salary | managerid | id | name | salary | managerid
	    ----+-------+--------+-----------+----+------+--------+-----------
	      1 | Joe   |  70000 |         3 |  3 | Sam  |  60000 |
	      2 | Henry |  80000 |         4 |  4 | Max  |  90000 |
	    (2 строки)
	postgres=# SELECT * FROM Employee AS e JOIN Employee AS m
	ON e.managerid = m.id
	postgres-# WHERE e.salary > m.salary;
	     id | name | salary | managerid | id | name | salary | managerid
	    ----+------+--------+-----------+----+------+--------+-----------
	      1 | Joe  |  70000 |         3 |  3 | Sam  |  60000 |
	    (1 строка)
	postgres=# SELECT e.name FROM Employee AS e JOIN Employee AS m
	ON e.managerid = m.id
	WHERE e.salary > m.salary;
	     name
	    ------
	     Joe
	    (1 строка)
	postgres=# SELECT e.name AS Employee FROM Employee AS e JOIN Employee AS m
	ON e.managerid = m.id
	WHERE e.salary > m.salary;
	     employee
	    ----------
	     Joe
	    (1 строка)
	Task:
	Самая высокая зарплата в отделе
	Task:
	Table: Employee
	+--------------+---------+
	| Column Name  | Type    |
	+--------------+---------+
	| id           | int     |
	| name         | varchar |
	| salary       | int     |
	| departmentId | int     |
	+--------------+---------+
	Table: Department
	+-------------+---------+
	| Column Name | Type    |
	+-------------+---------+
	| id          | int     |
	| name        | varchar |
	+-------------+---------+
	Напишите SQL-запрос, чтобы найти сотрудников с самой высокой зарплатой в каждом из отделов.
	Верните таблицу результатов в любом порядке.
	Decision:
	postgres=# DROP TABLE IF EXISTS Employee;
	TE TABLE Employee(
	    Id INT,
	    Name VARCHAR,
	    Salary INT,
	    DepartmentId INT
	);
	    DROP TABLE IF EXISTS DROP TABLE
	postgres=# CREATE TABLE Employee(
	postgres(#     Id INT,
	postgres(#     Name VARCHAR,
	postgres(#     Salary INT,
	postgres(#     DepartmentId INT
	postgres(# );
	CREATE TABLE Department(
	    Id Int,
	    Name VARCHAR
	);
	    INSERT INCREATE TABLE
	postgres=# DROP TABLE IF EXISTS Department;
	    DROP TABLE
	postgres=# CREATE TABLE Department(
	postgres(#     Id Int,
	postgres(#     Name VARCHAR
	postgres(# );
	    CREATE TABLE
	postgres=# INSERT INTO Employee(Id, Name, Salary, DepartmentId) VALUES(1, 'Joe', 70000, 1);
	    ERT INSERT 0 1
	postgres=# INSERT INTO Employee(Id, Name, Salary, DepartmentId) VALUES(2, 'Jim', 90000, 1);
	    NSERINSERT 0 1
	postgres=# INSERT INTO Employee(Id, Name, Salary, DepartmentId) VALUES(3, 'Henry', 80000, 2);
	    O EmplINSERT 0 1
	postgres=# INSERT INTO Employee(Id, Name, Salary, DepartmentId) VALUES(4, 'Sam', 60000, 2);
	    INSERT 0 1
	postgres=# INSERT INTO Employee(Id, Name, Salary, DepartmentId) VALUES(5, 'Max', 90000, 1);
	    NSERINSERT 0 1
	postgres=# INSERT INTO Department(Id, Name) VALUES (1, 'IT');
	    INSERT INTO DepartmINSERT 0 1
	postgres=# INSERT INTO Department(Id, Name) VALUES (2, 'Sales');
	    INSERT 0 1
	postgres=# SELECT * FROM Employee;
	     id | name  | salary | departmentid
	    ----+-------+--------+--------------
	      1 | Joe   |  70000 |            1
	      2 | Jim   |  90000 |            1
	      3 | Henry |  80000 |            2
	      4 | Sam   |  60000 |            2
	      5 | Max   |  90000 |            1
	    (5 строк)
	postgres=# SELECT * FROM Department;
	     id | name
	    ----+-------
	      1 | IT
	      2 | Sales
	    (2 строки)
	postgres=# SELECT MAX(salary), departmentid FROM Employee GROUP BY departmentid;
	      max  | departmentid
	    -------+--------------
	     80000 |            2
	     90000 |            1
	    (2 строки)
	postgres=# SELECT d.name, m.max_salary
	FROM Department AS d
	JOIN (SELECT MAX(salary) AS max_salary, departmentid FROM Employee GROUP BY departmentid) AS m
	ON d.id=m.departmentid;
	     name  | max_salary
	    -------+------------
	     IT    |      90000
	     Sales |      80000
	    (2 строки)
	postgres=# SELECT d.name, e.name, m.max_salary
	postgres-# FROM Department AS d
	postgres-# JOIN (SELECT MAX(salary) AS max_salary, departmentid FROM Employee GROUP BY departmentid) AS m
	postgres-# ON d.id=m.departmentid
	postgres-# JOIN Employee AS e
	postgres-# ON e.salary=m.max_salary;
	     name  | name  | max_salary
	    -------+-------+------------
	     Sales | Henry |      80000
	     IT    | Jim   |      90000
	     IT    | Max   |      90000
	    (3 строки)
	postgres=# SELECT d.name AS Department, e.name AS Employee, m.max_salary AS Salary
	postgres-# FROM Department AS d
	IN (Spostgres-# JOIN (SELECT MAX(salary) AS max_salary, departmentid FROM EmploROUP BY departmentid) AS m
	postgres-# ON d.id=m.departmentid
	postgres-# JOIN Employee AS e
	postgres-# ON e.salary=m.max_salary;
	     department | employee | salary
	    ------------+----------+--------
	     Sales      | Henry    |  80000
	     IT         | Jim      |  90000
	     IT         | Max      |  90000
	    (3 строки)
	postgres=# SELECT d.name AS Department, e.name AS Employee, m.max_salary AS Salary
	postgres-# FROM Department AS d
	postgres-# JOIN (SELECT MAX(salary) AS max_salary, departmentid FROM Employee GROUP BY departmentid) AS m
	postgres-# ON d.id=m.departmentid
	postgres-# JOIN Employee AS e
	postgres-# ON e.salary=m.max_salary AND e.departmentid=m.departmentid;
	     department | employee | salary
	    ------------+----------+--------
	     IT         | Max      |  90000
	     IT         | Jim      |  90000
	     Sales      | Henry    |  80000
	    (3 строки)
	Decision:
	https://github.com/David138it/MyPortfolio/tree/main/TaskDecision/Engineer-Isu/Sql/
	Source:
	1. https://www.asozykin.ru/?ysclid=lk9eaatbqj18673257

База данных "Online School"
	Task:
	Вставить данные в таблицу
	Decision:
	testbd=> CREATE TABLE superheroes(       
	id SERIAL PRIMARY KEY,
	name VARCHAR(100),
	align VARCHAR(30),
	eye VARCHAR(30),
	hair VARCHAR(30),
	gender VARCHAR(30),
	appearances INT,
	year INT,
	universe VARCHAR(10)
	);
	    CREATE TABLE
	testbd=> SELECT * FROM superheroes;
	     id | name | align | eye | hair | gender | appearances | year | universe
	    ----+------+-------+-----+------+--------+-------------+------+----------
	    (0 rows)
	testbd=> INSERT INTO superheroes(name, appearances, universe)
	testbd-> VALUES ('Spider-Man', 4043,'marvel');
	    INSERT 0 1
	testbd=> SELECT * FROM superheroes;
	     id |    name    | align | eye | hair | gender | appearances | year | universe
	    ----+------------+-------+-----+------+--------+-------------+------+----------
	      1 | Spider-Man |       |     |      |        |        4043 |      | marvel
	    (1 row)
	testbd=> INSERT INTO superheroes(name, align, eye, hair,   
	testbd(> gender, appearances, year, universe)
	testbd-> VALUES ('Spider-Man (Peter Parker)', 'Good
	testbd'> Characters', 'Hazel Eyes', 'Brown Hair',
	testbd(> 'Male Characters', 4043, 1962, 'marvel');
	    INSERT 0 1
	testbd=> SELECT * FROM superheroes;
	     id |           name            |   align    |    eye     |    hair    |     gender      | appearances | year | universe
	    ----+---------------------------+------------+------------+------------+-----------------+-------------+------+----------
	      1 | Spider-Man                |            |            |            |                 |        4043 |      | marvel
	      2 | Spider-Man (Peter Parker) | Good      +| Hazel Eyes | Brown Hair | Male Characters |        4043 | 1962 | marvel
	        |                           | Characters |            |            |                 |             |      |
	    (2 rows)
	testbd=> INSERT INTO superheroes(id, name, align, eye, hair,   
	gender, appearances, year, universe)
	VALUES (5, 'Spider-Man (Peter Parker)', 'Good
	Characters', 'Hazel Eyes', 'Brown Hair',
	'Male Characters', 4043, 1962, 'marvel');
	    INSERT 0 1
	testbd=> SELECT * FROM superheroes;
	     id |           name            |   align    |    eye     |    hair    |     gender      | appearances | year | universe
	    ----+---------------------------+------------+------------+------------+-----------------+-------------+------+----------
	      1 | Spider-Man                |            |            |            |                 |        4043 |      | marvel
	      2 | Spider-Man (Peter Parker) | Good      +| Hazel Eyes | Brown Hair | Male Characters |        4043 | 1962 | marvel
	        |                           | Characters |            |            |                 |             |      |
	      3 | Spider-Man (Peter Parker) | Good      +| Hazel Eyes | Brown Hair | Male Characters |        4043 | 1962 | marvel
	        |                           | Characters |            |            |                 |             |      |
	      5 | Spider-Man (Peter Parker) | Good      +| Hazel Eyes | Brown Hair | Male Characters |        4043 | 1962 | marvel
	        |                           | Characters |            |            |                 |             |      |
	    (4 rows)
	Task:
	Изменить данные в таблице
	Decision:
	testbd=> UPDATE superheroes
	SET name='Batman',
	universe='dc'
	WHERE id=1;
	UPDATE 1
	testbd=> SELECT * FROM superheroes;
	     id |  name  |   align    |    eye     |    hair    |     gender      | appearances | year | universe
	    ----+--------+------------+------------+------------+-----------------+-------------+------+----------
	      1 | Batman | Good      +| Hazel Eyes | Brown Hair | Male Characters |        4043 | 1962 | dc
	        |        | Characters |            |            |                 |             |      |
	    (1 row)
	testbd=> UPDATE superheroes
	SET gender='Man'
	WHERE gender='Male Characters';
	UPDATE 1
	testbd=> SELECT * FROM superheroes;
	     id |  name  |   align    |    eye     |    hair    | gender | appearances | year | universe
	    ----+--------+------------+------------+------------+--------+-------------+------+----------
	      1 | Batman | Good      +| Hazel Eyes | Brown Hair | Man    |        4043 | 1962 | dc
	        |        | Characters |            |            |        |             |      |
	    (1 row)
	Task:
	Удалить данные из таблицы
	Decision:
	testbd=> INSERT INTO superheroes(id, name, align, eye, hair,   
	gender, appearances, year, universe)
	VALUES (2, 'Spider-Man (Peter Parker)', 'Good
	Characters', 'Hazel Eyes', 'Brown Hair',
	'Male Characters', 4043, 1962, 'marvel');
	INSERT 0 1
	testbd=> SELECT * FROM superheroes;
	     id |           name            |   align    |    eye     |    hair    |     gender      | appearances | year | universe
	    ----+---------------------------+------------+------------+------------+-----------------+-------------+------+----------
	      1 | Batman                    | Good      +| Hazel Eyes | Brown Hair | Man             |        4043 | 1962 | dc
	        |                           | Characters |            |            |                 |             |      |
	      2 | Spider-Man (Peter Parker) | Good      +| Hazel Eyes | Brown Hair | Male Characters |        4043 | 1962 | marvel
	        |                           | Characters |            |            |                 |             |      |
	    (2 rows)
	testbd=> DELETE FROM superheroes
	WHERE id=2;
	DELETE 1
	testbd=> SELECT * FROM superheroes;
	     id |  name  |   align    |    eye     |    hair    | gender | appearances | year | universe
	    ----+--------+------------+------------+------------+--------+-------------+------+----------
	      1 | Batman | Good      +| Hazel Eyes | Brown Hair | Man    |        4043 | 1962 | dc
	        |        | Characters |            |            |        |             |      |
	    (1 row)
	testbd=> INSERT INTO superheroes(id, name, align, eye, hair,   
	gender, appearances, year, universe)
	VALUES (2, 'Spider-Man (Peter Parker)', 'Good
	Characters', 'Hazel Eyes', 'Brown Hair',
	'Male Characters', 4043, 1962, 'marvel');
	    INSERT 0 1
	testbd=> DELETE FROM superheroes
	WHERE gender='Male Characters';
	DELETE 1
	testbd=> SELECT * FROM superheroes;
	     id |  name  |   align    |    eye     |    hair    | gender | appearances | year | universe
	    ----+--------+------------+------------+------------+--------+-------------+------+----------
	      1 | Batman | Good      +| Hazel Eyes | Brown Hair | Man    |        4043 | 1962 | dc
	        |        | Characters |            |            |        | &
	Task:
	Удалить все данные
	Decision:
	testbd=> DELETE FROM superheroes;
	    DELETE 1
	testbd=> SELECT * FROM superheroes;
	     id | name | align | eye | hair | gender | appearances | year | universe
	    ----+------+-------+-----+------+--------+-------------+------+----------
	    (0 rows)
	Task:
	Удаление дубликатов email
	Decision:
	Table: Person
	+-------------+---------+
	| Column Name | Type    |
	+-------------+---------+
	| id          | int     |
	| email       | varchar |
	+-------------+---------+
	Task:
	Напишите SQL-запрос, чтобы удалить все дубликаты электронных писем, сохранив только одно уникальное электронное письмо с наименьшим идентификатором.
	Верните таблицу результатов в любом порядке.
	Decision:
	postgres=# CREATE TABLE person(
	postgres(#     id INT,
	postgres(#     email VARCHAR
	postgres(# );
	INSERT INTO person(id, email) VALUES (1, 'john@example.com');
	INSERT INTO person(id, email) VALUES (2, 'bob@example.com');
	INSERT INTO person(id, email) VALUES (3, 'john@example.com');
	    CREATE TABLE
	postgres=# INSERT INTO person(id, email) VALUES (1, 'john@example.com');
	postgres=# INSERT INTO person(id, email) VALUES (2, 'bob@example.com');
	postgres=# INSERT INTO person(id, email) VALUES (3, 'john@example.com');
	postgres=# INSERT INTO person(id, email) VALUES (1, 'john@example.com');
	    INSERT 0 1
	postgres=# INSERT INTO person(id, email) VALUES (2, 'bob@example.com');
	    INSERT 0 1
	postgres=# INSERT INTO person(id, email) VALUES (3, 'john@example.com');
	    INSERT 0 1
	postgres=# SELECT * FROM Person;
	     id |      email
	    ----+------------------
	      1 | john@example.com
	      2 | bob@example.com
	      3 | john@example.com
	    (3 строки)
	postgres=# SELECT MIN(id), email FROM person GROUP BY email;
	     min |      email
	    -----+------------------
	       2 | bob@example.com
	       1 | john@example.com
	    (2 строки)
	postgres=# SELECT MIN(id) FROM person GROUP BY email;
	    min
	    -----
	       2
	       1
	    (2 строки)
	postgres=# DELETE FROM person WHERE id NOT IN (SELECT MIN(id) FROM person GROUP BY email);
	    DELETE 1
	Task:
	Группировка
	Decision:
	testbd=> SELECT * FROM superheroes;
	     id | name | align | eye | hair | gender | appearances | year | universe
	    ----+------+-------+-----+------+--------+-------------+------+----------
	    (0 rows)
	testbd=> INSERT INTO superheroes(id, name, align, eye, hair,   
	gender, appearances, year, universe)
	VALUES (2, 'Spider-Man (Peter Parker)', 'Good
	Characters', 'Hazel Eyes', 'Brown Hair',
	'Male Characters', 4043, 1962, 'marvel');
	    INSERT 0 1
	testbd=> SELECT gender, COUNT(*) FROM superheroes
	testbd-> GROUP BY gender;
	         gender      | count
	    -----------------+-------
	     Male Characters |     1
	    (1 row)
	testbd=> SELECT * FROM superheroes;
	     id |           name            |   align    |    eye     |    hair    |     gender      | appearances | year | universe
	    ----+---------------------------+------------+------------+------------+-----------------+-------------+------+----------
	      2 | Spider-Man (Peter Parker) | Good      +| Hazel Eyes | Brown Hair | Male Characters |        4043 | 1962 | marvel
	        |                           | Characters |            |            |                 |             |      |
	    (1 row)
	testbd=> SELECT align, COUNT(*) FROM superheroes
	testbd-> GROUP BY align;
	       align    | count
	    ------------+-------
	     Good      +|     1
	     Characters |
	    (1 row)
	Task:
	Многоуровневая группировка данных
	Decision:
	estbd=> SELECT universe, align, COUNT(*) FROM superheroes
	GROUP BY universe, align;
	     universe |   align    | count
	    ----------+------------+-------
	     marvel   | Good      +|     1
	              | Characters |
	    (1 row)
	Task:
	Фильтрация, группировка, сортировка и лимит
	Decision:
	testbd=> SELECT hair, COUNT(*) FROM superheroes
	WHERE gender='Male Characters'
	GROUP BY hair;
	        hair    | count
	    ------------+-------
	     Brown Hair |     1
	    (1 row)
	Decision:
	testbd=> SELECT hair, COUNT(*) FROM superheroes
	WHERE gender='Male Characters'
	GROUP BY hair
	ORDER BY count(*) DESC;
	        hair    | count
	    ------------+-------
	     Brown Hair |     1
	    (1 row)
	Decision:
	testbd=> SELECT hair, COUNT(*) FROM superheroes
	WHERE gender='Male Characters'
	GROUP BY hair
	ORDER BY count(*) DESC
	LIMIT 5;
	        hair    | count
	    ------------+-------
	     Brown Hair |     1
	    (1 row)
	Task:
	Использование агрегатных функций
	Decision:
	testbd=> SELECT * FROM superheroes;
	      id  |                                 name                                  |       align        |       eye       |         hair          |         gender         | appearances | year | universe
	    ------+-----------------------------------------------------------------------+--------------------+-----------------+-----------------------+------------------------+-------------+------+----------
	        1 | Spider-Man (Peter Parker)                                             | Good Characters    | Hazel Eyes      | Brown Hair            | Male Characters        |        4043 | 1962 | marvel
	        2 | Captain America (Steven Rogers)                                       | Good Characters    | Blue Eyes       | White Hair            | Male Characters        |        3360 | 1941 | marvel
	        3 | Wolverine (James \"Logan\" Howlett)                                   | Neutral Characters | Blue Eyes       | Black Hair            | Male Characters        |        3061 | 1974 | marvel
	        4 | Iron Man (Anthony \"Tony\" Stark)                                     | Good Characters    | Blue Eyes       | Black Hair            | Male Characters        |        2961 | 1963 | marvel
	        5 | Thor (Thor Odinson)                                                   | Good Characters    | Blue Eyes       | Blond Hair            | Male Characters        |        2258 | 1950 | marvel
	        6 | Benjamin Grimm (Earth-616)                                            | Good Characters    | Blue Eyes       | No Hair               | Male Characters        |        2255 | 1961 | marvel
	        7 | Reed Richards (Earth-616)                                             | Good Characters    | Brown Eyes      | Brown Hair            | Male Characters        |        2072 | 1961 | marvel
	        8 | Hulk (Robert Bruce Banner)                                            | Good Characters    | Brown Eyes      | Brown Hair            | Male Characters        |        2017 | 1962 | marvel
	        9 | Scott Summers (Earth-616)                                             | Neutral Characters | Brown Eyes      | Brown Hair            | Male Characters        |        1955 | 1963 | marvel
	       10 | Jonathan Storm (Earth-616)                                            | Good Characters    | Blue Eyes       | Blond Hair            | Male Characters        |        1934 | 1961 | marvel
	       11 | Henry McCoy (Earth-616)                                               | Good Characters    | Blue Eyes       | Blue Hair             | Male Characters        |        1825 | 1963 | marvel
	       12 | Susan Storm (Earth-616)                                               | Good Characters    | Blue Eyes       | Blond Hair            | Female Characters      |        1713 | 1961 | marvel
	       13 | Ororo Munroe (Earth-616)                                              | Good Characters    | Blue Eyes       | White Hair            | Female Characters      |        1512 | 1975 | marvel
	       14 | Clinton Barton (Earth-616)                                            | Good Characters    | Blue Eyes       | Blond Hair            | Male Characters        |        1394 | 1964 | marvel
	       15 | Matthew Murdock (Earth-616)                                           | Good Characters    | Blue Eyes       | Red Hair              | Male Characters        |        1338 | 1964 | marvel
	testbd=> SELECT align, COUNT(*), SUM(appearances)
	testbd-> FROM superheroes
	testbd-> GROUP BY align;
	           align        | count |  sum   
	    --------------------+-------+--------
	     Bad Characters     |   489 |  29478
	     Good Characters    |   773 | 125961
	     Neutral Characters |   249 |  30513
	    (3 rows)
	Task:
	Выражения с агрегатными функциями
	Decision:
	testbd=> SELECT align, AVG(appearances),
	testbd-> SUM(appearances)/COUNT(*) AS average
	testbd-> FROM superheroes
	testbd-> GROUP BY align;
	           align        |         avg          | average
	    --------------------+----------------------+---------
	     Bad Characters     |  60.2822085889570552 |      60
	     Good Characters    | 162.9508408796895213 |     162
	     Neutral Characters | 122.5421686746987952 |     122
	    (3 rows)
	Task:
	Использование агрегатных функций
	Decision:
	testbd=> SELECT year, MIN(appearances), MAX(appearances)
	testbd-> FROM superheroes
	testbd-> GROUP BY year;
	     year | min | max  
	    ------+-----+------
	     1964 |  20 | 1394
	     1969 |  17 |  558
	     2008 |  19 |  200
	     1989 |  19 |  408
	     1991 |  18 |  500
	     1945 |  81 |   81
	     1974 |  18 | 3061
	     1943 |  34 |  140
	     1971 |  17 |  368
	     1977 |  17 |  471
	     1956 |  25 |  114
	     1940 |  17 |  373
	     1983 |  18 |  245
	     1984 |  18 |  348
	     2009 |  18 |   98
	     1958 |  25 |   25
	     2005 |  18 |  325
	     1973 |  17 |  323
	     2013 |  18 |   53
	     2003 |  18 |  238
	     1993 |  18 |  147
	     1990 |  18 |  636
	     1953 |  37 |  141
	     2002 |  20 |  171
	     1979 |  18 |  525
	     1997 |  18 |   97
	     2004 |  18 |  265
	     1980 |  19 |  886
	     1986 |  18 |  612
	     1970 |  20 |  787
	     1975 |  17 | 1512
	     1982 |  17 |  657
	testbd=> SELECT year, MIN(appearances), MAX(appearances)
	testbd-> FROM superheroes
	testbd-> GROUP BY year
	testbd-> ORDER BY year;
	     year | min | max  
	    ------+-----+------
	     1939 |  18 |  548
	     1940 |  17 |  373
	     1941 |  17 | 3360
	     1942 |  19 |   28
	     1943 |  34 |  140
	     1944 |  30 |  550
	     1945 |  81 |   81
	     1946 |  99 |   99
	     1947 | 139 |  139
	     1948 |  17 |  106
	     1949 |  26 |  532
	     1950 |  70 | 2258
	     1951 |  18 |  223
	     1953 |  37 |  141
	     1954 |  19 |   72
	     1955 |  44 |   65
	     1956 |  25 |  114
	     1958 |  25 |   25
	     1960 |  26 |  237
	     1961 |  21 | 2255
	     1962 |  21 | 4043
	     1963 |  20 | 2961
	     1964 |  20 | 1394
	     1965 |  17 | 1304
	     1966 |  17 |  696
	     1967 |  17 |  752
	     1968 |  17 | 1007
	     1969 |  17 |  558
	     1970 |  20 |  787
	     1971 |  17 |  368
	     1972 |  19 |  856
	     1973 |  17 |  323
	testbd=> SELECT year, MIN(appearances), MAX(appearances)
	testbd-> FROM superheroes
	testbd-> GROUP BY year
	testbd-> ORDER BY MAX(appearances) DESC;
	     year | min | max  
	    ------+-----+------
	     1962 |  21 | 4043
	     1941 |  17 | 3360
	     1974 |  18 | 3061
	     1963 |  20 | 2961
	     1950 |  70 | 2258
	testbd=> SELECT year, MIN(appearances),
	testbd-> MAX(appearances) AS max_ap
	testbd-> FROM superheroes
	testbd-> GROUP BY year
	testbd-> ORDER BY max_ap DESC;
	     year | min | max_ap
	    ------+-----+--------
	     1962 |  21 |   4043
	     1941 |  17 |   3360
	     1974 |  18 |   3061
	     1963 |  20 |   2961
	     1950 |  70 |   2258
	testbd=> SELECT year, MIN(appearances),
	testbd-> MAX(appearances) AS max_ap
	testbd-> FROM superheroes
	testbd-> GROUP BY year
	testbd-> ORDER BY max_ap DESC
	testbd-> LIMIT 5;
	     year | min | max_ap
	    ------+-----+--------
	     1962 |  21 |   4043
	     1941 |  17 |   3360
	     1974 |  18 |   3061
	     1963 |  20 |   2961
	     1950 |  70 |   2258
	    (5 rows)
	Task:
	Агрегатные функции без группировки
	Decision:
	testbd=> SELECT COUNT(*),
	testbd-> MIN(appearances),
	testbd-> MAX(appearances),
	testbd-> SUM(appearances),
	testbd-> AVG(appearances)
	testbd-> FROM superheroes;
	     count | min | max  |  sum   |         avg          
	    -------+-----+------+--------+----------------------
	      1511 |  17 | 4043 | 185952 | 123.0655195234943746
	    (1 row)
	Task:
	Группировка данных
	Decision:
	testbd=> SELECT hair, COUNT(*) FROM superheroes
	WHERE gender='Female Characters'
	GROUP BY hair;
	             hair          | count
	    -----------------------+-------
	     Strawberry Blond Hair |    11
	     Bald                  |     2
	     Green Hair            |     9
	     Silver Hair           |     5
	     Red Hair              |    40
	Task:
	Фильтрация групповых результатов
	Decision:
	testbd=> SELECT hair, COUNT(*) FROM superheroes
	testbd-> WHERE gender='Female Characters'
	testbd-> AND COUNT(*) > 10
	testbd-> GROUP BY hair;
	    ERROR:  aggregate functions are not allowed in WHERE
	    LINE 3: AND COUNT(*) > 10
	                ^
	testbd=> SELECT hair, COUNT(*) FROM superheroes
	testbd-> WHERE gender='Female Characters'
	testbd-> GROUP BY hair
	testbd-> HAVING COUNT(*) > 10;
	             hair          | count
	    -----------------------+-------
	     Strawberry Blond Hair |    11
	     Red Hair              |    40
	     White Hair            |    15
	     Black Hair            |   176
	     Blond Hair            |   110
	testbd=> SELECT hair, COUNT(*) FROM superheroes
	WHERE gender='Female Characters'
	GROUP BY hair
	HAVING COUNT(*) BETWEEN 50 AND 300;
	        hair    | count
	    ------------+-------
	     Black Hair |   176
	     Blond Hair |   110
	     Brown Hair |    63
	    (3 rows)
	Task:
	Запрос данных из нескольких таблиц
	Decision:
	testbd=> SELECT * FROM products;
	     id |                             name                              | type_id | price
	    ----+---------------------------------------------------------------+---------+-------
	      1 | Основы искусственного интеллекта                              |       1 | 15000
	      2 | Технологии обработки больших данных                           |       1 | 50000
	      3 | Программирование глубоких нейронных сетей                     |       1 | 30000
	      4 | Нейронные сети для анализа текстов                            |       1 | 50000
	      5 | Нейронные сети для анализа изображений                        |       1 | 50000
	      6 | Инженерия искусственного интеллекта                           |       1 | 60000
	      7 | Как стать DataScientist'ом                                    |       2 |     0
	      8 | Планирование карьеры в DataScience                            |       2 |  2000
	      9 | Области применения нейросетей: в какой развивать экспертность |       2 |  4000
	     10 | Программирование глубоких нейронных сетей на Python           |       3 |  1000
	     11 | Математика для DataScience                                    |       3 |  2000
	     12 | Основы визуализации данных                                    |       3 |   500
	     13 | Анализ временных рядов                                        |         | 30000
	    (13 rows)
	testbd=> SELECT * FROM product_types;
	     id |  type_name   
	    ----+--------------
	      1 | Онлайн-курс
	      2 | Вебинар
	      3 | Книга
	      4 | Консультация
	    (4 rows)
	Task:
	Объединение данных из нескольких таблиц в SELECT
	Decision:
	testbd=> SELECT products.name, product_types.type_name
	testbd-> FROM products JOIN product_types
	testbd-> ON products.type_id = product_types.id;
	                                 name                              |  type_name  
	    ---------------------------------------------------------------+-------------
	     Основы искусственного интеллекта                              | Онлайн-курс
	     Технологии обработки больших данных                           | Онлайн-курс
	     Программирование глубоких нейронных сетей                     | Онлайн-курс
	     Нейронные сети для анализа текстов                            | Онлайн-курс
	     Нейронные сети для анализа изображений                        | Онлайн-курс
	     Инженерия искусственного интеллекта                           | Онлайн-курс
	     Как стать DataScientist'ом                                    | Вебинар
	     Планирование карьеры в DataScience                            | Вебинар
	     Области применения нейросетей: в какой развивать экспертность | Вебинар
	     Программирование глубоких нейронных сетей на Python           | Книга
	     Математика для DataScience                                    | Книга
	     Основы визуализации данных                                    | Книга
	    (12 rows)
	Task:
	Псевдонимы таблиц
	Decision:
	testbd=> SELECT p.name, t.type_name
	testbd-> FROM products AS p JOIN product_types AS t
	testbd-> ON p.type_id = t.id;
	                                 name                              |  type_name  
	    ---------------------------------------------------------------+-------------
	     Основы искусственного интеллекта                              | Онлайн-курс
	     Технологии обработки больших данных                           | Онлайн-курс
	     Программирование глубоких нейронных сетей                     | Онлайн-курс
	     Нейронные сети для анализа текстов                            | Онлайн-курс
	     Нейронные сети для анализа изображений                        | Онлайн-курс
	     Инженерия искусственного интеллекта                           | Онлайн-курс
	     Как стать DataScientist'ом                                    | Вебинар
	     Планирование карьеры в DataScience                            | Вебинар
	     Области применения нейросетей: в какой развивать экспертность | Вебинар
	     Программирование глубоких нейронных сетей на Python           | Книга
	     Математика для DataScience                                    | Книга
	     Основы визуализации данных                                    | Книга
	    (12 rows)
	Task:
	Псевдонимы таблиц и столбцов
	Decision:
	testbd=> SELECT p.name AS product_name,
	testbd-> t.type_name AS product_type,
	testbd-> p.price AS product_price
	testbd-> FROM products AS p JOIN product_types AS t
	testbd-> ON p.type_id = t.id;
	                             product_name                          | product_type | product_price
	    ---------------------------------------------------------------+--------------+---------------
	     Основы искусственного интеллекта                              | Онлайн-курс  |         15000
	     Технологии обработки больших данных                           | Онлайн-курс  |         50000
	     Программирование глубоких нейронных сетей                     | Онлайн-курс  |         30000
	     Нейронные сети для анализа текстов                            | Онлайн-курс  |         50000
	     Нейронные сети для анализа изображений                        | Онлайн-курс  |         50000
	     Инженерия искусственного интеллекта                           | Онлайн-курс  |         60000
	     Как стать DataScientist'ом                                    | Вебинар      |             0
	     Планирование карьеры в DataScience                            | Вебинар      |          2000
	     Области применения нейросетей: в какой развивать экспертность | Вебинар      |          4000
	     Программирование глубоких нейронных сетей на Python           | Книга        |          1000
	     Математика для DataScience                                    | Книга        |          2000
	     Основы визуализации данных                                    | Книга        |           500
	    (12 rows)
	Task:
	Фильтрация данных из нескольких таблиц
	Decision:
	testbd=> SELECT p.name AS product_name,
	testbd-> t.type_name AS product_type,
	testbd-> p.price AS product_price
	testbd-> FROM products AS p JOIN product_types AS t
	testbd-> ON p.type_id = t.id
	testbd-> WHERE t.type_name='Онлайн-курс';
	                   product_name                | product_type | product_price
	    -------------------------------------------+--------------+---------------
	     Основы искусственного интеллекта          | Онлайн-курс  |         15000
	     Технологии обработки больших данных       | Онлайн-курс  |         50000
	     Программирование глубоких нейронных сетей | Онлайн-курс  |         30000
	     Нейронные сети для анализа текстов        | Онлайн-курс  |         50000
	     Нейронные сети для анализа изображений    | Онлайн-курс  |         50000
	     Инженерия искусственного интеллекта       | Онлайн-курс  |         60000
	    (6 rows)
	testbd=> SELECT p.name AS product_name,
	testbd-> t.type_name AS product_type,
	testbd-> p.price AS product_price
	testbd-> FROM products AS p JOIN product_types AS t
	testbd-> ON p.type_id = t.id
	testbd-> WHERE t.type_name = 'Вебинар'
	testbd-> AND p.price = 0;
	            product_name        | product_type | product_price
	    ----------------------------+--------------+---------------
	     Как стать DataScientist'ом | Вебинар      |             0
	    (1 row)
	Task:
	Сортировка данных из нескольких таблиц
	Decision:
	testbd=> SELECT p.name AS product_name,
	testbd-> t.type_name AS product_type,
	testbd-> p.price AS product_price
	testbd-> FROM products AS p JOIN product_types AS t
	testbd-> ON p.type_id = t.id
	testbd-> WHERE t.type_name='Онлайн-курс'
	testbd-> ORDER BY p.price DESC;
	                   product_name                | product_type | product_price
	    -------------------------------------------+--------------+---------------
	     Инженерия искусственного интеллекта       | Онлайн-курс  |         60000
	     Технологии обработки больших данных       | Онлайн-курс  |         50000
	     Нейронные сети для анализа текстов        | Онлайн-курс  |         50000
	     Нейронные сети для анализа изображений    | Онлайн-курс  |         50000
	     Программирование глубоких нейронных сетей | Онлайн-курс  |         30000
	     Основы искусственного интеллекта          | Онлайн-курс  |         15000
	    (6 rows)
	Task:
	Типы JOIN
	Decision:
	testbd=> SELECT * FROM products;
	     id |                             name                              | type_id | price
	    ----+---------------------------------------------------------------+---------+-------
	      1 | Основы искусственного интеллекта                              |       1 | 15000
	      2 | Технологии обработки больших данных                           |       1 | 50000
	      3 | Программирование глубоких нейронных сетей                     |       1 | 30000
	      4 | Нейронные сети для анализа текстов                            |       1 | 50000
	      5 | Нейронные сети для анализа изображений                        |       1 | 50000
	      6 | Инженерия искусственного интеллекта                           |       1 | 60000
	      7 | Как стать DataScientist'ом                                    |       2 |     0
	      8 | Планирование карьеры в DataScience                            |       2 |  2000
	      9 | Области применения нейросетей: в какой развивать экспертность |       2 |  4000
	     10 | Программирование глубоких нейронных сетей на Python           |       3 |  1000
	     11 | Математика для DataScience                                    |       3 |  2000
	     12 | Основы визуализации данных                                    |       3 |   500
	     13 | Анализ временных рядов                                        |         | 30000
	    (13 rows)
	testbd=> SELECT * FROM product_types;
	     id |  type_name   
	    ----+--------------
	      1 | Онлайн-курс
	      2 | Вебинар
	      3 | Книга
	      4 | Консультация
	    (4 rows)
	Task:
	Объединение таблиц в запросе
	Decision:
	testbd=> SELECT products.name, product_types.type_name
	testbd-> FROM products JOIN product_types
	testbd-> ON products.type_id = product_types.id;
	                                 name                              |  type_name  
	    ---------------------------------------------------------------+-------------
	     Основы искусственного интеллекта                              | Онлайн-курс
	     Технологии обработки больших данных                           | Онлайн-курс
	     Программирование глубоких нейронных сетей                     | Онлайн-курс
	     Нейронные сети для анализа текстов                            | Онлайн-курс
	     Нейронные сети для анализа изображений                        | Онлайн-курс
	     Инженерия искусственного интеллекта                           | Онлайн-курс
	     Как стать DataScientist'ом                                    | Вебинар
	     Планирование карьеры в DataScience                            | Вебинар
	     Области применения нейросетей: в какой развивать экспертность | Вебинар
	     Программирование глубоких нейронных сетей на Python           | Книга
	     Математика для DataScience                                    | Книга
	     Основы визуализации данных                                    | Книга
	    (12 rows)
	Task:
	Внутреннее объединение
	Decision:
	testbd=> SELECT products.name, product_types.type_name
	testbd-> FROM products INNER JOIN product_types
	testbd-> ON products.type_id = product_types.id;
	                                 name                              |  type_name  
	    ---------------------------------------------------------------+-------------
	     Основы искусственного интеллекта                              | Онлайн-курс
	     Технологии обработки больших данных                           | Онлайн-курс
	     Программирование глубоких нейронных сетей                     | Онлайн-курс
	     Нейронные сети для анализа текстов                            | Онлайн-курс
	     Нейронные сети для анализа изображений                        | Онлайн-курс
	     Инженерия искусственного интеллекта                           | Онлайн-курс
	     Как стать DataScientist'ом                                    | Вебинар
	     Планирование карьеры в DataScience                            | Вебинар
	     Области применения нейросетей: в какой развивать экспертность | Вебинар
	     Программирование глубоких нейронных сетей на Python           | Книга
	     Математика для DataScience                                    | Книга
	     Основы визуализации данных                                    | Книга
	    (12 rows)
	Task:
	Левое внешнее объединение
	Decision:
	testbd=> SELECT products.name, product_types.type_name
	testbd-> FROM products LEFT OUTER JOIN product_types
	testbd-> ON products.type_id = product_types.id;
	                                 name                              |  type_name  
	    ---------------------------------------------------------------+-------------
	     Основы искусственного интеллекта                              | Онлайн-курс
	     Технологии обработки больших данных                           | Онлайн-курс
	     Программирование глубоких нейронных сетей                     | Онлайн-курс
	     Нейронные сети для анализа текстов                            | Онлайн-курс
	     Нейронные сети для анализа изображений                        | Онлайн-курс
	     Инженерия искусственного интеллекта                           | Онлайн-курс
	     Как стать DataScientist'ом                                    | Вебинар
	     Планирование карьеры в DataScience                            | Вебинар
	     Области применения нейросетей: в какой развивать экспертность | Вебинар
	     Программирование глубоких нейронных сетей на Python           | Книга
	     Математика для DataScience                                    | Книга
	     Основы визуализации данных                                    | Книга
	     Анализ временных рядов                                        |
	    (13 rows)
	Task:
	Правое внешнее объединение
	Decision:
	testbd=> SELECT products.name, product_types.type_name
	testbd-> FROM products RIGHT OUTER JOIN product_types
	testbd-> ON products.type_id = product_types.id;
	                                 name                              |  type_name   
	    ---------------------------------------------------------------+--------------
	     Основы искусственного интеллекта                              | Онлайн-курс
	     Технологии обработки больших данных                           | Онлайн-курс
	     Программирование глубоких нейронных сетей                     | Онлайн-курс
	     Нейронные сети для анализа текстов                            | Онлайн-курс
	     Нейронные сети для анализа изображений                        | Онлайн-курс
	     Инженерия искусственного интеллекта                           | Онлайн-курс
	     Как стать DataScientist'ом                                    | Вебинар
	     Планирование карьеры в DataScience                            | Вебинар
	     Области применения нейросетей: в какой развивать экспертность | Вебинар
	     Программирование глубоких нейронных сетей на Python           | Книга
	     Математика для DataScience                                    | Книга
	     Основы визуализации данных                                    | Книга
	                                                                   | Консультация
	    (13 rows)
	Task:
	Полное внешнее объединение
	Decision:
	testbd=> SELECT products.name, product_types.type_name
	testbd-> FROM products FULL OUTER JOIN product_types
	testbd-> ON products.type_id = product_types.id;
	                                 name                              |  type_name   
	    ---------------------------------------------------------------+--------------
	     Основы искусственного интеллекта                              | Онлайн-курс
	     Технологии обработки больших данных                           | Онлайн-курс
	     Программирование глубоких нейронных сетей                     | Онлайн-курс
	     Нейронные сети для анализа текстов                            | Онлайн-курс
	     Нейронные сети для анализа изображений                        | Онлайн-курс
	     Инженерия искусственного интеллекта                           | Онлайн-курс
	     Как стать DataScientist'ом                                    | Вебинар
	     Планирование карьеры в DataScience                            | Вебинар
	     Области применения нейросетей: в какой развивать экспертность | Вебинар
	     Программирование глубоких нейронных сетей на Python           | Книга
	     Математика для DataScience                                    | Книга
	     Основы визуализации данных                                    | Книга
	     Анализ временных рядов                                        |
	                                                                   | Консультация
	    (14 rows)
	Task:
	Перекрестное объединение
	Decision:
	testbd=> SELECT products.name, product_types.type_name
	testbd-> FROM products CROSS JOIN product_types;
	                                 name                              |  type_name   
	    ---------------------------------------------------------------+--------------
	     Основы искусственного интеллекта                              | Онлайн-курс
	     Технологии обработки больших данных                           | Онлайн-курс
	     Программирование глубоких нейронных сетей                     | Онлайн-курс
	     Нейронные сети для анализа текстов                            | Онлайн-курс
	     Нейронные сети для анализа изображений                        | Онлайн-курс
	     Инженерия искусственного интеллекта                           | Онлайн-курс
	     Как стать DataScientist'ом                                    | Онлайн-курс
	     Планирование карьеры в DataScience                            | Онлайн-курс
	     Области применения нейросетей: в какой развивать экспертность | Онлайн-курс
	     Программирование глубоких нейронных сетей на Python           | Онлайн-курс
	     Математика для DataScience                                    | Онлайн-курс
	     Основы визуализации данных                                    | Онлайн-курс
	     Анализ временных рядов                                        | Онлайн-курс
	     Основы искусственного интеллекта                              | Вебинар
	     Технологии обработки больших данных                           | Вебинар
	     Программирование глубоких нейронных сетей                     | Вебинар
	     Нейронные сети для анализа текстов                            | Вебинар
	     Нейронные сети для анализа изображений                        | Вебинар
	     Инженерия искусственного интеллекта                           | Вебинар
	     Как стать DataScientist'ом                                    | Вебинар
	     Планирование карьеры в DataScience                            | Вебинар
	     Области применения нейросетей: в какой развивать экспертность | Вебинар
	     Программирование глубоких нейронных сетей на Python           | Вебинар
	     Математика для DataScience                                    | Вебинар
	     Основы визуализации данных                                    | Вебинар
	     Анализ временных рядов                                        | Вебинар
	     Основы искусственного интеллекта                              | Книга
	     Технологии обработки больших данных                           | Книга
	     Программирование глубоких нейронных сетей                     | Книга
	     Нейронные сети для анализа текстов                            | Книга
	     Нейронные сети для анализа изображений                        | Книга
	     Инженерия искусственного интеллекта                           | Книга
	Task:
	Объединить две таблицы
	Decision:
	Table: Person
	+-------------+---------+
	| Column Name | Type    |
	+-------------+---------+
	| personId    | int     |
	| lastName    | varchar |
	| firstName   | varchar |
	+-------------+---------+
	Table: Address
	+-------------+---------+
	| Column Name | Type    |
	+-------------+---------+
	| addressId   | int     |
	| personId    | int     |
	| city        | varchar |
	| state       | varchar |
	+-------------+---------+
	Напишите SQL-запрос, чтобы сообщить имя, фамилию, город и состояние каждого человека в таблице Person. Если адрес идентификатора человека отсутствует в таблице адресов, вместо этого сообщите null.
	Верните таблицу результатов в любом порядке.
	Input:
	Person table:
	+----------+----------+-----------+
	| personId | lastName | firstName |
	+----------+----------+-----------+
	| 1        | Wang     | Allen     |
	| 2        | Alice    | Bob       |
	+----------+----------+-----------+
	Address table:
	+-----------+----------+---------------+------------+
	| addressId | personId | city          | state      |
	+-----------+----------+---------------+------------+
	| 1         | 2        | New York City | New York   |
	| 2         | 3        | Leetcode      | California |
	+-----------+----------+---------------+------------+
	Output:
	+-----------+----------+---------------+----------+
	| firstName | lastName | city          | state    |
	+-----------+----------+---------------+----------+
	| Allen     | Wang     | Null          | Null     |
	| Bob       | Alice    | New York City | New York |
	+-----------+----------+---------------+----------+
	Decision:
	SELECT p.FirstName, p.LastName, a.City, a.State
	FROM Person AS p LEFT OUTER JOIN Address AS a
	ON p.PersonId = a.PersonId;
	    personId    lastName    firstName
	0   1           Wang        Allen
	1   2           Alice       Bob
	    addressId   personId    city            state
	0   1           2           New York City   New York
	1   2           3           Leetcode        California
	Task:
	JOIN нескольких таблиц
	Task:
	В какие города летал Bruce Willis
	Decision:
	SELECT id FROM Passenger WHERE name = 'Bruce Willis';
	SELECT trip FROM Pass_in_trip WHERE passenger = 1 OR passenger = 31;
	SELECT town_to FROM Trip WHERE id IN (1100, 1123, 1181);
	SELECT town_to
	FROM Trip JOIN Pass_in_trip
	ON Trip.id=Pass_in_trip.trip
	JOIN Passenger
	ON Pass_in_trip.passenger=Passenger.id
	WHERE Passenger.name='Bruce Willis';
	SELECT town_to
	FROM Trip JOIN Pass_in_trip
	ON Trip.id=Pass_in_trip.trip
	JOIN Passenger
	ON Pass_in_trip.passenger=Passenger.id
	JOIN Company
	ON Trip.company=Company.id
	WHERE Passenger.name='Bruce Willis';
	Task:
	Схема базы данных
	Decision:
	testbd=> SELECT * FROM products;
	     id |                             name                              | type_id | price
	    ----+---------------------------------------------------------------+---------+-------
	      1 | Основы искусственного интеллекта                              |       1 | 15000
	      2 | Технологии обработки больших данных                           |       1 | 50000
	      3 | Программирование глубоких нейронных сетей                     |       1 | 30000
	      4 | Нейронные сети для анализа текстов                            |       1 | 50000
	      5 | Нейронные сети для анализа изображений                        |       1 | 50000
	      6 | Инженерия искусственного интеллекта                           |       1 | 60000
	      7 | Как стать DataScientist'ом                                    |       2 |     0
	      8 | Планирование карьеры в DataScience                            |       2 |  2000
	      9 | Области применения нейросетей: в какой развивать экспертность |       2 |  4000
	     10 | Программирование глубоких нейронных сетей на Python           |       3 |  1000
	     11 | Математика для DataScience                                    |       3 |  2000
	     12 | Основы визуализации данных                                    |       3 |   500
	     13 | Анализ временных рядов                                        |         | 30000
	    (13 rows)
	testbd=> SELECT * FROM product_types;
	     id |  type_name   
	    ----+--------------
	      1 | Онлайн-курс
	      2 | Вебинар
	      3 | Книга
	      4 | Консультация
	    (4 rows)
	testbd=> SELECT * FROM customers;
	     id |      name       |         email          
	    ----+-----------------+------------------------
	      1 | Иван Петров     | petrov@mail.ru
	      2 | Петр Иванов     | ivanov@gmail.com
	      3 | Тимофей Сергеев | ts@gmail.com
	      4 | Даша Корнеева   | dasha.korneeva@mail.ru
	      5 | Иван Иван       | petrov@mail.ru
	      6 | Сергей Щербаков | user156@yandex.ru
	      7 | Катя Самарина   | kate@mail.ru
	      8 | Андрей Котов    | a.kotoff@yandex.ru
	    (8 rows)
	testbd=> SELECT * FROM orders;
	     id | order_date | customer_id
	    ----+------------+-------------
	      1 | 2021-01-11 |           1
	      2 | 2021-01-15 |           3
	      3 | 2021-01-20 |           4
	      4 | 2021-01-12 |           2
	      5 | 2021-01-25 |           8
	      6 | 2021-01-30 |           1
	    (6 rows)
	testbd=> SELECT * FROM sales;
	     product_id | order_id | quantity
	    ------------+----------+----------
	              3 |        1 |        1
	              4 |        6 |        1
	             10 |        2 |        2
	             11 |        2 |        2
	              3 |        3 |        1
	              4 |        3 |        1
	              5 |        3 |        1
	              1 |        4 |        1
	              6 |        5 |        1
	    (9 rows)
	Task:
	Продукты в заказе
	Decision:
	testbd=> SELECT p.id,
	testbd-> p.name,
	testbd-> p.price,
	testbd-> s.quantity,
	testbd-> p.price * s.quantity AS total
	testbd-> FROM products AS p JOIN sales AS s
	testbd-> ON p.id = s.product_id
	testbd-> WHERE s.order_id=2;
	     id |                        name                         | price | quantity | total
	    ----+-----------------------------------------------------+-------+----------+-------
	     10 | Программирование глубоких нейронных сетей на Python |  1000 |        2 |  2000
	     11 | Математика для DataScience                          |  2000 |        2 |  4000
	    (2 rows)
	Task:
	Все покупки заказчика
	Decision:
	testbd=> SELECT p.id,
	testbd-> p.name,
	testbd-> p.price,
	testbd-> s.quantity,
	testbd-> p.price * s.quantity AS total
	testbd-> FROM products AS p JOIN sales AS s
	testbd-> ON p.id = s.product_id
	testbd-> JOIN orders AS o
	testbd-> ON o.id = s.order_id
	testbd-> WHERE o.customer_id=1;
	     id |                   name                    | price | quantity | total
	    ----+-------------------------------------------+-------+----------+-------
	      3 | Программирование глубоких нейронных сетей | 30000 |        1 | 30000
	      4 | Нейронные сети для анализа текстов        | 50000 |        1 | 50000
	    (2 rows)
	Task:
	Подзапросы
	Decision:
	postgres=# SELECT * FROM products;
	     id |                             name                              | type_id | price
	    ----+---------------------------------------------------------------+---------+-------
	      1 | Основы искусственного интеллекта                              |       1 | 15000
	      2 | Технологии обработки больших данных                           |       1 | 50000
	      3 | Программирование глубоких нейронных сетей                     |       1 | 30000
	      4 | Нейронные сети для анализа текстов                            |       1 | 50000
	      5 | Нейронные сети для анализа изображений                        |       1 | 50000
	      6 | Инженерия искусственного интеллекта                           |       1 | 60000
	      7 | Как стать DataScientist'ом                                    |       2 |     0
	      8 | Планирование карьеры в DataScience                            |       2 |  2000
	      9 | Области применения нейросетей: в какой развивать экспертность |       2 |  4000
	     10 | Программирование глубоких нейронных сетей на Python           |       3 |  1000
	     11 | Математика для DataScience                                    |       3 |  2000
	     12 | Основы визуализации данных                                    |       3 |   500
	     13 | Анализ временных рядов                                        |         | 30000
	    (13 строк)
	postgres=# SELECT id, name, price
	postgres-# FROM products
	postgres-# WHERE price = (SELECT MAX(price)
	postgres(# FROM products);
	     id |                name                 | price
	    ----+-------------------------------------+-------
	      6 | Инженерия искусственного интеллекта | 60000
	    (1 строка)
	postgres=# SELECT MAX(price) FROM products;
	      max
	    -------
	     60000
	    (1 строка)
	postgres=# SELECT id, name, price
	postgres-# FROM products
	postgres-# WHERE price = 60000;
	     id |                name                 | price
	    ----+-------------------------------------+-------
	      6 | Инженерия искусственного интеллекта | 60000
	    (1 строка)
	Task:
	Вывести информацию о самом дорогом продукте
	Decision:
	postgres=# SELECT id, name, price
	postgres-# FROM products
	postgres-# WHERE price = (SELECT MAX(price)
	postgres(# FROM products);
	     id |                name                 | price
	    ----+-------------------------------------+-------
	      6 | Инженерия искусственного интеллекта | 60000
	    (1 строка)
	Task:
	Вывести информацию о продуктах, которые были проданы хотя бы 1 раз
	Decision:
	postgres=# SELECT id, name, price
	postgres-# FROM products
	postgres-# WHERE id IN (SELECT product_id
	postgres(# FROM sales);
	     id |                        name                         | price
	    ----+-----------------------------------------------------+-------
	      1 | Основы искусственного интеллекта                    | 15000
	      3 | Программирование глубоких нейронных сетей           | 30000
	      4 | Нейронные сети для анализа текстов                  | 50000
	      5 | Нейронные сети для анализа изображений              | 50000
	      6 | Инженерия искусственного интеллекта                 | 60000
	     10 | Программирование глубоких нейронных сетей на Python |  1000
	     11 | Математика для DataScience                          |  2000
	    (7 строк)
	postgres=# SELECT * FROM sales;
	     product_id | order_id | quantity
	    ------------+----------+----------
	              3 |        1 |        1
	              4 |        6 |        1
	             10 |        2 |        2
	             11 |        2 |        2
	              3 |        3 |        1
	              4 |        3 |        1
	              5 |        3 |        1
	              1 |        4 |        1
	              6 |        5 |        1
	    (9 строк)
	postgres=# SELECT product_id FROM sales;
	     product_id
	    ------------
	              3
	              4
	             10
	             11
	              3
	              4
	              5
	              1
	              6
	    (9 строк)
	postgres=# SELECT id, name, price
	postgres-# FROM products
	postgres-# WHERE id IN (3, 4, 10, 11, 3, 4, 5, 1, 6);
	     id |                        name                         | price
	    ----+-----------------------------------------------------+-------
	      1 | Основы искусственного интеллекта                    | 15000
	      3 | Программирование глубоких нейронных сетей           | 30000
	      4 | Нейронные сети для анализа текстов                  | 50000
	      5 | Нейронные сети для анализа изображений              | 50000
	      6 | Инженерия искусственного интеллекта                 | 60000
	     10 | Программирование глубоких нейронных сетей на Python |  1000
	     11 | Математика для DataScience                          |  2000
	    (7 строк)
	Task:
	Индексы
	Decision:
	postgres=# SELECT * FROM superheroes;
	      id  |                                 name                                  |       align        |        eye         |         hair          |         gender         | appearances | year | universe
	    ------+-----------------------------------------------------------------------+--------------------+--------------------+-----------------------+------------------------+-------------+------+----------
	        1 | Spider-Man (Peter Parker)                                             | Good Characters    | Hazel Eyes         | Brown Hair            | Male Characters        |        4043 | 1962 | marvel
	        2 | Captain America (Steven Rogers)                                       | Good Characters    | Blue Eyes          | White Hair            | Male Characters        |        3360 | 1941 | marvel
	        3 | Wolverine (James \"Logan\" Howlett)                                   | Neutral Characters | Blue Eyes          | Black Hair            | Male Characters        |        3061 | 1974 | marvel
	        4 | Iron Man (Anthony \"Tony\" Stark)                                     | Good Characters    | Blue Eyes          | Black Hair            | Male Characters        |        2961 | 1963 | marvel
	        5 | Thor (Thor Odinson)                                                   | Good Characters    | Blue Eyes          | Blond Hair            | Male Characters        |        2258 | 1950 | marvel
	        6 | Benjamin Grimm (Earth-616)                                            | Good Characters    | Blue Eyes          | No Hair               | Male Characters        |        2255 | 1961 | marvel
	        7 | Reed Richards (Earth-616)                                             | Good Characters    | Brown Eyes         | Brown Hair            | Male Characters        |        2072 | 1961 | marvel
	        8 | Hulk (Robert Bruce Banner)                                            | Good Characters    | Brown Eyes         | Brown Hair            | Male Characters        |        2017 | 1962 | marvel
	        9 | Scott Summers (Earth-616)                                             | Neutral Characters | Brown Eyes         | Brown Hair            | Male Characters        |        1955 | 1963 | marvel
	       10 | Jonathan Storm (Earth-616)                                            | Good Characters    | Blue Eyes          | Blond Hair            | Male Characters        |        1934 | 1961 | marvel
	       11 | Henry McCoy (Earth-616)                                               | Good Characters    | Blue Eyes          | Blue Hair             | Male Characters        |        1825 | 1963 | marvel
	       12 | Susan Storm (Earth-616)                                               | Good Characters    | Blue Eyes          | Blond Hair            | Female Characters      |        1713 | 1961 | marvel
	       13 | Ororo Munroe (Earth-616)                                              | Good Characters    | Blue Eyes          | White Hair            | Female Characters      |        1512 | 1975 | marvel
	       14 | Clinton Barton (Earth-616)                                            | Good Characters    | Blue Eyes          | Blond Hair            | Male Characters        |        1394 | 1964 | marvel
	       15 | Matthew Murdock (Earth-616)                                           | Good Characters    | Blue Eyes          | Red Hair              | Male Characters        |        1338 | 1964 | marvel
	       16 | Stephen Strange (Earth-616)                                           | Good Characters    | Grey Eyes          | Black Hair            | Male Characters        |        1307 | 1963 | marvel
	       17 | Mary Jane Watson (Earth-616)                                          | Good Characters    | Green Eyes         | Red Hair              | Female Characters      |        1304 | 1965 | marvel
	       18 | John Jonah Jameson (Earth-616)                                        | Neutral Characters | Blue Eyes          | Black Hair            | Male Characters        |        1266 | 1963 | marvel
	       19 | Robert Drake (Earth-616)                                              | Good Characters    | Brown Eyes         | Brown Hair            | Male Characters        |        1265 | 1963 | marvel
	       20 | Henry Pym (Earth-616)                                                 | Good Characters    | Blue Eyes          | Blond Hair            | Male Characters       
	Task:
	Запрос на поиск данных
	Decision:
	postgres=# SELECT * FROM superheroes;
	postgres=# SELECT name, appearances, eye, hair
	postgres-# FROM superheroes
	postgres-# WHERE name = 'Iron Man (Anthony \"Tony\" Stark)';
	                   name                | appearances |    eye    |    hair
	    -----------------------------------+-------------+-----------+------------
	     Iron Man (Anthony \"Tony\" Stark) |        2961 | Blue Eyes | Black Hair
	    (1 строка)
	Task:
	Создание индекса
	Decision:
	postgres=# CREATE INDEX superheroes_name_idx
	postgres-# ON superheroes(name);
	    CREATE INDEX
	Task:
	Использование индекса при запросе
	Decision:
	postgres=# SELECT name, appearances, eye, hair
	postgres-# FROM superheroes
	postgres-# WHERE name = 'Iron Man (Anthony \"Tony\" Stark)';
	                   name                | appearances |    eye    |    hair
	    -----------------------------------+-------------+-----------+------------
	     Iron Man (Anthony \"Tony\" Stark) |        2961 | Blue Eyes | Black Hair
	    (1 строка)
	Task:
	Порядок сортировки данных в индексе
	Decision:
	postgres=# CREATE INDEX superheroes_appearances_idx
	postgres-# ON superheroes(appearances DESC);
	    CREATE INDEX
	Task:
	Ограничения
	Decision:
	postgres=# CREATE TABLE superheroes1(
	id INT PRIMARY KEY,
	name VARCHAR(100),
	align VARCHAR(30),
	eye VARCHAR(30),
	hair VARCHAR(30),
	gender VARCHAR(30),
	appearances INT,
	year INT,
	universe VARCHAR(10)
	);
	    CREATE TABLE
	postgres=# SELECT * FROM superheroes1;
	     id | name | align | eye | hair | gender | appearances | year | universe
	    ----+------+-------+-----+------+--------+-------------+------+----------
	    (0 строк)
	Task:
	Непустые значения
	Decision:
	postgres=# CREATE TABLE superheroes2(
	id INT PRIMARY KEY,
	name VARCHAR(100) NOT NULL,
	align VARCHAR(30),
	eye VARCHAR(30),
	hair VARCHAR(30),
	gender VARCHAR(30),
	appearances INT,
	year INT,
	universe VARCHAR(10)
	);
	    CREATE TABLE    
	postgres=# SELECT * FROM superheroes2;
	     id | name | align | eye | hair | gender | appearances | year | universe
	    ----+------+-------+-----+------+--------+-------------+------+----------
	    (0 строк)
	Task:
	Уникальные значения
	Decision:
	postgres=# CREATE TABLE superheroes3(
	postgres(# id INT PRIMARY KEY,
	postgres(# name VARCHAR(100) UNIQUE,
	postgres(# align VARCHAR(30),
	postgres(# eye VARCHAR(30),
	postgres(# hair VARCHAR(30),
	postgres(# gender VARCHAR(30),
	postgres(# appearances INT,
	postgres(# year INT,
	postgres(# universe VARCHAR(10)
	postgres(# );
	CREATE TABLE
	postgres=# SELECT * FROM superheroes3;
	     id | name | align | eye | hair | gender | appearances | year | universe
	    ----+------+-------+-----+------+--------+-------------+------+----------
	    (0 строк)
	Task:
	Уникальные непустые значения
	Decision:
	postgres=# CREATE TABLE superheroes4(
	postgres(# id INT PRIMARY KEY,
	postgres(# name VARCHAR(100) UNIQUE NOT NULL,
	postgres(# align VARCHAR(30),
	postgres(# eye VARCHAR(30),
	postgres(# hair VARCHAR(30),
	postgres(# gender VARCHAR(30),
	postgres(# appearances INT,
	postgres(# year INT,
	postgres(# universe VARCHAR(10)
	postgres(# );
	    CREATE TABLE
	postgres=# SELECT * FROM superheroes4;
	     id | name | align | eye | hair | gender | appearances | year | universe
	    ----+------+-------+-----+------+--------+-------------+------+----------
	    (0 строк)
	Task:
	Первичный ключ из нескольких полей
	Decision:
	postgres=# CREATE TABLE sales1(
	postgres(# product_id INT,
	postgres(# order_id INT,
	postgres(# quantity INT,
	postgres(# PRIMARY KEY(product_id, order_id)
	postgres(# );
	    CREATE TABLE
	postgres=# SELECT * FROM sales1;
	     product_id | order_id | quantity
	    ------------+----------+----------
	    (0 строк)
	Task:
	Первичный и внешний ключи
	Decision:
	postgres=# CREATE TABLE sales2(
	product_id INT REFERENCES products(id),
	order_id INT REFERENCES orders(id),
	quantity INT,
	PRIMARY KEY(product_id, order_id)
	);
	    CREATE TABLE
	postgres=# SELECT * FROM sales2;
	     product_id | order_id | quantity
	    ------------+----------+----------
	    (0 строк)
	Task:
	Представления с данными из нескольких таблиц
	Decision:
	postgres=# SELECT * FROM products;
	     id |                             name                              | type_id | price
	    ----+---------------------------------------------------------------+---------+-------
	      1 | Основы искусственного интеллекта                              |       1 | 15000
	      2 | Технологии обработки больших данных                           |       1 | 50000
	      3 | Программирование глубоких нейронных сетей                     |       1 | 30000
	      4 | Нейронные сети для анализа текстов                            |       1 | 50000
	      5 | Нейронные сети для анализа изображений                        |       1 | 50000
	      6 | Инженерия искусственного интеллекта                           |       1 | 60000
	      7 | Как стать DataScientist'ом                                    |       2 |     0
	      8 | Планирование карьеры в DataScience                            |       2 |  2000
	      9 | Области применения нейросетей: в какой развивать экспертность |       2 |  4000
	     13 | Анализ временных рядов                                        |         | 30000
	     10 | Программирование глубоких нейронных сетей на Python           |       3 |  1500
	     11 | Математика для DataScience                                    |       3 |  2500
	     12 | Основы визуализации данных                                    |       3 |  1000
	    (13 строк)
	postgres=# CREATE VIEW products_v
	postgres-# AS SELECT p.id AS id,
	postgres-# p.name AS product_name,
	postgres-# t.type_name AS product_type,
	postgres-# p.price AS product_price
	postgres-# FROM products AS p JOIN product_types AS t
	postgres-# ON p.type_id = t.id;
	    CREATE VIEW
	postgres=# SELECT * FROM products_v;
	     id |                         product_name                          | product_type | product_price
	    ----+---------------------------------------------------------------+--------------+---------------
	      1 | Основы искусственного интеллекта                              | Онлайн-курс  |         15000
	      2 | Технологии обработки больших данных                           | Онлайн-курс  |         50000
	      3 | Программирование глубоких нейронных сетей                     | Онлайн-курс  |         30000
	      4 | Нейронные сети для анализа текстов                            | Онлайн-курс  |         50000
	      5 | Нейронные сети для анализа изображений                        | Онлайн-курс  |         50000
	      6 | Инженерия искусственного интеллекта                           | Онлайн-курс  |         60000
	      7 | Как стать DataScientist'ом                                    | Вебинар      |             0
	      8 | Планирование карьеры в DataScience                            | Вебинар      |          2000
	      9 | Области применения нейросетей: в какой развивать экспертность | Вебинар      |          4000
	     10 | Программирование глубоких нейронных сетей на Python           | Книга        |          1500
	     11 | Математика для DataScience                                    | Книга        |          2500
	     12 | Основы визуализации данных                                    | Книга        |          1000
	    (12 строк)
	Task:
	Материализованные представления
	Decision:
	postgres=# CREATE MATERIALIZED VIEW products_v1
	AS SELECT p.id AS id,
	p.name AS product_name,
	t.type_name AS product_type,
	p.price AS product_price
	FROM products AS p JOIN product_types AS t
	ON p.type_id = t.id;
	    SELECT 12
	postgres=# SELECT * FROM products_v1;
	     id |                         product_name                          | product_type | product_price
	    ----+---------------------------------------------------------------+--------------+---------------
	      1 | Основы искусственного интеллекта                              | Онлайн-курс  |         15000
	      2 | Технологии обработки больших данных                           | Онлайн-курс  |         50000
	      3 | Программирование глубоких нейронных сетей                     | Онлайн-курс  |         30000
	      4 | Нейронные сети для анализа текстов                            | Онлайн-курс  |         50000
	      5 | Нейронные сети для анализа изображений                        | Онлайн-курс  |         50000
	      6 | Инженерия искусственного интеллекта                           | Онлайн-курс  |         60000
	      7 | Как стать DataScientist'ом                                    | Вебинар      |             0
	      8 | Планирование карьеры в DataScience                            | Вебинар      |          2000
	      9 | Области применения нейросетей: в какой развивать экспертность | Вебинар      |          4000
	     10 | Программирование глубоких нейронных сетей на Python           | Книга        |          1500
	     11 | Математика для DataScience                                    | Книга        |          2500
	     12 | Основы визуализации данных                                    | Книга        |          1000
	    (12 строк)
	Task:
	Обновление материализованных представлений
	Decision:
	postgres=# REFRESH MATERIALIZED VIEW products_v1;
	    REFRESH MATERIALIZED VIEW
	postgres=# SELECT * FROM products_v1;
	     id |                         product_name                          | product_type | product_price
	    ----+---------------------------------------------------------------+--------------+---------------
	      1 | Основы искусственного интеллекта                              | Онлайн-курс  |         15000
	      2 | Технологии обработки больших данных                           | Онлайн-курс  |         50000
	      3 | Программирование глубоких нейронных сетей                     | Онлайн-курс  |         30000
	      4 | Нейронные сети для анализа текстов                            | Онлайн-курс  |         50000
	      5 | Нейронные сети для анализа изображений                        | Онлайн-курс  |         50000
	      6 | Инженерия искусственного интеллекта                           | Онлайн-курс  |         60000
	      7 | Как стать DataScientist'ом                                    | Вебинар      |             0
	      8 | Планирование карьеры в DataScience                            | Вебинар      |          2000
	      9 | Области применения нейросетей: в какой развивать экспертность | Вебинар      |          4000
	     10 | Программирование глубоких нейронных сетей на Python           | Книга        |          1500
	     11 | Математика для DataScience                                    | Книга        |          2500
	     12 | Основы визуализации данных                                    | Книга        |          1000
	    (12 строк)
	Task:
	Удаление представлений
	Decision:
	postgres=# DROP VIEW products_v;
	    DROP VIEW
	postgres=# SELECT * FROM products_v;
	    ОШИБКА:  отношение "products_v" не существует
	    СТРОКА 1: SELECT * FROM products_v;
	                        ^
	Task:
	Удаление материализованных представлений
	Decision:
	postgres=# DROP MATERIALIZED VIEW products_v1;
	    DROP MATERIALIZED VIEW
	postgres=# SELECT * FROM products_v1;
	    ОШИБКА:  отношение "products_v1" не существует
	    СТРОКА 1: SELECT * FROM products_v1;
	Decision:
	https://github.com/David138it/MyPortfolio/tree/main/TaskDecision/Engineer-Isu/Sql/
	Source:
	1. https://www.asozykin.ru/?ysclid=lk9eaatbqj18673257
	
База данных "Практическое пособие разработчика"
	Task:
	Справочники
	Task:
	Документы
	Task:
	Регистры накопления
	Task:
	Простой отчет
	Task:
	Макеты. Редактирование макетов и форм
	Task:
	Периодические регистры сведений
	Task:
	Перечисления
	Task:
	Проведение документа по нескольким регистрам
	Task:
	Оборотные регистры накопления
	Task:
	Отчеты
	Task:
	Оптимизация проведения документа «Оказание услуги»
	Task:
	В качестве конфигурации для разработки использовать базу, полученную в результате решения тестового примера по книге Радченко М.Г.
	Необходимо доработать конфигурацию так, чтобы обеспечить расчет вознаграждения мастеру за оказанные им услуги при проведении документа «Оказание услуг». Вознаграждение высчитывается как процент от общей суммы, предоставленных по данному документу услуг (без учёта проданных товаров) и составляет:
	5%    сумма меньше 1 000 руб.
	10%    сумма от 1 000 до 5 000 руб.
	15%    сумма больше 5 000 руб.
	Требуется разработать структуру данных для хранения накопленного вознаграждения.
	Разработать отчет, позволяющий получить общие суммы вознаграждений по каждому мастеру за произвольно выбранный период.
	Пример отчета:
	Период: 01.01.2013 – 15.05.2013
	Мастер    Сумма
	Иванов Иван    1000
	Петров Пётр    1500
	Task:
	План видов характеристик
	Task:
	Анализ производительности
	Добавим в диалог кнопку, которую программа будет для каждой строки документа получать из справочника цену товара, подставлять ее в строку и пересчитывать сумму. Добавим неовую комаанду Сделать с флажком Изменяет сохраняемые данные.
	Decision:
	    конфигруатор-документы-поступление товаров-формаДокументов-командная панель-команды-добавить-имя:сделать-флажок:изменяет сохраненные данные-перетаскиваем в командную панель команду-действие-добавить-
	&НаКлиенте
	Процедура ТоварыЦенаПриИзменении(Элемент)
	    Стр=Элементы.Товары.ТекущиеДанные;
	    РасчетСтроки(Стр);
	    //Стр=Элементы.Товары.ТекущиеДанные;
	    //ПроцедурыДокументов.РассчетСтроки(Стр);
	КонецПроцедуры
	&НаКлиенте
	Процедура ТоварыКоличествоПриИзменении(Элемент)
	    Стр=Элементы.Товары.ТекущиеДанные;
	    РасчетСтроки(Стр);
	    //Стр=Элементы.Товары.Стр;
	    //ПроцедурыДокументов.РассчетСтроки(Стр);
	КонецПроцедуры
	&НаКлиенте
	Процедура РасчетСтроки(ТекСтр)
	    ТекСтр.Сумма=ТекСтр.Цена*ТекСтр.Количество;
	КонецПроцедуры
	&НаКлиенте
	Процедура ТоварыСуммаПриИзменении(Элемент)
	    Стр=Элементы.Товары.ТекущиеДанные;
	    Если Стр.Количество = 0 Тогда
	        Сообщить("Ошибка");
	    Иначе
	        Стр.Цена=Стр.Сумма/Стр.Количество;
	    КонецЕсли
	КонецПроцедуры
	&НаКлиенте
	Процедура ТоварыНоменклатураПриИзменении(Элемент)
	    Стр=Элементы.Товары.ТекущиеДанные;
	    Стр.Цена=ПолучитьЦену(Стр.Номенклатура);  
	    РасчетСтроки(Стр);
	КонецПроцедуры
	&НаСервереБезКонтекста
	Функция ПолучитьЦену(Товар)
	    //Возврат Товар.Цена;    //{{КОНСТРУКТОР_ЗАПРОСА_С_ОБРАБОТКОЙ_РЕЗУЛЬТАТА
	    // Данный фрагмент построен конструктором.
	    // При повторном использовании конструктора, внесенные вручную изменения будут утеряны!!!         
	    Запрос = Новый Запрос;
	    Запрос.Текст =
	        "ВЫБРАТЬ
	        |    Номенклатура.Цена
	        |ИЗ
	        |    Справочник.Номенклатура КАК Номенклатура
	        |ГДЕ
	        |    Номенклатура.Ссылка = &Ссылка";               
	    Запрос.УстановитьПараметр("Ссылка", Товар);            
	    РезультатЗапроса = Запрос.Выполнить();                   
	    ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();        
	    Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
	        // Вставить обработку выборки ВыборкаДетальныеЗаписи
	    КонецЦикла;                                                 
	    //}}КОНСТРУКТОР_ЗАПРОСА_С_ОБРАБОТКОЙ_РЕЗУЛЬТАТА
	КонецФункции
	&НаКлиенте
	Процедура Сделать(Команда)
	    Для каждого Стр Из Объект.Товары Цикл
	        Стр.Цена=ПолучитьЦену(Стр.Номенклатура);
	        РасчетСтроки(Стр);
	    КонецЦикла;
	КонецПроцедуры
	Task:
	Точка останова
	понять, как работает механзим получения цены и номенклатуры из справочника (в форме документы, форма докмента)
	Decision:
	установить точку останова на интересующую строку содержимого этой процедуры. В нашем случае, поставим точку в первой строке (Стр=Элементы.Товары.ТекущиеДанные;) процедуры:
	&НаКлиенте
	Процедура ТоварыНоменклатураПриИзменении(Элемент)
	    Стр=Элементы.Товары.ТекущиеДанные;
	    Стр.Цена=ПолучитьЦену(Стр.Номенклатура);  
	    РасчетСтроки(Стр);
	КонецПроцедуры
	запускаем в обычном пользовательском режиме - пробуем создать новую номенклатуру в поступлении товаров - увидим что в конфигураторе появится стреллочка - можем перемещаться по коду нажимая f11 или shift+f10
	Task:
	Сервис при программировании. Шаблоны текста
	Включить шаблоны
	Decision:
	Меню:Конфигуратор-Сервис-Параметры
	Task:
	Увидеть шаблоны
	Decision:
	Меню-сервис-Шаблоны текста
	Task:
	Выбрать шаблоны
	Decision:
	Действия-настройка шаблонов
	Task:
	Создание ролей и описание прав пользоавтелей
	Decision:
	справочник номенклатура - создадим новый элемент справочника - в документе выбрать этот товар в табличную часть - запишем документ (т.е. купим товар) - вернемся в справочник номенклатура - удалим его совсем - В результате будет битая ссылка. Это не правильно.
	    пометить на удаление товар - главное меню - все функции - стандартные - удаление помеченных объектов
	Task:
	Создадим в нашей конфигурации роль для себя - "полные права"
	Decision:
	    Конфигурация-общие-роли-Имя:ПолныеПрава-добавить-права:отметить все элементы-действия:установить все права-
	Task:
	Мы ведь собираемся создавать новые объекты, и у старых появятся со временем новые реквизиты и табличные частицы поэтому еще добавим
	Decision:
	    -флажок:устанавливать права для новых объектов-флажок:Устанавливать права для реквизитов и табличчных частей по умолчанию-
	Task:
	Для роли ПОЛНЫЕ ПРАВА, чтобы пользователь не смог удалять элемент справочника из базы без проверки ссылочной целстности базы.
	Decision:
	    -справочники,документы-снять флажок-интерактивное удаление-меню-конфигурация-обновить конфигурацию БД
	Task:
	Добавим нового пользователя
	Decision:
	    меню-администрирование-пользователи-добавить-Имя:Администратор-прочие-флажок:полные права
	Теперь можно выйти и войти под учеткой. И удалить новый товар не получится, такая функция просто исчезнет с меню "Еще"
	Task:
	Активные пользователи
	посмотреть работающих сейчас пользователей БД
	Decision:
	    меню-администрирование-активные пользователи.
	Попросить их выйти из БД можно, воспользовавшись механизмом конфигурации или службой администирования серверов, которая инсталируется в каталог программных файлов (1СV7 servers.msc) и позваляет отключать соединения с БД.
	Task:
	Журнал регистрации
	Настроим конфигуратор так, чтобы журнал велся, регистрировать некие события в нем:
	Decision:
	    меню-администрирование-настройка журнала регистрации-флажок:регистрировать ошибки, предупреждения, информацию, примечания
	Task:
	События пользователя можно посмотреть в
	Decision:
	    меню-администрирование-журнал регистрации
	Task:
	Выгрузка и загрузка БД
	Выгрузить из конфигурации. В момент выгрузки в БД не должны работать пользователи
	Decision:
	    меню-администрирование-выгрузить БД-расширение .dt
	Task:
	Загрузить в конфигурацию
	Decision:
	меню-администрирование-загрузить БД-расширение .dt
	Task:
	Конфигурация БД
	в базе сидит огромное предприятие, все работают и одному пользователю повезло залезть туда, где вы допустили ошибку. одному ему она мешает, а остальные даже о ней не догадываются. Чтобы всех с БД не выгонять, нужно:
	Decision:
	    исправить ошибку - обновить динамически- и одного попросить выйти из программы - заново войти
	Task:
	Тестирование и исправление БД
	Когда мы удалили элементы, осталась битая ссылка. Нужно это исправлять. Когда нет пользователей в БД можно выполнить тестирование и исправление БД.
	Decision:
	    меню-администрирование-тестирование и исправление-поставим везде флажки-в двух колонках отметим создавать объекты-выполнить
	Запустим конфигуратор - посмотрим, что изменилось в элементе, которую мы оставили с битой ссылкой
	Task:
	Лечение файловой БД
	Если после сбоя совсем все плохо и вас даже не пускают в конфигуратор, можно восппользоваться программой проверки физической целостности файла БД называется chdbfl.exe. он позваоляет восстановить БД
	Decision:
	    указывается расположение БД - исправлять ошибки - выполнить
	Task:
	Константы
	Решили мы продать конфигурацию предприятию, которое торгует услугами. И нет у них складов, и просят они убрать эти склады.
	Decision:
	Для того чтобы убрать надо убрать из главного окна, убрать из всех документов, из всех отчетов. Проще не убрать, а скрыть по флажку. Этот флажок и бдет храниться в константе.
	    конфигурация-добавить константу-УчетПоСкладам-тип:булево-Представление:использовать стандартные команды-конфигурацияобщие-подсистемы-сервис-состав:открыть-флаг:УчетПоСкладам
	Task:
	Функциональные опции
	В примере учет по складам мы можем установить конфигурацию разным предприятиям. Некоторые из них имеют несколько складов, и учет в разрезе складов им обяазательно нужен. Некоторые могу завести этот один склад и во всех документах его выбирать, а во всех отчетах ео видеть, но не хотят. Поэтому нужно предусмотреть режим, при котором с панели навигации должна убраться ссылка открытия справочника "Склады", а из документов поле ввода для выбора склада.
	Decision:
	    Конфигурация-общие-функциональные опции-добавить-имя:УчетПоСкладам-хранение:указывыаем нашу константу УчетПоСкладам-состав-помечаем флажками там где есть связь со складом
	Decision:
	В пользовательском интерфейсе вся информация о складах исчезнет
	Task:
	Создание механизма компоновки данных
	Добавим в нашу конфигурацию отчет, который позволит распечать список справочника "номенклатура". Мы хотим напечатать не весь справочник, а с нужной сортировкой.
	Decision:
	    Конфигурация-отчеты-добавить-имя,синонимы:ПрайсЛист-подсистемы-продажи-основные-открыть схему компоновки данных-добавить набор данных запрос-
	    -конструктор запроса-таблицы-справочники-номенклатура > - код >, изготовитель >, наименование >, цена > - ок - поле - флажок "Цена" - поменяем на "Цена продажи"
	Task:
	Группировка отчета
	Нужно описать какие в отчете будут группировки.вывести все строки, которые есть в справочнике
	Decision:
	    Конфигурация-отчеты-добавить-имя,синонимы:ПрайсЛист-подсистемы-продажи-основные-открыть схему компоновки данных-настройки-новая группировка-ок-
	Task:
	Если бы нам нужно было бы сгруппировать данные, например, по поставкам НДС и посчитать, например, количество, качество товаров с с каждой ставкой , мы бы вместо пустой добавили группировку "Ставка НДС"
	Decision:
	    -выбранные поля-код, наименование, цена-другие настройки-флаг:заголово-Прайс лист-
	Task:
	Свойства пользовательских настроек
	B отчете мы разрешим управлять пользователю.
	Decision:
	-отчет-свойства элемента пользовательских настроек-выбор поля:колонки,быстрый доступ-отбор:быстрый доступ-порядок:быстрый доступ-условное офомление:обычный-группировки-обычный
	Task:
	Соединение таблиц в запросе
	Decision:
	    Запрос - простое соединение - конструктор запроса - Справочники - Контрагенты, Организации> - Нименование(Контрагенты),ИНН(Организации))> - ок
	ВЫБРАТЬ
	    Контрагенты.Наименование КАК Наименование,
	    Организации.ИНН КАК ИНН
	ИЗ
	    Справочник.Контрагенты КАК Контрагенты,
	    Справочник.Организации КАК Организации
	Decision:
	    Запрос - Безусловное соединение - конструктор запроса - Справочники - Контрагенты> БанковскиеСчетаОрганизаций> - Наименование (Контрагенты, БанковскиеСчетаОрганизаций)> - Объединение/Псевдонимы - Имя полей - Контрагент, Банк - ок - выполнить
	ВЫБРАТЬ
	    БанковскиеСчетаОрганизаций.Наименование КАК Банк,
	    Контрагенты.Наименование КАК Контрагент
	ИЗ
	    Справочник.Контрагенты КАК Контрагенты,
	    Справочник.БанковскиеСчетаОрганизаций КАК БанковскиеСчетаОрганизаций
	Task:
	Объединение таблиц в запросе
	Получить список всех продаж и товаров в хронологиическом порядке
	Decision:
	    Добавить запрос - Объединение (продажи и товары в хронологии) - конструктор запроса - таблицы и поля - база данных - документы - заказ клиента> - номер, дата, партнер, сумма документа> - объединение/псевдонимы - запрос - добавить - Таблицы и поля - РасходныйОрдерНаТовары> - номер, дата - поля -добавить - 0 - объединение/псевдонимы - запрос2 - 0 - ок
	ВЫБРАТЬ
	    ЗаказКлиента.Номер КАК Номер,
	    ЗаказКлиента.Дата КАК Дата,
	    ЗаказКлиента.Партнер КАК Партнер,
	    ЗаказКлиента.СуммаДокумента КАК СуммаДокумента
	ИЗ
	    Документ.ЗаказКлиента КАК ЗаказКлиента
	ОБЪЕДИНИТЬ ВСЕ
	ВЫБРАТЬ
	    РасходныйОрдерНаТовары.Номер,
	    РасходныйОрдерНаТовары.Дата,
	    0,
	    0
	ИЗ
	    Документ.РасходныйОрдерНаТовары КАК РасходныйОрдерНаТовары
	    Конструктор заппроса - порядок - дата> - возрастание - ок
	ВЫБРАТЬ
	    ЗаказКлиента.Номер КАК Номер,
	    ЗаказКлиента.Дата КАК Дата,
	    ЗаказКлиента.Партнер КАК Партнер,
	    ЗаказКлиента.СуммаДокумента КАК СуммаДокумента,
	    ЗаказКлиента.Ссылка КАК Ссылка
	ИЗ
	    Документ.ЗаказКлиента КАК ЗаказКлиента
	ОБЪЕДИНИТЬ ВСЕ
	ВЫБРАТЬ
	    РасходныйОрдерНаТовары.Номер,
	    РасходныйОрдерНаТовары.Дата,
	    0,
	    0,
	    РасходныйОрдерНаТовары.Ссылка
	ИЗ
	    Документ.РасходныйОрдерНаТовары КАК РасходныйОрдерНаТовары
	УПОРЯДОЧИТЬ ПО
	    Дата
	Task:
	СКД - Разработка отчетов. Создание отчета - фиксированный макет
	Нужно создать отчет остатки товаров, который должен показывать остатки номенклатуры в разрезе в виде таблицы с группировкой по складам
	Task:
	Сначала выведем на форму элемент, который позволит нам показать результат отчета пользователю
	Decision:
	    Конфигурация - Отчеты - добавить - ОстаткиТоваров_Вариант1 - Формы - Форма отчета - открыть - добавить реквизит - ТабДок - Выбрать тип - +Табличный документ - перетаскиваем ТабДок из реквизитов в форму - Положение Заголовка - Нет - Команды - добавить - СформироватьОтчет - Представление - Выбрать картинку - СформироватьОтчет - отображение - Картинка и текст - перетаскиваем СформироватьОтчет из реквизитов в командную панель - форма - использование - положение командной панели - авто - ФормаСформироватьОтчет - основные - +КнопкаПоУмолчанию
	Task:
	Теперь нужно создать макет
	Decision:
	    Конфигурация - Отчеты - ОстаткиТоваров_Вариант1 - Макеты - Добавить - Остатки - тип макета - табличный документ - Склад, Товар, Количество остаток - Склад, Товар, КоличествоОстаток - свойства - Склад, Товар, КоличествоОстаток - макет - Заполнение - Параметр - Выделим первые три строки и макета с полями Склад, Товар, Количество остаток - Таблица - имена - назначить имя - ШапкаТаблицы - Выделим четвертую строку макета с полями Склад, Товар, КоличествоОстаток - Таблица - имена - назначить имя - СтрокаТаблицы
	Task:
	Разработать алгоритм, который позволит вывести нам результат в табличный документ и показать его на форме пользователю
	Decision:
	    Конфигурация - Отчеты - ОстаткиТоваров_Вариант1 - Подсистемы - Продажи - Конфигурация - Отчеты - ОстаткиТоваров_Вариант1 - ФормаОтчета - поле - Сформировать отчет - действия команды - Создать на клиенте и на сервере
	&НаКлиенте
	Процедура СформироватьОтчет(Команда)
	    СформироватьОтчетНаСервере();
	КонецПроцедуры
	&НаСервере
	Процедура СформироватьОтчетНаСервере()
	    ОтчетОбъект= РеквизитФормыВЗначение("Отчет");
	    ОтчетОбъект.СформироватьОтчет(ТабДок);
	КонецПроцедуры
	    Конфигурация - Отчеты - ОстаткиТоваров_Вариант1 - Открыть модуль объекта
	Процедура СформироватьОтчет(ТабДок) Экспорт   
	    //1. Прочитать данные из базы
	КонецПроцедуры
	    Конструктор запроса с обработкой результата - таблицы и поля - РегистрыНакопления - ТоварныеЗапасыОстатки> - Склад, товар, КоличествоОстаток>
	Процедура СформироватьОтчет(ТабДок) Экспорт   
	    ТабДок.Очистить();
	    //1. Прочитать данные из базы
	    Запрос = Новый Запрос;
	    Запрос.Текст =
	        "ВЫБРАТЬ
	        |   ТоварныеЗапасыОстатки.Склад КАК Склад,
	        |   ТоварныеЗапасыОстатки.Товар КАК Товар,
	        |   ТоварныеЗапасыОстатки.КоличествоОстаток КАК КоличествоОстаток
	        |ИЗ
	        |   РегистрНакопления.ТоварныеЗапасы.Остатки КАК ТоварныеЗапасыОстатки";
	    РезультатЗапроса = Запрос.Выполнить();
	    ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
	    Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
	    КонецЦикла;
	КонецПроцедуры
	...
	    РезультатЗапроса = Запрос.Выполнить();
	    Выборка = РезультатЗапроса.Выбрать();
	    //2. Вывод результата в отчет
	    Макет = ПолучитьМакет("Остатки");
	    Область=Макет.ПолучитьОбласть("ШапкаТаблицы");
	    ТабДок.Вывести(Область);
	    Пока Выборка.Следующий() Цикл
	        Область=Макет.ПолучитьОбласть("СтрокаТаблицы");
	        Область.Параметры.Заполнить(Выборка);
	        ТабДок.Вывести(Область);
	    КонецЦикла;
	...
	    Выполнить - продажи - остатки товаров вариант1 - сформировать
	Task:
	Добавить в отчете поля для выбора даты, чтоб на указанную дату рассчитывался остаток
	Decision:
	    Конфигурация - Отчеты - ОстаткиТоваров_Вариант1 - данные - добавить реквизит - ДатаОстатков - тип - дата - форма отчета - перетаскиваем ДатаОстаков из реквизита в форму - Открыть модуль объекта - конструктор запроса - таблицы и поля - таблицы - параметры вирутальной таблицы - период - &ДатаОстатков - таблицы и поля - поля - ТоварныеЗапасыОстатки Склад - изменить текущий элемент - функции языка запросов - функции - прочие запросы - ПредставлениеССылки
	ПРЕДСТАВЛЕНИЕССЫЛКИ(ТоварныеЗапасыОстатки Склад)
	    ТоварныеЗапасыОстатки Товар - изменить текущий элемент - функции языка запросов - функции - прочие запросы - ПредставлениеССылки
	ПРЕДСТАВЛЕНИЕССЫЛКИ(ТоварныеЗапасыОстатки Товар)
	Процедура СформироватьОтчет(ТабДок) Экспорт   
	    ТабДок.Очистить();
	    //1. Прочитать данные из базы
	        //{{КОНСТРУКТОР_ЗАПРОСА_С_ОБРАБОТКОЙ_РЕЗУЛЬТАТА
	    // Данный фрагмент построен конструктором.
	    // При повторном использовании конструктора, внесенные вручную изменения будут утеряны!!!
	    Запрос = Новый Запрос;
	    Запрос.Текст =
	        "ВЫБРАТЬ
	        |   ПРЕДСТАВЛЕНИЕССЫЛКИ(ТоварныеЗапасыОстатки.Склад) КАК Склад,
	        |   ПРЕДСТАВЛЕНИЕССЫЛКИ(ТоварныеЗапасыОстатки.Товар) КАК Товар,
	        |   ТоварныеЗапасыОстатки.КоличествоОстаток КАК КоличествоОстаток
	        |ИЗ
	        |   РегистрНакопления.ТоварныеЗапасы.Остатки(&ДатаОстатков, ) КАК ТоварныеЗапасыОстатки";
	    ВыбраннаяДата=?(ЗначениеЗаполнено(ДатаОстатков), КонецДня(ДатаОстатков)+1, '00010101');
	    Запрос.УстановитьПараметр("ДатаОстатков", ВыбраннаяДата);
	    РезультатЗапроса = Запрос.Выполнить();
	    Выборка = РезультатЗапроса.Выбрать();
	    //2. Вывод результата в отчет
	    Макет = ПолучитьМакет("Остатки");
	    Область=Макет.ПолучитьОбласть("ШапкаТаблицы");
	    ТабДок.Вывести(Область);
	    Пока Выборка.Следующий() Цикл
	        Область=Макет.ПолучитьОбласть("СтрокаТаблицы");
	        Область.Параметры.Заполнить(Выборка);
	        ТабДок.Вывести(Область);
	    КонецЦикла;
	КонецПроцедуры
	    Выполнить - продажи - остатки товаров вариант1 -  выбрать дату - сформировать
	Task:
	Создание отчета - Система компоновки данных (СКД)
	Нужно создать отчет, используя СКД, остатки товаров, который должен показывать остатки номенклатуры в разрезе в виде таблицы с группировкой по складам
	Decision:
	    Конфигурация - Отчеты - добавить - ОстаткиТоваров_Вариант2 - подсистемы - продажи - основные - открыть схему компоновки данных - Добавить набор данных - запрос - конструктор запроса - РегистрыНакопления - ТоварыеЗапасыОстатки> - Склад, товар, КоличествоОстаток>
	ВЫБРАТЬ
	    ТоварныеЗапасыОстатки.Склад КАК Склад,
	    ТоварныеЗапасыОстатки.Товар КАК Товар,
	    ТоварныеЗапасыОстатки.КоличествоОстаток КАК КоличествоОстаток
	ИЗ
	    РегистрНакопления.ТоварныеЗапасы.Остатки КАК ТоварныеЗапасыОстатки
	    Настройки - открыть конструктор запроса - Список - Склад, Товар, КоличествоОстаток> - выполнить - продажи - остатки товаров вариант2
	Task:
	Пользователю нужно указать период
	Decision:
	    Еще - Изменить вариант - Параметры - Период - свойства элемента пользовательских настроек - включать в пользовательские настройки - режим редактирования - быстрый доступ
	Task:
	Консоль отчетов
	Decision:
	    Конфигуратор - сервис - параметры - запуск 1с - +Толстый клиент - Выполнить - файл - открыть - управляемая консоль отчетов - добавить - схему компоновки данных - конструктор - добавить набор данных запрос - конструктор запросов - товарныеЗапросыОстатки>> - ok - Настройки - открыть конструктор запросов - количествоОстаток>> - ок - выполнить - конструктор - сохранить схему в файл
	Task:
	Ресурсы (Поля итога)
	В отчете "Остатки товаров" нужно наастроит расчет итогов по количеству
	Decision:
	    Добавить схему компоновки данных -  конструктор - добавить набор данных запрос - конструктор запроса - регистрыНакопления - товарныеЗапасыОстатки>>-ок-настройки-количествоОстаток>>- ok - выполнить - конструктор - ресурсы - количествоОстаток> - ок - выполнить
	Task:
	Поменяем структуру отчета
	Decision:
	    конструктор - настройки - добавить новую группировку - Склад - детальный записи перетаскимваем в Склад - ок - выполнить
	Task:
	Разработать отчет, который будет показывать информацию о продажах за период, период будет выбирать пользователь
	Decision:
	    Добавить схему компоновки данных - конструктор - добавить набор данных запрос - конструктор запроса - регистрыНакопление-ПродажиОбороты>-покупатель, товар, количествоОборот, суммаОборот> - ресурсы - количествоОборот, суммаОборот> - настройки - открыть конструтор запроса - список - КоличествоОборот>> - ок - выполнить - конструктор запроса - сохранить схему - конфигуратор - Отчеты - Создать - ПродажиТоваров_СКД - подсисема Продажи+ - основные - открыть схему компоновки данных - загрузитьсхему из файла - f5 - продажи - Продажи Товаров СКД - сформировать
	Task:
	Нужно сделать так, чтобы пользователь мог работать с периодом
	Decision:
	    Отчет - ПродажиТоваров_СКД - Натсройки - Начало приода, конец периода - Свойства элементов пользовательских настроек - Включать пользовательские настройки+ - параметры - добавить - Период - тип - Стандартный период+ - Начало, конец период - ограничение доступности+ -  Начало, конец период - вырожение - &Период.ДатаНачала, &Период.ДатаОкончания - Настройки - период - Свойства элементов пользовательских настроек - Включать пользовательские настройки+ -выполнить - продажи - Продажи Товаров СКД - сформировать
	Task:
	Сложные отчеты: список, таблица, диаграмма
	Разработаем отчет, который позволит получить данные оборота по купленным товарам за выбранный пользователем период и узнать количество и сумму купленных  товаров в разреезе товаров, складов, организаций и других полей приходной накладной. Создадим отчет "Отчет о закупках" и добавим новый запрос данных.
	Decision:
	   Конфигурация-отчеты-добавить-имя,синоним:ОтчетОЗакупках-подсистемы-закупки-основные-открыть схему компоновки данных-добавить набор данных:запрос-конструктор запроса БД:документы/поступление товаров/товары,Таблицы:поступлениеТоваров-переименовать-ПрихТовары:Номенклатура/количество/сумма/ссылка-
	Task:
	Отбор и параметры в запросе
	Пользователю можно добаться до даты, имея "Ссылку", или, поставив условие "Отбор", или часть отобров можно прописать явно в запросе. Для этого есть есть предложение "ГДЕ" в закладке "Условия". И тогда написанные нами отборы пользователь не сможет отключить.
	Decision:
	    -условия-прихТовары,ссылка-дата-между-Дата1-Дата2-прихТовары,ссылка-пометкаНаУдаление-флаг-выбрать-НЕ ПрихТовары.Ссылка.ПометкаУдаления-ок-Запрос-
	ВЫБРАТЬ
	    ПрихТовары.Номенклатура,
	    ПрихТовары.Количество,
	    ПрихТовары.Сумма,
	    ПрихТовары.Ссылка
	ИЗ
	    Документ.ПоступлениеТоваров.Товары КАК ПрихТовары
	ГДЕ
	    НЕ ПрихТовары.Ссылка.ПометкаУдаления
	    И ПрихТовары.Ссылка.Дата МЕЖДУ &Дата1 И &Дата2
	    -ок-поля:ссылка-флажок-(переименовать)Документ-
	Task:
	Ресурсы запроса
	Пользователь в отчете наверняка захочет увидет не только все строки всех документов, но и подвести итоги по товару, контрагенту, и другим полям, сколько всего было куплено товаров данного типа. Запрос должен просуммировать поля "количество" и "сумма".
	Decision:
	    -ресурсы-количество,сумма-количество,рассчитывать по-номенклатура-ок-сумма,рассчитывать по - количеству-ок-
	Task:
	Параметры компоновки
	Воспользуемся механизмом стандартного выбора периода, который позволяет осуществлять выбор из списка со стандартными периодами. Для этого добавим новый параметр "период".
	Decision:
	    -Параметры-Добавить-Имя:Пеиод-тип:СтандартныйПериод-
	Task:
	Вариант отчета "список"
	Настроим несколько вариантов отчета для нашего пользователя.
	Decision:
	    -Настройка-Открыть конструктор настроек-список-Номенклатура >, Количество >, Сумма > - Номенклатура > -
	Task:
	Установим период отчета по умолчанию
	Decision:
	    -Настройка-параметры-Флажок на период-Дата окончания: этот год-Другие настройки-Заголовок:Ведомость закупок-отчет-свойства элемента пользовательских настроек-Флажок:выбранные поля,отбор,порядок (обычный),условное оформление (обычный),группировка-Параметры-свойства элемента пользовательских настроек-флажок:включать в пользовательские настройки-ок-
	Task:
	Связанные поля
	Получить отчет пользователю о закупках с отбором по одной организации
	Decision:
	в свойстве отбор - найти там документ (ссылка) - найти орагнанизацию - на нее поставить отбор.
	Task:
	Но можно это сделать за пользователя, чтобы все поля, которые ему нужны будут, были видны на вернем углу списка доступных полей.
	Decision:
	    конфигурация-отчетОЗакупках-схема компоновка даных-набор данных-конструктор запроса-таблицы:организация >,контрагент >,Склад >-В наборе данных-поле-переименуем добавленные нами заголовки-флагСклад:Ссылка.Склад,Организация,Контрагент-
	Task:
	Ограничение поля
	Запретим пользователю залезать внутрь документа ссылки, т.е. убрать плюсик слева от поля "Документ", когда пользователь работает с отбором
	Decision:
	    -Ссылка документ:условие:флаг-
	Task:
	Кросс-таблица
	Теперь когда появились поля Контрагент, организация, склад сделаем отчет типа таблица. Нам нужно изменить только вкладку настройки схемы компоновки данных. Чтобы сэкономить время скопируем наш вариант  отчета
	Decision:
	    -настройки-копируем вариант отчета и переименуем: Шахматка-удаляем группировку номенклатура-добавить новую таблицу-Таблица--Строки-номенклатура-колонки-контрагент-выбранные поля-оставим только сумму-другие настройки-заголовок:Шахматка закупок-отчет-свойства элемента пользовательских настроек-везде поставим галочку кроме группировки, а в режиме редактирования поставим обычный у порядка и условного оформления- в таблице-свойства элемента пользовательских настроек-поставим галочки только в группировки строк и колонок
	Task:
	Функции языка запросов
	Сгруппируем наш отчет о закупках, который мы по умолчанию формируем за 1 год, помесячно
	Decision:
	Для этого нужно довить в текст запроса поле, которое идентифицирует месяц, к которому принадлежит дата документа.
	НАЧАЛАПЕРИОДА- функция, которая, получив от нас дату документа и название периода "месяц", сможет рассчитать дату начала месяца.
	    конфигуратор-отчет о закупках-сехма компоновки данных-конструктор запросов-поля-добавить-функция,функция работы с датами, НАЧАЛОПЕРИОДА(Тащим вниз)-(Заместо дата)поле,все поля,прихтовары,ссылка,дата(Тащим вниз)-(Заместо период)функция,функция работы с датами,Месяц(Тащим вниз)-объединения и псевдонимы-назовем:периодМесяц-ок-набор данных-ПериодМесяц-оформление-формат поля-формат-конструктор фоматной строки-дата-формат даты(флаг)-ММММ.гггг-
	Также если надо не помесячно указать в отчете, а по квартально, тогда нужно в формате данных указать  - к "кв." гггг "г."
	Task:
	Диаграмма
	Управленцам создадим графический вариант отображения данных.
	Decision:
	    конфигуратор-отчет о закупках-сехма компоновки данных-настройки-Скопироуем вариант с Шахматки и назовем его Диаграмма-Удаляем "таблица" полностью-вместо нее добавляем "Диаграмма"-точки:ПериодМесяц-Серии:номенклатура-диаграмма-свойства элемента пользовательских настроек-флажок:Группировки серий, Группировки точек-ок-другие настройки-Заголовок:диаграмма закупок
	Task:
	Внешние отчеты
	Можно с самого начала разрабатывать отчет не как новую ветку в дереве  объектов конфигурации, а используя
	Decision:
	    конфигуратор-файл-новый-внешний отчет-имя:НовыйВнешнийОтчет-файл-сохранить как-1c-Forus-NewExternalReport.erf
	Task:
	открыть для изменения этот отчет
	Decision:
	    конфигуратор-файл-открыть-1c-Forus-NewExternalReport.erf
	Task:
	Программноe выполнение запроса
	В модуле формы документа "Поступление товаров" описан механизм получения цены из элементасправочника Номенклатура. Для этого использовалась объектная модель и обращение  через точку к реквизиту выбранного элемента справочника номенклатуры.
	В функции была одна трока кода и возврат результата:
	&НаСервере
	Функция ПолучитьЦену(Товар)
	    Возврат Товар.Цена;
	КонецФункции
	Но можно сделать это и запросом, чтобы оптимизировать получение данных. Перепишем функцию так, чтобы она получала данные запросом.
	Изменим функцию получитьЦену, удалим строе ее содержимое и напишем алгоритм получения цены с сервра по новому.
	Decision:
	    пр.кн.мыши-конструторзапроса с обработкой результата-обход результата-таблицы и поля,справочники,номенклатура>цена>-Условия,поля,номенклатура,ссылка-перетаскиваем в правое поле-запрос-
	ВЫБРАТЬ
	    Номенклатура.Цена
	ИЗ
	    Справочник.Номенклатура КАК Номенклатура
	ГДЕ
	    Номенклатура.Ссылка = &Ссылка
	    -ок
	Decision:
	&НаКлиенте
	Процедура ТоварыЦенаПриИзменении(Элемент)
	    Стр=Элементы.Товары.ТекущиеДанные;
	    РасчетСтроки(Стр);
	    //Стр=Элементы.Товары.ТекущиеДанные;
	    //ПроцедурыДокументов.РассчетСтроки(Стр);
	КонецПроцедуры
	&НаКлиенте
	Процедура ТоварыКоличествоПриИзменении(Элемент)
	    Стр=Элементы.Товары.ТекущиеДанные;
	    РасчетСтроки(Стр);
	    //Стр=Элементы.Товары.Стр;
	    //ПроцедурыДокументов.РассчетСтроки(Стр);
	КонецПроцедуры
	&НаКлиенте
	Процедура РасчетСтроки(ТекСтр)
	    ТекСтр.Сумма=ТекСтр.Цена*ТекСтр.Количество;
	КонецПроцедуры
	&НаКлиенте
	Процедура ТоварыСуммаПриИзменении(Элемент)
	    Стр=Элементы.Товары.ТекущиеДанные;
	    Если Стр.Количество = 0 Тогда
	        Сообщить("Ошибка");
	    Иначе
	        Стр.Цена=Стр.Сумма/Стр.Количество;
	    КонецЕсли
	КонецПроцедуры
	&НаКлиенте
	Процедура ТоварыНоменклатураПриИзменении(Элемент)
	    Стр=Элементы.Товары.ТекущиеДанные;
	    Стр.Цена=ПолучитьЦену(Стр.Номенклатура);  
	    РасчетСтроки(Стр);
	КонецПроцедуры
	&НаСервереБезКонтекста
	Функция ПолучитьЦену(Товар)
	    //Возврат Товар.Цена;    //{{КОНСТРУКТОР_ЗАПРОСА_С_ОБРАБОТКОЙ_РЕЗУЛЬТАТА
	    // Данный фрагмент построен конструктором.
	    // При повторном использовании конструктора, внесенные вручную изменения будут утеряны!!!         
	    Запрос = Новый Запрос;
	    Запрос.Текст =
	        "ВЫБРАТЬ
	        |    Номенклатура.Цена
	        |ИЗ
	        |    Справочник.Номенклатура КАК Номенклатура
	        |ГДЕ
	        |    Номенклатура.Ссылка = &Ссылка";               
	    Запрос.УстановитьПараметр("Ссылка", Ссылка);            
	    РезультатЗапроса = Запрос.Выполнить();                   
	    ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();        
	    Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
	        // Вставить обработку выборки ВыборкаДетальныеЗаписи
	    КонецЦикла;                                                 
	    //}}КОНСТРУКТОР_ЗАПРОСА_С_ОБРАБОТКОЙ_РЕЗУЛЬТАТА
	КонецФункции
	Task:
	Способы чтения данных из базы
	прочитать какую то информацию из базы, например, товары используя метод объект
	Decision:
	Файл->Внешняя обработка->Имя:СпособыЧтенияДанных->Форма обработки->Команды->Добавить->ОбъектнаяМодель,ТабличнаяМодель->Перетаскиваем команды в командную панель->ОбхектнаяМодель->ДействияКоманды->На клиенте и на сервере
	&НаКлиенте
	Процедура ОбъектнаяМодель(Команда)
	    ОбъектнаяМодельНаСервере();
	КонецПроцедуры
	&НаСервере
	Процедура ОбъектнаяМодельНаСервере()
	    Выборка=Справочники.ТоварныеКатегории.Выбрать();
	    Пока Выборка.Следующий() Цикл
	        Сообщение=Новый СообщениеПользователю;
	        Сообщение.Текст=Выборка.Наименование;
	        Сообщение.Сообщить();
	    КонецЦикла;
	КонецПроцедуры
	Output:
	Объектная модель
	    Женская обувь
	    Кабели
	    Кондиционеры
	    Крупы
	    Масло
	    Мебель
	    Мебель (наборы)
	    Мебель (сборка)
	    Молоко
	    Мужская обувь
	    Соки
	    Спортивная обувь
	    Телевизоры
	    Хлебобулочные изделия
	    Холодильники
	    Электротовары
	    Объектная модель доступа к данным. Ограничения.(1)
	Task:
	Если мы хотим поменять номенклатуру
	Decision:
	...
	Процедура ОбъектнаяМодельНаСервере()
	    Выборка=Справочники.ТоварныеКатегории.Выбрать();
	    Пока Выборка.Следующий() Цикл  
	        ТоварОбъект=Выборка.ПолучитьОбъект();
	        ТоварОбъект.Артикул="21414";
	        ТоварОбъект.Записать();
	        Сообщение=Новый СообщениеПользователю;
	        Сообщение.Текст=Выборка.Наименование;
	        Сообщение.Сообщить();
	    КонецЦикла;
	КонецПроцедуры
	Task:
	Получить данные из двух таблиц
	Decision:
	...
	    Выборка=Справочники.ТоварныеКатегории.Выбрать();
	    ВыборкаЦены=РегистрыСведений.ЦеныНоменклатуры.Выбрать();
	    Пока Выборка.Следующий() Цикл
	...
	Task:
	Попробуем прочитать из таблицы заказов по одному покупателю
	Decision:
	        ...
	    КонецЦикла;    
	    Покупатель=Справочники.Контрагенты.НайтиПоНаименованию("Саймон и Шустер");
	    Отбор=Новый Структура("Партнер", Покупатель);
	    ВыборкаЗаказы=Документы.ЗаказКлиента.Выбрать(,,Отбор);
	КонецПроцедуры
	Task:
	Вывести информацию с помощью табличной модели
	Decision:
	    Табличная модель->Выполнить действия->Клиент,Сервер->Конструктор запроса->Таблицы и поля->Справочник->Товарные категории> -> Наименование>
	&НаКлиенте
	Процедура ТабличнаяМодель(Команда)
	    ТабличнаяМодельНаСервере();
	КонецПроцедуры
	&НаСервере
	Процедура ТабличнаяМодельНаСервере()
	    //{{КОНСТРУКТОР_ЗАПРОСА_С_ОБРАБОТКОЙ_РЕЗУЛЬТАТА
	    // This fragment was built by the wizard.
	    // Warning! All manually made changes will be lost next time you use the wizard.
	    Запрос = Новый Запрос;
	    Запрос.Текст =
	        "ВЫБРАТЬ
	        |   ТоварныеКатегории.Наименование КАК Наименование
	        |ИЗ
	        |   Справочник.ТоварныеКатегории КАК ТоварныеКатегории";
	    РезультатЗапроса = Запрос.Выполнить();
	    ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
	    Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
	        // Insert selected data processing ВыборкаДетальныеЗаписи
	        Сообщение=Новый СообщениеПользователю;
	        Сообщение.Текст=ВыборкаДетальныеЗаписи.Наименование;
	        Сообщение.Сообщить();
	    КонецЦикла;
	    //}}КОНСТРУКТОР_ЗАПРОСА_С_ОБРАБОТКОЙ_РЕЗУЛЬТАТА
	КонецПроцедуры
	Output:
	Табличная модель
	    Молоко
	    Масло
	    Крупы
	    Хлебобулочные изделия
	    Соки
	    Женская обувь
	    Мужская обувь
	    Спортивная обувь
	    Кондиционеры
	    Кабели
	    Мебель (сборка)
	    Мебель (наборы)
	    Телевизоры
	    Холодильники
	    Электротовары
	    Мебель
	Task:
	Консоль запросов
	Decision:
	    1с предприятие->Файл->Открыть->УправляемаяКонсольОтчетов 3.8.9->Текст запроса
	ВЫБРАТЬ * ИЗ Справочник.ТоварныеКатегории
	    Выполнить
	Task:
	Конструктор запросов
	Из справочника ТоварныеКатегории выбрать все наименования товаров
	Decision:
	Конструктор->База данных->Справочники->ТоварныеКатегории>->Таблицы->Наименование>->Ок->Выполнить
	Простые запросы
	Task:
	Самый простой запрос: константные значения в запросе
	Decision:
	ВЫБРАТЬ
	5 КАК ПростоеЧисло,
	"строка" КАК ПростаяСтрока
	Decision:
	    Конструктор->Поле->Добавить->5,"строка"->Объединение Псевдонимы->Поле1,Поле2->ПростоеЧисло,ПростаяСтрока->Ок->Выполнить
	Output:
	    ПростоеЧисло    ПростаяСтрока
	    5               строка
	Task:
	Как прочитать значение константы
	Decision:
	    Добавить запрос->Запрос к константе->Конструктор->База данных->Константы->ВалютаУпрвленческогоУчета>->Таблицы->Значение>->ок->Выполнить
	Decision:
	    Значение
	    USD
	Task:
	Как прочитать данные из справочников
	Decision:
	    Добавить запрос->Запрос к справочнику->Конструктор->База данных->Справочник->Контрагенты>->Наименование, КодПоОКПО,СтранаРегистрации>->ок->Выполнить
	Task:
	Как прочитать данные из документов
	Decision:
	    Добавить запрос->Запрос к документу->Конструктор->База данных->Документ->ЗаказКлиента>->Номер, Дата, Партнер, Склад, Валюта, Автор, СуммаДокумента>->ок->Выполнить
	Task:
	Как прочитать данные из табличных частей
	Decision:
	Добавить запрос->Запрос к табличной части->Конструктор->База данных->ЗаказКлиентаТовары>->НомерСтроки, Номенклатура, Цена, Количество, Сумма>->ок->Выполнить
	Task:
	Разыменование полей в запросе
	Decision:
	Добавить запрос->Запрос к табличной части (разыменование)->Конструктор->База данных->ЗаказКлиентаТовары>->Таблицы->НомерСтроки, Номенклатура, Цена, Количество, Сумма>->Таблицы->Ссылка->Контрагент>->ок->Выполнить
	Фильтр в запросе
	Task:
	Найти контрагента по наименованию
	Decision:
	Добавить запрос->Условие в запросе->Конструктор->База данных->Контрагенты>->Ссылка, Наименование, КодПоОКПО>->Условие->Поля->Наименование>->ок->Параметры->Значение->Бакалея->Выполнить
	Task:
	Выбрать из справочника «Товары» только элементы (без групп)
	Decision:
	Добавить запрос->Товары без групп->Конструктор->База данных->Справочники->ТоварныеКатегории>->Наименование, ЭтоГруппа,Владелец->Условие->Поля->ЭтоГруппа>->ок->Параметры->Значение->Да->Выполнить
	Task:
	Найти товар по наименованию    по точному соответствию
	    по неточному соответствию
	Decision:
	Добавить запрос->Запрос по наименованию (точное соответствие)->Конструктор->База данных->Справочник>->ТоварныеКатегории->Наименование,Владелец>Условие->Условие->Поля->ТоварныеКатегории->Наименование>->ок->Параметры->Значение->Молоко->Выполнить
	Decision:
	Добавить запрос->Запрос по наименованию (не точное соответствие)->Конструктор->База данных->Справочник>->ТоварныеКатегории->Наименование,Владелец>Условие->Условие->Поля->ТоварныеКатегории->Наименование>->ТоварныеКатегории.Наименование ПОДОБНО &Наименование->ок->Параметры->Значение->%Мебель%->Выполнить
	Task:
	Выбрать товар из группы «Электротовары» не включая/включая вложенные группы
	Decision:
	Добавить запрос->Выбор товаров из группы->Конструктор->База данных->Справочник>->ТоварныеКатегории->Наименование,Владелец>Условие->Условие->Поля->ТоварныеКатегории->Родитель>->ок->Параметры->Значение->Электротовары->Выполнить
	Task:
	Найти товары, для которых не заполнен реквизит кода
	Decision:
	Добавить запрос->Поиск товаров без кода->Конструктор запроса->База данных->Справочник>->ТоварныеКатегории->Наименование,код>Условие->Поля->ТоварныеКатегории->код>->ТоварныеКатегории.Владелец.КодОКВЭД = ""->ок->Выполнить
	Task:
	Найти товары, для которых заполнен реквизит код
	Decision:
	Копировать запрос->переименовать->Поиск товаров с кодом>Конструктор запроса->Условие->ТоварныеКатегории.Владелец.КодОКВЭД <> ""->ok->Выполнить
	Группировка
	Task:
	Выбирать данные из всех заказов
	Decision:
	Добавить запрос->Все товары из заказов->Конструктор запроса->База данных->Документы>->ЗаказКлиента->Товары>Количество,Сумма,Номенклатура,Цена>ок->Выполнить
	Decision:
	ВЫБРАТЬ
	    ЗаказКлиентаТовары.Количество КАК Количество,
	    ЗаказКлиентаТовары.Сумма КАК Сумма,
	    ЗаказКлиентаТовары.Номенклатура КАК Номенклатура,
	    ЗаказКлиентаТовары.Цена КАК Цена
	ИЗ
	    Документ.ЗаказКлиента.Товары КАК ЗаказКлиентаТовары
	Task:
	Нужно сделать так, чтобы по каждому товару была только одна запись. То есть мы хотим получить общим общий объем количества товаров и сумму и минимальную цену
	Decision:
	Конструктор запроса->Группировка->Номенклатура>Поле группировки->Количество,Сумма,Цена>Суммарные поля->Цена->Минимум->ок->Выполнить
	Decision:
	ВЫБРАТЬ
	    СУММА(ЗаказКлиентаТовары.Количество) КАК Количество,
	    СУММА(ЗаказКлиентаТовары.Сумма) КАК Сумма,
	    ЗаказКлиентаТовары.Номенклатура КАК Номенклатура,
	    МИНИМУМ(ЗаказКлиентаТовары.Цена) КАК Цена
	ИЗ
	    Документ.ЗаказКлиента.Товары КАК ЗаказКлиентаТовары
	СГРУППИРОВАТЬ ПО
	    ЗаказКлиентаТовары.Номенклатура
	Task:
	Получить сводную информацию о продажах товаров за период по данным документов «РасходныйОрдерНаТовары»
	Decision:
	Добавить запрос->Продажа по документам->Конструктор запроса->База данных->Документы->РасходныйОрдерНаТовары->ТоварыПоРаспоряжениям>->Номенклатура,Количество>->ок->Выполнить
	Decision:
	ВЫБРАТЬ
	    РасходныйОрдерНаТоварыТоварыПоРаспоряжениям.Количество КАК Количество,
	    РасходныйОрдерНаТоварыТоварыПоРаспоряжениям.Номенклатура КАК Номенклатура
	ИЗ
	    Документ.РасходныйОрдерНаТовары.ТоварыПоРаспоряжениям КАК РасходныйОрдерНаТоварыТоварыПоРаспоряжениям
	Decision:
	Конструктор запроса->Группировка->Номенклатура>Поле группировки->Количество>Суммарные поля->ок->Выполнить
	Decision:
	ВЫБРАТЬ
	    СУММА(РасходныйОрдерНаТоварыТоварыПоРаспоряжениям.Количество) КАК Количество,
	    РасходныйОрдерНаТоварыТоварыПоРаспоряжениям.Номенклатура КАК Номенклатура
	ИЗ
	    Документ.РасходныйОрдерНаТовары.ТоварыПоРаспоряжениям КАК РасходныйОрдерНаТоварыТоварыПоРаспоряжениям
	СГРУППИРОВАТЬ ПО
	    РасходныйОрдерНаТоварыТоварыПоРаспоряжениям.Номенклатура
	Task:
	Получить количество продаж в разрезе покупателей
	Decision:
	Добавить запрос->Количество продаж по контрагентам->Конструктор запроса->РасходныйОрдерНаТовары>->Получатель,Ссылка>->
	Decision:
	ВЫБРАТЬ
	    РасходныйОрдерНаТовары.Ссылка КАК Ссылка,
	    РасходныйОрдерНаТовары.Получатель КАК Получатель
	ИЗ
	    Документ.РасходныйОрдерНаТовары КАК РасходныйОрдерНаТовары
	Decision:
	Конструктор запроса->Группировка->Получатель>Поле группировки->Ссылка>Суммарные поля->ок->Выполнить
	Decision:
	ВЫБРАТЬ
	    КОЛИЧЕСТВО(РАЗЛИЧНЫЕ РасходныйОрдерНаТовары.Ссылка) КАК Ссылка,
	    РасходныйОрдерНаТовары.Получатель КАК Получатель
	ИЗ
	    Документ.РасходныйОрдерНаТовары КАК РасходныйОрдерНаТовары  
	СГРУППИРОВАТЬ ПО
	    РасходныйОрдерНаТовары.Получатель
	Task:
	По каждому товару определить максимальное количество
	единиц, которое продавалось за одну продажу
	Decision:
	Добавить запрос->Максимальное количество за одну продажу->Конструктор запроса->База данных->Документы->РасходныйОрдерНаТовары->ТоварыПоРаспоряжениям>->Номенклатура,Количество>->Группировка->Номенклатура>Поле группировки->Количество>Суммарные поля->Максимум->ок->Выполнить
	Decision:
	ВЫБРАТЬ
	    РасходныйОрдерНаТоварыТоварыПоРаспоряжениям.Номенклатура КАК Номенклатура,
	    МИНИМУМ(РасходныйОрдерНаТоварыТоварыПоРаспоряжениям.Количество) КАК Количество
	ИЗ
	    Документ.РасходныйОрдерНаТовары.ТоварыПоРаспоряжениям КАК РасходныйОрдерНаТоварыТоварыПоРаспоряжениям
	СГРУППИРОВАТЬ ПО
	    РасходныйОрдерНаТоварыТоварыПоРаспоряжениям.Номенклатура
	Task:
	Получить среднюю сумму продаж по дням за период
	Decision:
	Добавить запрос->Продажи по документам (сумма)->Конструктор запроса->База данных->Документы->ЗаказКлиента>->Дата,СуммаДокумента>->Группировка->Дата>Поле группировки->СуммаДокумента>Суммарные поля->Среднее->Таблицы и поля->Поле->Дата->Редактировать->Функция языка запросов->Функции->Функции работы с датами->Начало периода->Перетащить его в нижнее поле->НАЧАЛОПЕРИОДА(ЗаказКлиента.Дата, ДЕНЬ)->ок->Выполнить
	Decision:
	ВЫБРАТЬ
	    НАЧАЛОПЕРИОДА(ЗаказКлиента.Дата, ДЕНЬ) КАК Дата,
	    ЗаказКлиента.СуммаДокумента КАК СуммаДокумента
	ИЗ
	    Документ.ЗаказКлиента КАК ЗаказКлиента
	Task:
	Сортировка данных
	Выбрать все документы «Приход товара» в порядке убывания даты
	Decision:
	Добавить запрос->Приходы по убыванию->Конструктор запроса->База данных->Документы->ПриходныйОрдерНаТовары>->Дата,Номер,Склад>->Порядок->Дата->По убыванию->ок->Выполнить
	Decision:
	ВЫБРАТЬ
	    ПриходныйОрдерНаТовары.Дата КАК Дата,
	    ПриходныйОрдерНаТовары.Склад КАК Склад,
	    ПриходныйОрдерНаТовары.Номер КАК Номер
	ИЗ
	    Документ.ПриходныйОрдерНаТовары КАК ПриходныйОрдерНаТовары
	УПОРЯДОЧИТЬ ПО
	    Дата УБЫВ
	Task:
	Определить дату последнего поступления конкретного товара
	Decision:
	Добавить запрос->дата последнего поступления товара->Конструктор запроса->База данных->Документы->ПриходныйОрдерНаТовары->Товары>->Номенклатура,Ссылка,Дата->Порядок->Дата->По убыванию->Дополнительно->Выборка записей->перерыв->1->ок->Выполнить
	Decision:
	ВЫБРАТЬ ПЕРВЫЕ 1
	    ПриходныйОрдерНаТоварыТовары.Номенклатура КАК Номенклатура,
	    ПриходныйОрдерНаТоварыТовары.Ссылка.Дата КАК Дата,
	    ПриходныйОрдерНаТоварыТовары.Ссылка.Ссылка КАК Ссылка
	ИЗ
	    Документ.ПриходныйОрдерНаТовары.Товары КАК ПриходныйОрдерНаТоварыТовары
	Task:
	Итоги в запросе
	Получить сводную информацию о продажах товаров за период по данным документов «Расход товара» в разрезе покупателей и заказов. По
	каждому покупателю нужно вычислять итоговую сумму всех заказов
	Decision:
	Добавить запрос->Итоги по заказам->Конструктор запроса->База данных->Документы->ЗаказКлиента>->Партнер,Ссылка,СуммаДокумента>->Итоги->Партнер>Группировочное поле->СуммаДокумента>Итоговое поле->ок->Выполнить
	Decision:
	ВЫБРАТЬ
	    ЗаказКлиента.Ссылка КАК Ссылка,
	    ЗаказКлиента.СуммаДокумента КАК СуммаДокумента,
	    ЗаказКлиента.Партнер КАК Партнер
	ИЗ
	    Документ.ЗаказКлиента КАК ЗаказКлиента
	ИТОГИ
	    СУММА(СуммаДокумента)
	ПО
	    Партнер
	Task:
	Получить все документы «Приход товара» в хронологическом порядке с подсчетом итогов количества документов за каждый день периода
	Decision:
	Добавить запрос->Приходы с итогами по дням->Конструктор запроса->База данных->Документы->ПриходныйОрдерНаТовары>->Дата,Номер,Ссылка>->Дата->редактировать->Функции языка запросов->Функции->Функции работы с датами->НАЧАЛОПЕРИОДА->перетаскиваем вниз->НАЧАЛОПЕРИОДА(ПриходныйОрдерНаТовары.Дата, ДЕНЬ)->Итоги->дата>Группировочное поле->Ссылка>Итоговое поле->ок->Выполнить
	Decision:
	ВЫБРАТЬ
	    НАЧАЛОПЕРИОДА(ПриходныйОрдерНаТовары.Дата, ДЕНЬ) КАК Поле1,
	    ПриходныйОрдерНаТовары.Номер КАК Номер,
	    ПриходныйОрдерНаТовары.Ссылка КАК Ссылка
	ИЗ
	    Документ.ПриходныйОрдерНаТовары КАК ПриходныйОрдерНаТовары
	ИТОГИ
	    КОЛИЧЕСТВО(РАЗЛИЧНЫЕ Ссылка)
	ПО
	    Поле1
	Task:
	Как сформировать отчет
	Создать отчет Остатки товаров. Пользователь должен иметь возможность выбрать дату получения остатков. Результат должен выглядеть примерно так:
	    Остатки товаров на дату 17.02.2020
	Номенклатура         Остаток
	Молоток                7
	Отвертка крестовая    5
	Шуруповерт            20
	Штукатурка            -6
	Газонокосилка         7
	Итого                33
	Decision:
	    регистры накопления - добавить - ОстаткиТоваров - данные - измерения - номенклатура - Ресурсы - добавить - КоличествоОстаток - документы - добавить - Номенклатура - движение - регистры накопления - +ОстаткиТоваров - Отчет - добавить - ОстатокТоваров_ФиксированныйМакет - данные - реквизиты - добавить - дата - тип - дата - формы - форма отчета - команды - добавить - Сформировать - представление - картинка - отображение - картинка и текст - сформировать - петескиваем команду в командную панель формы - форма - свойства - использование - положение командной панели - авто - кнопка по умолчанию - реквизиты - дооавить - ТабДок - тип - табличный документ - положение заголовки - нет - ок - перетаскиваем в форму - свойства - команды - сформировать - действие - на клиенте и на сервере - конструктор запроса с обработкой результата - вывод в табличный документ - таблицы и поля - регистры накопления - ОстаткиТоваров.Остатки> - параметры виртуальной таблицы - период - &Дата - номенклатура, КоличествоОстатки> - Итоги - количествоОстаток перетскиваем в итоговое поле - ок - модуль
	&НаСервере
	Процедура СформироватьНаСервере()
	    Макет = Отчеты.ОстатокТоваров_ФиксированныйМакет.ПолучитьМакет("Макет");
	    Запрос = Новый Запрос;
	    Запрос.Текст =
	        "ВЫБРАТЬ
	        |    ОстаткиТоваровОстатки.Номенклатура КАК Номенклатура,
	        |    ОстаткиТоваровОстатки.КоличествоОстатокОстаток КАК КоличествоОстатокОстаток
	        |ИЗ
	        |    РегистрНакопления.ОстаткиТоваров.Остатки(&Дата, ) КАК ОстаткиТоваровОстатки";
	    
	    Запрос.УстановитьПараметр("Дата", Дата);    
	    РезультатЗапроса = Запрос.Выполнить();    
	    ОбластьЗаголовок = Макет.ПолучитьОбласть("Заголовок");
	    ОбластьПодвал = Макет.ПолучитьОбласть("Подвал");
	    ОбластьШапкаТаблицы = Макет.ПолучитьОбласть("ШапкаТаблицы");
	    ОбластьПодвалТаблицы = Макет.ПолучитьОбласть("ПодвалТаблицы");
	    ОбластьДетальныхЗаписей = Макет.ПолучитьОбласть("Детали");    
	    ТабДок.Очистить();
	    ТабДок.Вывести(ОбластьЗаголовок);
	    ТабДок.Вывести(ОбластьШапкаТаблицы);
	    ТабДок.НачатьАвтогруппировкуСтрок();    
	    ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();    
	    Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
	        ОбластьДетальныхЗаписей.Параметры.Заполнить(ВыборкаДетальныеЗаписи);
	        ТабДок.Вывести(ОбластьДетальныхЗаписей, ВыборкаДетальныеЗаписи.Уровень());
	    КонецЦикла;    
	    ТабДок.ЗакончитьАвтогруппировкуСтрок();
	    ТабДок.Вывести(ОбластьПодвалТаблицы);
	    ТабДок.Вывести(ОбластьПодвал);
	КонецПроцедуры
	&НаКлиенте
	Процедура Сформировать(Команда)
	    СформироватьНаСервере();
	КонецПроцедуры
	Task:
	Поменяем макет
	Decision:
	    Макет -Заголовок - ячейка - свойства - макет - заполнение - шаблон
	    Остатки товаров на дату: [Дата]
	    модуль
	    ...
	    //Запрос.УстановитьПараметр("Дата", Дата);
	    Запрос.УстановитьПараметр("Дата", Отчет.Дата);
	    ..
	    ТабДок.Очистить();  
	    ОбластьЗаголовок.Параметры.Дата = Формат(Отчет.Дата, )
	    ТабДок.Вывести(ОбластьЗаголовок);
	    ..
	    Конструктор форматной строки - дата - формат даты - выбираем - ок
	    ...
	    ТабДок.Очистить();  
	    ОбластьЗаголовок.Параметры.Дата = Формат(Отчет.Дата, "ДФ=dd.MM.yyyy");
	    ТабДок.Вывести(ОбластьЗаголовок);
	    ТабДок.Вывести(ОбластьШапкаТаблицы);
	    ТабДок.НачатьАвтогруппировкуСтрок();      
	    //ВыборкаОбщийИтог=РезультатЗапроса.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
	    //ВыборкаОбщийИтог.Следующий();
	    //ОбластьОбщийИтог.Параметры.Заполнить(ВыборкаОбщийИтог);    
	    ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();    
	    Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
	        ОбластьДетальныхЗаписей.Параметры.Заполнить(ВыборкаДетальныеЗаписи);
	        ТабДок.Вывести(ОбластьДетальныхЗаписей, ВыборкаДетальныеЗаписи.Уровень());
	    КонецЦикла;
	    //ТабДок.Вывести(ОбластьОбщийИтог, ВыборкаОбщийИтог.Уровень());
	    ТабДок.ЗакончитьАвтогруппировкуСтрок();
	    //ТабДок.Вывести(ОбластьПодвалТаблицы);
	    //ТабДок.Вывести(ОбластьПодвал);
	    ...
	    запустить
	Task:
	Сделать такой отчет с помощью СКД
	Decision:
	    Отчет - добавить - открыть схему компоновки данных - ок - добавить набор данных - запрос - конструктор запроса - Регистрация накопления - ОстаткиТоваров.Остатки> - номенклатура, КоличествоОстаток> - ок - параметры - Ресурсы - КоличествоОстатокОстаток> - Настройки - открыть конструктор настроек - список - номенклатура, КоличествоОстаток> - ок - параметры - период - пр.кн. - свой элемента пользвательских настроек - *Включать в пользовательские настройки - ок - запустить
	Документ "поступление товаров"
	Task:
	Для регистрации события покупки материальных ценностей создадим документ "поступление товаров"
	Decision:
	    Конфигурация-документы-добавить-имя, синоним: Постпуление товаров-подсистема-закупки
	    Данные-реквизиты:добавить-имя:организация-тип:справочникСсылка.Организация-проверка заполнения:выдать ошибки-так же с контрагентом-табличные части:добавить табличную часть-имя,синоним:товары-табличные части:добавить реквизит таблицы-имя:Номенклатура-тип:справочникСсылка.Номенклатура-проверка заполнения:выдать ошибки-табличные части:добавить реквизит таблицы-имя:Цена-тип:число-точность:2-также с количеством (точность оставить 0) и суммой
	Task:
	Копирование объектов конфигурации
	Сделаем документ реализация товаров, скопировав и вставив объект поступление товаров.
	Decision:
	    Конфигурация-ctrl+c"поступление товаров"-ctrl+v"поступление товаров"-переименуем имя на "реализация товаров"-подсистема-Продажи
	Task:
	Выяснилось, что наше предприятие имеет несколько складов. Пjэтому нужно еще ввести список складов, который должен быть доступен из раздела "общее", при поступлении и продаже товаров нужно указывать склад, причем, при покупке товаров все товары одной накладной приходуются на один склад, то есть реквизит склад должен располагаться в "шапке" документа под контрагентом, а при продаже польователь должен иметь возможность выбора склада и в "шапке" и таблчиной части документа. т. е. если все товары продаются с одного склада, пользователь укажет склад как в приходной накладной, а если товары в разных строках продаются с разных складов, значит пользователь укажет склады в каждой строке документа.
	Task:
	Поле ввода и удобное заполнение реквизитов
	Decision:
	    Конфигурация-справочники-контрагенты-поле ввода
	Создание при вводе
	Task:
	при заполнении приходной накладной, выясняется, что это первый документ от контрагента "Крутой поставщик" и такого в справочнике еще нет.
	Decision:
	    Пользователь нажмет на педальку выбора из правочника, ему покажут последние, которые он выбирал, можно также создать новый
	    Пользоавтель начнет выбирать наименование элемента, подкажут, что такого нет, и предложать опять новый создать.
	Task:
	Новые реквизиты для поиска по строке
	Наименования контрагентов часто повторяются, а ИНН должно быть уникальным.
	Decision:
	    Конфигурация-справочники-контрагенты-данные-ИНН-индексировать:индексировать-поле ввода-ввод по строке-ИНН > - Код
	Способ поиска строки
	Decision:
	    Конфигурация-справочники-контрагенты-поле ввода-способ поиска строки:любой части
	Task:
	История выбора
	Decision:
	    Конфигурация-справочники-контрагенты-поле ввода-история выбора при вводе:авто
	Decision:
	При выборе истории выбора - Авто, сначала открывается список выбранных пользователем ранее элементов, а затем команда "показать все" и "добавить"
	Дополнительные реквизиты, тип данных
	Task:
	Для элемента справочника номенклатуры лучше хранить цену и изготовителя, а для контрагентов - инн и адрес. Для этого нужно добавить реквизиты.
	Decision:
	    Конфигуратор - справочники - контрагенты - данные - реквизиты - создать - имя и синоним: адрес - неограниченная длина - ок - создать - имя и синоним: ИНН - длина: 12 - ок
	Task:
	Примитивные типы данных
	Добавим в справчник номенклатура реквизит цена
	Decision:
	>    Справочник - номенклатура - данные - реквизиты - создать - имя и синоним: Цена - тип: число - длина: 10 - точность: 2 - неотрицательное
	Task:
	Ссылочные типы данных
	Для каждого товара из номенклатуры мы хотим помнить изготовителя (контрагент, который выпускает этот товар, оказывает эту услугу). Поэтому нужно один раз ввести справочник "Контрагенты" того самого изготовителя и многократно выбирать его в разных элементах справочника "Номенклатура"
	Decision:
	    Справочники - номенклатура - данные - реквизиты - создать - имя и синоним: Изготовитель - тип: редактор - справочникСсылка - контрагенты

	Линейные справочники
	Task:
	Наше предприятие может состоять из нескольких самостоятельных юридических лиц и/или обособленных и выделенных на отдельный баланс подразделений. Список этих самостоятельных бизнес-единиц нужно где-то хранить. Создадим справочник "Организация"
	Decision:
	Создадим справочник "Организация"- В закладке данные мы можем упралять длиной стандартных реквизитов "Код" и "Наименование"
	Внутренний      Код                 Наименование
	Идентификатор
	ID              Строка 3 символа    Строка 25 символов
	Включение справочника в управляемый интерфейс
	Task:
	Чтобы пользователь мог открыть справочни, команда открытия его списка должна быть включена в глобальный командный интерфейс конфигурации.
	Нужно предоставить пользователю  возможность открыть справочник для просмотра и заполнения. Для эттого нужно подключить подсистему.
	Decision:
	    Подсистемы - Общее -
	И у него должно быть включено использование стандартных команд
	    Команды - Использовать стандартные команды
	Переименуем элемент "Основная оргаизация" в "Фабрика" - создадим еще элемент "Торговый дом".
	В режиме "Версия 8.2" /Сервис/Параметры/Формы в отдельных закладках выглядит это так:
	Task:
	Включение в интерфейс обычного приложения
	Decision:
	    Конфигуратор - Общее - Интерфейсы - Интерфейс1 - Общее - Новая - Действие - Объект метаданных:Справочники - Организация - Действие: Открыть справочник организация - ОК
	Decision:
	Запустив через "толстый клиент обычное приложение":
	Task:
	Иерархические справочники
	Для хранеия списка справочника, разбитого на группы, создается иерархический справочник. Удобно разбить справочник на группы по видам ценностей: товары, материалы, продукция.
	Создадим справочник номенкатура.
	Decision:
	    Конфигуратор - Справочник - Номенклатура - Подсистема - Общее - иерархия - иерархический справочник
	Decision:
	Таблица иерархического справочника:
	Ссылка  Это     Код     Наименование    Родитель
	        группа
	...     Истина  01      Группа          <Пусто>
	...     Ложь    02      Элемент         Ссылка группы
	Task:
	Стандартные реквезиты
	Свойство "Родитель" может быть не понятно пользователю. Изменить его нужно:
	    Данные - Стандартные реквизиты - Стандартные реквизиты: Родитель - Синоним: Группа
	Task:
	Чтобы определить, какой режим будет основным, и будут ли возможны переключения между разными вариантами интерфейса
	Decision:
	откройте свойство корня дерева конфигурации "Конфигурация"-Выберем режим совместимости "Такси-Разрешить Версия 8.2". То есть по умолчанию будет использоваться вариант интерфейса "такси", но можно переключиться в предыдущий вариаант режима.
	Разделы управляемого интерфейса
	Создание разделов.
	Task:
	Создадим 4 подсистемы. Общее - включает все справочники, закупки - что нужно пользователю для оформления покупки товаров, продажи - для оформления продажи, сервис - служебные функции программы. Чтоб кнопки разделов программа выстроила на панели не по алфавиту, а так как мы это заводили, нужно в окне командный интерфейс выбрать нужный нам порядок.
	Decision:
	конфигурация-общее-подсистемы-сервис-основные-командный интерфейс
	Task:
	Настройка положения панелей "Такси"
	Изменим положение по умолчанию панелей
	Decision:
	Конфигурация-открыть интерфес клиентского приложения - -меняем положения разделов-
	Task:
	Можно в пользовательском интерфейсе это сделать
	Decision:
	вид-настройка панелей-меняем положения
	Управяемый интерфейс "Версия 8.2"
	Task:
	Посмотрим результаты нашей работы в интерфейсе "Версия 8.2".
	Decision:
	Сервис-Параметры-+формы в отдельных окнах
	Task:
	Интерфейс обычного приложения
	запустить программу в режиме обычного приложения
	Decision:
	поставить галочку в управляемое приложение и обычное приложение в Конфигуратор-сервис-параметры -запустить через - откладка - начало откладки - толстый клиент (обычное приложение) - начать откладку
	Decision:
	https://github.com/David138it/MyPortfolio/tree/main/TaskDecision/1c-Evrisoft/
	Source:
	1. Практическое пособие разработчика М.Г. Радченко, Е.Ю. Хрусталева
	2. https://www.youtube.com/channel/UC124tAuP11GlaGpK3YGHzlw
	Task:
	Установка 1с в Ubuntu 20.04
	Decision:
	:~$ tar xvzf training_8_3_19_1150.deb64.tar.gz
	  1c-enterprise-8.3.19.1150-training-nls_8.3.19-1150_amd64.deb
	  1c-enterprise-8.3.19.1150-training_8.3.19-1150_amd64.deb
	  1c-enterprise-license-tools-0.14.3+7-linux-x86_64.tar.gz
	:~$ sudo apt -y install libwebkitgtk-3.0-0
	  Reading package lists... Done
	  Building dependency tree       
	  Reading state information... Done
	  Package libwebkitgtk-3.0-0 is not available, but is referred to by another package.
	  This may mean that the package is missing, has been obsoleted, or
	  is only available from another source
	  E: Package 'libwebkitgtk-3.0-0' has no installation candidate
	:~$ sudo cat /etc/apt/sources.list
	# deb cdrom:[Ubuntu 20.04.2.0 LTS _Focal Fossa_ - Release amd64 (20210209.1)]/ focal main restricted
	deb-src http://archive.ubuntu.com/ubuntu focal main restricted #Added by software-properties
	# See http://help.ubuntu.com/community/UpgradeNotes for how to upgrade to
	# newer versions of the distribution.
	deb http://us.archive.ubuntu.com/ubuntu/ focal main restricted
	deb-src http://us.archive.ubuntu.com/ubuntu/ focal multiverse universe main restricted #Added by software-properties
	## Major bug fix updates produced after the final release of the
	## distribution.
	deb http://us.archive.ubuntu.com/ubuntu/ focal-updates main restricted
	deb-src http://us.archive.ubuntu.com/ubuntu/ focal-updates multiverse universe main restricted #Added by software-properties
	## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu
	## team. Also, please note that software in universe WILL NOT receive any
	## review or updates from the Ubuntu security team.
	deb http://us.archive.ubuntu.com/ubuntu/ focal universe
	# deb-src http://us.archive.ubuntu.com/ubuntu/ focal universe
	deb http://us.archive.ubuntu.com/ubuntu/ focal-updates universe
	# deb-src http://us.archive.ubuntu.com/ubuntu/ focal-updates universe
	## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu
	## team, and may not be under a free licence. Please satisfy yourself as to
	## your rights to use the software. Also, please note that software in
	## multiverse WILL NOT receive any review or updates from the Ubuntu
	## security team.
	deb http://us.archive.ubuntu.com/ubuntu/ focal multiverse
	# deb-src http://us.archive.ubuntu.com/ubuntu/ focal multiverse
	deb http://us.archive.ubuntu.com/ubuntu/ focal-updates multiverse
	# deb-src http://us.archive.ubuntu.com/ubuntu/ focal-updates multiverse
	## N.B. software from this repository may not have been tested as
	## extensively as that contained in the main release, although it includes
	## newer versions of some applications which may provide useful features.
	## Also, please note that software in backports WILL NOT receive any review
	## or updates from the Ubuntu security team.
	deb http://us.archive.ubuntu.com/ubuntu/ focal-backports main restricted universe multiverse
	deb-src http://us.archive.ubuntu.com/ubuntu/ focal-backports main restricted universe multiverse #Added by software-properties
	## Uncomment the following two lines to add software from Canonical's
	## 'partner' repository.
	## This software is not part of Ubuntu, but is offered by Canonical and the
	## respective vendors as a service to Ubuntu users.
	# deb http://archive.canonical.com/ubuntu focal partner
	# deb-src http://archive.canonical.com/ubuntu focal partner
	deb http://security.ubuntu.com/ubuntu focal-security main restricted
	deb-src http://security.ubuntu.com/ubuntu focal-security multiverse universe main restricted #Added by software-properties
	deb http://security.ubuntu.com/ubuntu focal-security universe
	# deb-src http://security.ubuntu.com/ubuntu focal-security universe
	deb http://security.ubuntu.com/ubuntu focal-security multiverse
	# deb-src http://security.ubuntu.com/ubuntu focal-security multiverse
	# This system was installed using small removable media
	# (e.g. netinst, live or single CD). The matching "deb cdrom"
	# entries were disabled at the end of the installation process.
	# For information about how to configure apt package sources,
	# see the sources.list(5) manual.
	:~$ sudo vim /etc/apt/sources.list
	:~$ cat /etc/apt/sources.list
	# deb cdrom:[Ubuntu 20.04.2.0 LTS _Focal Fossa_ - Release amd64 (20210209.1)]/ focal main restricted
	deb-src http://archive.ubuntu.com/ubuntu focal main restricted #Added by software-properties
	# See http://help.ubuntu.com/community/UpgradeNotes for how to upgrade to
	# newer versions of the distribution.
	deb http://us.archive.ubuntu.com/ubuntu/ focal main restricted
	deb-src http://us.archive.ubuntu.com/ubuntu/ focal multiverse universe main restricted #Added by software-properties
	## Major bug fix updates produced after the final release of the
	## distribution.
	deb http://us.archive.ubuntu.com/ubuntu/ focal-updates main restricted
	deb-src http://us.archive.ubuntu.com/ubuntu/ focal-updates multiverse universe main restricted #Added by software-properties
	## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu
	## team. Also, please note that software in universe WILL NOT receive any
	## review or updates from the Ubuntu security team.
	deb http://us.archive.ubuntu.com/ubuntu/ focal universe
	# deb-src http://us.archive.ubuntu.com/ubuntu/ focal universe
	deb http://us.archive.ubuntu.com/ubuntu/ focal-updates universe
	# deb-src http://us.archive.ubuntu.com/ubuntu/ focal-updates universe
	## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu
	## team, and may not be under a free licence. Please satisfy yourself as to
	## your rights to use the software. Also, please note that software in
	## multiverse WILL NOT receive any review or updates from the Ubuntu
	## security team.
	deb http://us.archive.ubuntu.com/ubuntu/ focal multiverse
	# deb-src http://us.archive.ubuntu.com/ubuntu/ focal multiverse
	deb http://us.archive.ubuntu.com/ubuntu/ focal-updates multiverse
	# deb-src http://us.archive.ubuntu.com/ubuntu/ focal-updates multiverse
	## N.B. software from this repository may not have been tested as
	## extensively as that contained in the main release, although it includes
	## newer versions of some applications which may provide useful features.
	## Also, please note that software in backports WILL NOT receive any review
	## or updates from the Ubuntu security team.
	deb http://us.archive.ubuntu.com/ubuntu/ focal-backports main restricted universe multiverse
	deb-src http://us.archive.ubuntu.com/ubuntu/ focal-backports main restricted universe multiverse #Added by software-properties
	## Uncomment the following two lines to add software from Canonical's
	## 'partner' repository.
	## This software is not part of Ubuntu, but is offered by Canonical and the
	## respective vendors as a service to Ubuntu users.
	# deb http://archive.canonical.com/ubuntu focal partner
	# deb-src http://archive.canonical.com/ubuntu focal partner
	deb http://security.ubuntu.com/ubuntu focal-security main restricted
	deb-src http://security.ubuntu.com/ubuntu focal-security multiverse universe main restricted #Added by software-properties
	deb http://security.ubuntu.com/ubuntu focal-security universe
	# deb-src http://security.ubuntu.com/ubuntu focal-security universe
	deb http://security.ubuntu.com/ubuntu focal-security multiverse
	# deb-src http://security.ubuntu.com/ubuntu focal-security multiverse
	# This system was installed using small removable media
	# (e.g. netinst, live or single CD). The matching "deb cdrom"
	# entries were disabled at the end of the installation process.
	# For information about how to configure apt package sources,
	# see the sources.list(5) manual.
	deb http://ru.archive.ubuntu.com/ubuntu/ bionic main universe
	:~$ sudo apt-get update
	:~$ sudo apt -y install libwebkitgtk-3.0-0
	:~$ sudo apt -y install ./1c-enterprise-8.3.19.1150-training_8.3.19-1150_amd64.deb
	Task:
	Во время установки 1C 8.3 в Ubuntu 20.04 выходят такие ошибки:
	:~$ sudo apt -y install libwebkitgtk-3.0-0
	  Reading package lists... Done
	  Building dependency tree       
	  Reading state information... Done
	  Package libwebkitgtk-3.0-0 is not available, but is referred to by another package.
	  This may mean that the package is missing, has been obsoleted, or
	  is only available from another source
	  E: Package 'libwebkitgtk-3.0-0' has no installation candidate
	Decision:
	:~$ sudo cat /etc/apt/sources.list
	# deb cdrom:[Ubuntu 20.04.2.0 LTS _Focal Fossa_ - Release amd64 (20210209.1)]/ focal main restricted
	deb-src http://archive.ubuntu.com/ubuntu focal main restricted #Added by software-properties
	# See http://help.ubuntu.com/community/UpgradeNotes for how to upgrade to
	# newer versions of the distribution.
	deb http://us.archive.ubuntu.com/ubuntu/ focal main restricted
	deb-src http://us.archive.ubuntu.com/ubuntu/ focal multiverse universe main restricted #Added by software-properties
	## Major bug fix updates produced after the final release of the
	## distribution.
	deb http://us.archive.ubuntu.com/ubuntu/ focal-updates main restricted
	deb-src http://us.archive.ubuntu.com/ubuntu/ focal-updates multiverse universe main restricted #Added by software-properties
	## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu
	## team. Also, please note that software in universe WILL NOT receive any
	## review or updates from the Ubuntu security team.
	deb http://us.archive.ubuntu.com/ubuntu/ focal universe
	# deb-src http://us.archive.ubuntu.com/ubuntu/ focal universe
	deb http://us.archive.ubuntu.com/ubuntu/ focal-updates universe
	# deb-src http://us.archive.ubuntu.com/ubuntu/ focal-updates universe
	## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu
	## team, and may not be under a free licence. Please satisfy yourself as to
	## your rights to use the software. Also, please note that software in
	## multiverse WILL NOT receive any review or updates from the Ubuntu
	## security team.
	deb http://us.archive.ubuntu.com/ubuntu/ focal multiverse
	# deb-src http://us.archive.ubuntu.com/ubuntu/ focal multiverse
	deb http://us.archive.ubuntu.com/ubuntu/ focal-updates multiverse
	# deb-src http://us.archive.ubuntu.com/ubuntu/ focal-updates multiverse
	## N.B. software from this repository may not have been tested as
	## extensively as that contained in the main release, although it includes
	## newer versions of some applications which may provide useful features.
	## Also, please note that software in backports WILL NOT receive any review
	## or updates from the Ubuntu security team.
	deb http://us.archive.ubuntu.com/ubuntu/ focal-backports main restricted universe multiverse
	deb-src http://us.archive.ubuntu.com/ubuntu/ focal-backports main restricted universe multiverse #Added by software-properties
	## Uncomment the following two lines to add software from Canonical's
	## 'partner' repository.
	## This software is not part of Ubuntu, but is offered by Canonical and the
	## respective vendors as a service to Ubuntu users.
	# deb http://archive.canonical.com/ubuntu focal partner
	# deb-src http://archive.canonical.com/ubuntu focal partner
	deb http://security.ubuntu.com/ubuntu focal-security main restricted
	deb-src http://security.ubuntu.com/ubuntu focal-security multiverse universe main restricted #Added by software-properties
	deb http://security.ubuntu.com/ubuntu focal-security universe
	# deb-src http://security.ubuntu.com/ubuntu focal-security universe
	deb http://security.ubuntu.com/ubuntu focal-security multiverse
	# deb-src http://security.ubuntu.com/ubuntu focal-security multiverse
	# This system was installed using small removable media
	# (e.g. netinst, live or single CD). The matching "deb cdrom"
	# entries were disabled at the end of the installation process.
	# For information about how to configure apt package sources,
	# see the sources.list(5) manual.
	:~$ sudo vim /etc/apt/sources.list
	:~$ cat /etc/apt/sources.list
	# deb cdrom:[Ubuntu 20.04.2.0 LTS _Focal Fossa_ - Release amd64 (20210209.1)]/ focal main restricted
	deb-src http://archive.ubuntu.com/ubuntu focal main restricted #Added by software-properties
	# See http://help.ubuntu.com/community/UpgradeNotes for how to upgrade to
	# newer versions of the distribution.
	deb http://us.archive.ubuntu.com/ubuntu/ focal main restricted
	deb-src http://us.archive.ubuntu.com/ubuntu/ focal multiverse universe main restricted #Added by software-properties
	## Major bug fix updates produced after the final release of the
	## distribution.
	deb http://us.archive.ubuntu.com/ubuntu/ focal-updates main restricted
	deb-src http://us.archive.ubuntu.com/ubuntu/ focal-updates multiverse universe main restricted #Added by software-properties
	## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu
	## team. Also, please note that software in universe WILL NOT receive any
	## review or updates from the Ubuntu security team.
	deb http://us.archive.ubuntu.com/ubuntu/ focal universe
	# deb-src http://us.archive.ubuntu.com/ubuntu/ focal universe
	deb http://us.archive.ubuntu.com/ubuntu/ focal-updates universe
	# deb-src http://us.archive.ubuntu.com/ubuntu/ focal-updates universe
	## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu
	## team, and may not be under a free licence. Please satisfy yourself as to
	## your rights to use the software. Also, please note that software in
	## multiverse WILL NOT receive any review or updates from the Ubuntu
	## security team.
	deb http://us.archive.ubuntu.com/ubuntu/ focal multiverse
	# deb-src http://us.archive.ubuntu.com/ubuntu/ focal multiverse
	deb http://us.archive.ubuntu.com/ubuntu/ focal-updates multiverse
	# deb-src http://us.archive.ubuntu.com/ubuntu/ focal-updates multiverse
	## N.B. software from this repository may not have been tested as
	## extensively as that contained in the main release, although it includes
	## newer versions of some applications which may provide useful features.
	## Also, please note that software in backports WILL NOT receive any review
	## or updates from the Ubuntu security team.
	deb http://us.archive.ubuntu.com/ubuntu/ focal-backports main restricted universe multiverse
	deb-src http://us.archive.ubuntu.com/ubuntu/ focal-backports main restricted universe multiverse #Added by software-properties
	## Uncomment the following two lines to add software from Canonical's
	## 'partner' repository.
	## This software is not part of Ubuntu, but is offered by Canonical and the
	## respective vendors as a service to Ubuntu users.
	# deb http://archive.canonical.com/ubuntu focal partner
	# deb-src http://archive.canonical.com/ubuntu focal partner
	deb http://security.ubuntu.com/ubuntu focal-security main restricted
	deb-src http://security.ubuntu.com/ubuntu focal-security multiverse universe main restricted #Added by software-properties
	deb http://security.ubuntu.com/ubuntu focal-security universe
	# deb-src http://security.ubuntu.com/ubuntu focal-security universe
	deb http://security.ubuntu.com/ubuntu focal-security multiverse
	# deb-src http://security.ubuntu.com/ubuntu focal-security multiverse
	# This system was installed using small removable media
	# (e.g. netinst, live or single CD). The matching "deb cdrom"
	# entries were disabled at the end of the installation process.
	# For information about how to configure apt package sources,
	# see the sources.list(5) manual.
	deb http://ru.archive.ubuntu.com/ubuntu/ bionic main universe
	:~$ sudo apt-get update
	:~$ sudo apt -y install libwebkitgtk-3.0-0
	Task:
	Создать внешнюю печатную форму
	Decision:
	файл->новый->внешняя обработка->Имя:ЗаказВнешний->Действие->открыть модуль объекта
	Функция СведенияОВнешнейОбработке() Экспорт
	    ПараметрыРегистрации = Новый Структура;
	    МассивНазначений = Новый Массив;
	    МассивНазначений.Добавить("Документ.РеализацияТоваровУслуг"); //Указываем документ к которому делаем внешнюю печ. форму
	    ПараметрыРегистрации.Вставить("Вид", "ПечатнаяФорма"); //может быть - ПечатнаяФорма, ЗаполнениеОбъекта, ДополнительныйОтчет, СозданиеСвязанныхОбъектов...
	    ПараметрыРегистрации.Вставить("Назначение", МассивНазначений);
	    ПараметрыРегистрации.Вставить("Наименование", "Заказ для реализации товаров"); //имя под которым обработка будет зарегестрирована в справочнике внешних обработок
	    ПараметрыРегистрации.Вставить("БезопасныйРежим", ЛОЖЬ);
	    ПараметрыРегистрации.Вставить("Версия", "1.0");
	    ПараметрыРегистрации.Вставить("Информация", "Эту ВПФ мы сделали для того что бы посмотреть возможности БСП ");
	    ТаблицаКоманд = ПолучитьТаблицуКоманд();
	    ДобавитьКоманду(ТаблицаКоманд, "Заказ внешний", "ЗаказВнешний", "ВызовСерверногоМетода", Истина, "ПечатьMXL");
	    ПараметрыРегистрации.Вставить("Команды", ТаблицаКоманд);
	    Возврат ПараметрыРегистрации;
	КонецФункции // СведенияОВнешнейОбработке()
	Функция ПолучитьТаблицуКоманд()
	    Команды = Новый ТаблицаЗначений;
	    Команды.Колонки.Добавить("Представление", Новый ОписаниеТипов("Строка"));//как будет выглядеть описание печ.формы для пользователя
	    Команды.Колонки.Добавить("Идентификатор", Новый ОписаниеТипов("Строка")); //имя макета печ.формы
	    Команды.Колонки.Добавить("Использование", Новый ОписаниеТипов("Строка")); //ВызовСерверногоМетода
	    Команды.Колонки.Добавить("ПоказыватьОповещение", Новый ОписаниеТипов("Булево"));
	    Команды.Колонки.Добавить("Модификатор", Новый ОписаниеТипов("Строка"));
	    Возврат Команды;
	КонецФункции
	Процедура ДобавитьКоманду(ТаблицаКоманд, Представление, Идентификатор, Использование, ПоказыватьОповещение = Ложь, Модификатор = "")
	    НоваяКоманда = ТаблицаКоманд.Добавить();
	    НоваяКоманда.Представление = Представление;
	    НоваяКоманда.Идентификатор = Идентификатор;
	    НоваяКоманда.Использование = Использование;
	    НоваяКоманда.ПоказыватьОповещение = ПоказыватьОповещение;
	    НоваяКоманда.Модификатор = Модификатор;
	КонецПроцедуры
	Процедура Печать(МассивОбъектов, КоллекцияПечатныхФорм, ОбъектыПечати, ПараметрыВывода) Экспорт
	    УправлениеПечатью.ВывестиТабличныйДокументВКоллекцию(
	        КоллекцияПечатныхФорм,
	        "ЗаказВнешний",
	        "Заказ внешний",
	        СформироватьПечатнуюФорму(МассивОбъектов[0], ОбъектыПечати));
	КонецПроцедуры // Печать()
	Функция СформироватьПечатнуюФорму(СсылкаНаОбъект, ОбъектПечати)
	КонецФункции // СформироватьПечатнуюФорму(СсылкаНаОбъект, ОбъектПечати)()

	Макеты->Добавить->Имя: МакетЗаказа->Выделить область->Объединить

	    Заказ на товар № [НомерРеализации] от [ДатаРеализации]

	Свойства->макет->заполнение:шаблон

	    Товар,Количество,Цена,Сумма

	Выделить заполненные ячейки->Таблица->Имя->Назначить имя->Шапка->Скопируем:Товар,Количество,Цена,Сумма->Свойства->Макет->Заполнение->Параметр->Выделить заполненные ячейки->Таблица->Имя->Назначить имя->СтрокаТЧ

	    Итого:, СуммаИтого, Ответственный,Ответственный

	Выделить: СуммаИтого->Свойства->Макет->Заполнение->Параметр->Выделить:Ответственный->Свойства->Макет->Заполнение->Параметр->Выделить заполненные ячейки->Таблица->Имя->Назначить имя->Подвал

	Функция СформироватьПечатнуюФорму(СсылкаНаОбъект, ОбъектПечати)  
	    ТабличныйДокумент = Новый ТабличныйДокумент;
	    МакетОбработки=ПолучитьМакет("МакетЗаказа");
	    ОбластьШапки=МакетОбработки.ПолучитьОбласть("Шапка");
	    ОбластьШапки.Параметры.НомерРеализации=СсылкаНаОбъект.Номер;
	    ОбластьШапки.Параметры.ДатаРеализации=Формат(СсылкаНаОбъект.Дата, )
	КонецФункции

	Конструктор форматной строки->Дата->Локальный формат даты+->Проверим товары,цена,сумма,количество,ответственный в конфигураторе документы->РеализацияТоваровУслуг->Табличные части->Таблицы->товары,цена,сумма,количество->Реквизиты->->Контрагент->Находим объекты

	Функция СформироватьПечатнуюФорму(СсылкаНаОбъект, ОбъектПечати)  
	    ТабличныйДокумент = Новый ТабличныйДокумент;
	    МакетОбработки=ПолучитьМакет("МакетЗаказа");
	    ОбластьШапки=МакетОбработки.ПолучитьОбласть("Шапка");
	    ОбластьШапки.Параметры.НомерРеализации=СсылкаНаОбъект.Номер;
	    ОбластьШапки.Параметры.ДатаРеализации=Формат(СсылкаНаОбъект.Дата, "ДЛФ=DD");
	    ТабличныйДокумент.Вывести(ОбластьШапки);
	    ОбластьСтроки=МакетОбработки.ПолучитьОбласть("СтрокаТЧ");
	    Для каждого ТекущаяСтрока Из СсылкаНаОбъект.Товары Цикл
	        ОбластьСтроки.Параметры.Товар=ТекущаяСтрока.Номенклатура;
	        ОбластьСтроки.Параметры.Цена=ТекущаяСтрока.Цена;
	        ОбластьСтроки.Параметры.Количество=ТекущаяСтрока.Количество;
	        ОбластьСтроки.Параметры.Сумма=ТекущаяСтрока.Сумма;
	        ТабличныйДокумент.Вывести(ОбластьСтроки);   
	    КонецЦикла;
	    ОбластьПодвала=МакетОбработки.ПолучитьОбласть("Подвал");
	    ОбластьПодвала.Параметры.Ответственный=СсылкаНаОбъект.Контрагент;
	    //ОбластьПодвала.Параметры.СуммаИтого=СсылкаНаОбъект.Товары.Итог(Сумма);
	    ТабличныйДокумент.Вывести(ОбластьПодвала);
	    Возврат ТабличныйДокумент;  
	КонецФункции
	Decision:
	НСИ и Администрирование->Печатные формы, отчеты и обработки->Дополнительные отчеты и обработки->Создать->ЗаказВнешний->Записать и закрыть->Продажи->Документ продажи->Печать->ЗаказВнешний
	Source:
	1. https://programmist1s.ru/vneshnie-pechatnyie-formyi-v-1s/
	Task:
	Как хранить картинки
	Для каждого товара, который хранится в справочнике номенклатура, нужно хранить его изображение. То есть пользователь должен иметь возможность в форме нажать на кнопку и выбрать картинку и в резльтате картинка должна отобразиться на форме.
	Decision:
	    Справчоник-номенклатура-реквизиты-добавить-имя-изображение-тип данных - хранилище значений - ок - формы - форма элемента - реквизит - добавить - Имя - адресКартинки - ок - перетаскиваем в группу - вид - поле картинки - гиберссылка + - оформление - размер картинки - пропорциональный - использованиен - текстНе выбраннойКартинки - Нажмите для выбора карнтинки - ок - свойства -адрес Картинки - события - нажатие - на клиенте
	&НаКлиенте
	Процедура АдресКартинкиНажатие(Элемент, СтандартнаяОбработка)
	    //добавляем картинку
	    Оповещение  =  Новый ОписаниеОповещения("АдресКартинкиНажатиеЗавершение", ЭтотОбъект);
	    НачатьПомещениеФайла(Оповещение,,,Истина, УникальныйИдентификатор);
	    СтандартнаяОбработка = Ложь;
	КонецПроцедуры    
	&НаКлиенте
	Процедура АдресКартинкиНажатиеЗавершение(Результат, Адрес, ПомещаемыйФайл, ДополнительныеПараметры) Экспорт
	    Если НЕ Результат Тогда
	        Возврат;
	    КонецЕсли;
	    АдресКартинки=Адрес;
	    Модифицированность=Истина;
	КонецПроцедуры

	Запуск

	    формы - форма элемента - формы - свойства - события - ПередЗаписьюНаСервере

	&НаСервере
	Процедура ПередЗаписьюНаСервере(Отказ, ТекущийОбъект, ПараметрыЗаписи)
	    Если ЭтоАдресВременногоХранилища(АдресКартинки) Тогда
	        ТекущийОбъект.Изображение=Новый ХранилищеЗначения(ПолучитьИзВременногоХранилища(АдресКартинки));
	    КонецЕсли;
	КонецПроцедуры

	    формы - форма элемента - формы - свойства - собыия - ПриСозданииНаСервере

	&НаСервере
	Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)
	    АдресКартинки=ПолучитьНавигационнуюСсылку(Объект.Ссылка, "Изображение");
	КонецПроцедуры

	Запуск

	    формы - форма элемента - добавить команду - ОчиститьИзображение - представление - выбрать картинку - отображение - картинка - ок - перетаскиваем в форму - действие команды - на клиенте

	&НаСервере
	Процедура ПередЗаписьюНаСервере(Отказ, ТекущийОбъект, ПараметрыЗаписи)
	    Если ЭтоАдресВременногоХранилища(АдресКартинки) Тогда
	        ТекущийОбъект.Изображение=Новый ХранилищеЗначения(ПолучитьИзВременногоХранилища(АдресКартинки));
	    КонецЕсли;     
	    Если ПустаяСтрока(АдресКартинки) Тогда
	        ТекущийОбъект.Изображение = Неопределено;
	    КонецЕсли;
	КонецПроцедуры
	&НаСервере
	Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)
	    АдресКартинки=ПолучитьНавигационнуюСсылку(Объект.Ссылка, "Изображение");
	КонецПроцедуры
	&НаКлиенте
	Процедура ОчиститьИзображение(Команда)
	    АдресКартинки="";
	    Модифицированность=Истина;
	КонецПроцедуры
	Task:
	Загрузить данные из внешнего файла в справочник контрагенты.
	Decision:
	Для запуска можно установить 1с учебную версию: online.1c.ru - добавить новую базу - запустить конфигуратор - Администрирование -загрузить базу, выбрав файл с расширением *.dt - запустить
	Обработка-создать-загрузка данных из файла-подсистема--данные-реквизит-добавить-ПутьКФайлу,ФорматФайла-длина строки-256,3-табличная часть-добавить-данные файла-добавить реквизит-наименование,полное наименование,унп-длина строки-150,150,9-формы-добавить форму обработки-везде+, кроме номер строки-ок-камндная панель-свойства--атозаполнение-данные файла-свойства-использование--изменить состав строк-путь к файлу-сфойства-использование-кнопка выбора-да-формат файла-свойства-использование-список выбора-значение-TXT,CSV,XLS,DBF,XML-Основные-Вид-Полеперключателя-Вид переключателя-Тумблер-ок-команды-добавить-ПрочитатьФайл,ЗаписатьДанные-перетаскиваем в командную панель таблицы ДанныеФайла-путь к Файлу-свойства-события-началов выбора-на клиенте

	&НаКлиенте
	Процедура ПутьКФайлуНачалоВыбора(Элемент, ДанныеВыбора, СтандартнаяОбработка)
	    Проводник=Новый ДиалогВыбораФайла(РежимДиалогаВыбораФайла.Открытие);
	    Проводник.Заголовок="Выберитефайл с контрагентами";
	    Если Объект.ФорматФайла="TXT" Тогда
	        Фильтр="Текстовый документ (*.txt)|*.txt";
	    ИначеЕсли Объект.ФорматФайла="CSV" Тогда
	        Фильтр="Текстовый документ (*.csv)|*.csv";
	    ИначеЕсли Объект.ФорматФайла="XLS" Тогда
	        Фильтр="Файл ЕКСЕЛЬ (*.xls)|*.xls";
	    ИначеЕсли Объект.ФорматФайла="DBF" Тогда
	        Фильтр="Таблица DBF (*.dbf)|*.dbf";
	    ИначеЕсли Объект.ФорматФайла="XML" Тогда
	        Фильтр="XML-файл (*.xml)|*.xml";
	    Иначе
	        Возврат;
	    КонецЕсли;
	    Проводник.Фильтр=Фильтр;
	    Оповещение=Новый ОписаниеОповещения("ПослеВыбораФайла", ЭтотОбъект);
	    Проводник.Показать(Оповещение);
	КонецПроцедуры  

	&НаКлиенте
	Процедура ПослеВыбораФайла(ВыбранныеФайлы, ДополнительныеПараметры) Экспорт
	    Если ВыбранныеФайлы=Неопределено Тогда
	        Возврат;
	    КонецЕсли;
	    Объект.ПутьКФайлу=ВыбранныеФайлы[0];
	КонецПроцедуры  
	Task:
	Как вывести штрихкод в печатную форму
	Decision:
	        установить элемент управления «1С: Печать штрихкодов» - its.1c.ru - ок - открыть обработку - макеты - Макет_ТолстыйКлиент - выделить поля от 2 до 8 - таблица -имена - назначить - Штрихкод - таблица - рисунки - вставить объект - мышкой выделяем нужную область в виде прямоугольника - элемент управления - 1сV8 печать штрихкодов - ок на добавленный фрагмент - свойства - КартинкаШтрихкода - оформление - линия - нет линий - ок - формы - ФормаОбычная - вывести штрихкод - ВывестиШтрихкод -

	Процедура ВывестиШтрихкод(Кнопка)    
	        ЭлементыФормы.ТабДок.Очистить(); //1 выполним очистку документа    
	        Макет = ПолучитьМакет("Макет_ТолстыйКлиент"); //2 Получить макет
	        Область = Макет.ПолучитьОбласть("Штрихкод"); //3 получить область макета
	        Область.Рисунки.КартинкаШтрихкода.Объект.ТипКода = 4; //4 обратимся к элементу управления
	        Область.Рисунки.КартинкаШтрихкода.Объект.Сообщение = Штрихкод; //5 необходимо вывести область сообщение
	        ЭлементыФормы.ТабДок.Вывести(Область); //6
	КонецПроцедуры

	        запустить у ее нужно в режиме толстый клиент - сервис - параметры - запуск 1с предприятия - +толстый клиент обычное приложение - ок - запуск
	Task:
	Вывод штрихкода в печатную форму 1С. Тонкий клиент.
	Decision:
	        Загрузить внешнюю компоненту печати штрихкодов в общий макет - its.1c.ru - после установки создать новую информационную базу - общие - общие макеты - копируем в нашу конфигурацию 4 макета (КомпонентаПечатиШтрихкодов....) - смотрим также код в демо конфе справчоник - товары - открыть модуль команды - копируем в нашу конифгурацию код:
	Функция ПолучитьКартинкуШтрихкода()
	        // В зависимости от типа платформы подключим соответствующую внешнюю компоненту
	        ИнформацияОСистеме = Новый СистемнаяИнформация;
	        Если ИнформацияОСистеме.ТипПлатформы = ТипПлатформы.Windows_x86 Тогда
	                ПодключитьВнешнююКомпоненту("ОбщийМакет.КомпонентаПечатиШтрихкодовWindows32", "КартинкаШтрихкода", ТипВнешнейКомпоненты.Native);
	        ИначеЕсли ИнформацияОСистеме.ТипПлатформы = ТипПлатформы.Windows_x86_64 Тогда
	                ПодключитьВнешнююКомпоненту("ОбщийМакет.КомпонентаПечатиШтрихкодовWindows64", "КартинкаШтрихкода", ТипВнешнейКомпоненты.Native);
	        ИначеЕсли ИнформацияОСистеме.ТипПлатформы = ТипПлатформы.Linux_x86 Тогда
	                ПодключитьВнешнююКомпоненту("ОбщийМакет.КомпонентаПечатиШтрихкодовLinux32", "КартинкаШтрихкода", ТипВнешнейКомпоненты.Native);          
	        Иначе
	                ПодключитьВнешнююКомпоненту("ОбщийМакет.КомпонентаПечатиШтрихкодовLinux64", "КартинкаШтрихкода", ТипВнешнейКомпоненты.Native);
	        КонецЕсли;
	        // Создадим объект внешней компоненты
	        Компонент = Новый("AddIn.КартинкаШтрихкода.Barcode");
	        // Если нет возможности рисовать
	        Если НЕ Компонент.ГрафикаУстановлена Тогда
	                // То картинку сформировать не сможем
	                Возврат Неопределено;
	        КонецЕсли;
	        // Если в системе установлен шрифт Tahoma
	        Если Компонент.НайтиШрифт("Tahoma") = Истина Тогда
	                // Выбираем его как шрифт для формирования картинки
	                Компонент.Шрифт = "Tahoma";
	        Иначе
	                // Шрифт Tahoma в системе отсутствует
	                // Обойдем все доступные компоненте шрифты
	                Для Сч = 0 По Компонент.КоличествоШрифтов -1 Цикл
	                        // Получим очередной шрифт, доступный компоненте
	                        ТекущийШрифт = Компонент.ШрифтПоИндексу(Сч);
	                        // Если шрифт доступен
	                        Если ТекущийШрифт <> Неопределено Тогда
	                                // Они и будет шрифтом для формирования штрихкода
	                                Компонент.Шрифт = ТекущийШрифт;
	                                Прервать;
	                        КонецЕсли;
	                КонецЦикла;
	        КонецЕсли;
	        // Установим размер шрифта
	        Компонент.РазмерШрифта = 12;
	        // Зададим размер картинки
	        Компонент.Ширина = 100;
	        Компонент.Высота = 90;
	        // Разрешим компоненте самой определять тип кода
	        Компонент.АвтоТип = Истина;
	        // ИЛИ установим код EAN-13
	        // Компонент.ТипКода = 1;
	        //
	        // Тип смотрим в документации на внешнюю компоненту
	        // Если код содержит контрольный символ, обязательно указываем
	        Компонент.СодержитКС = СтрДлина(ЭтотОбъект.Штрихкод) = 13;
	        // Если отображать контрольный символ не нужно
	        // Компонент.ВидимостьКС = Ложь;
	        // Формируем картинку штрихкода
	        Компонент.ЗначениеКода = ЭтотОбъект.Штрихкод;
	        // Если установленная нами ширина меньше минимально допустимой для этого штрихкода
	        Если Компонент.Ширина < Компонент.МинимальнаяШиринаКода Тогда
	                // Скорректируем ширину
	                Компонент.Ширина = Компонент.МинимальнаяШиринаКода + 10;
	        КонецЕсли;
	        // Сформируем картинку
	        ДвоичныеДанныеКартинки = Компонент.ПолучитьШтрихкод();
	        // Если картинка сформировалась
	        Если НЕ ДвоичныеДанныеКартинки = Неопределено Тогда
	                // Формируем из двоичных данных
	                Возврат Новый Картинка(ДвоичныеДанныеКартинки);
	        КонецЕсли;
	        Возврат Неопределено;
	КонецФункции

	        вставим ее в обработку ВыводШтрихкодаВПечатнуюФорму с директивыой &НаСервере - формы - ФормаУправляемая - Макеты - Макет_ТонкийКлиент - выделим область полей с 2 до 8 - таблица -имена - назначить имя - Штрихкод - наводим на поле - таблица - рисунки - картинка - выбираем картинку с .пнг - свойства картинки - КартинкаШтрихкода - оформление - линия - формы - форма управляемая

	&НаСервере
	Процедура ВывестиШтрихкодНаСервере()
	        ТабДок.Очистить();
	        Макет = РеквизитФормыВЗначение("Объект").ПолучитьМакет("Макет_ТонкийКлиент");
	        Область = Макет.ПолучитьОбласть("Штрихкод");
	        КартинкаШтрихкода = ПолучитьКартинкуШтрихкода(Штрихкод);
	        Если КартинкаШтрихкода <> Неопределено Тогда
	                Область.Рисунки.КартинкаШтрихкода.Картинка = КартинкаШтрихкода;
	        КонецЕсли;
	        ТабДок.Вывести(Область);
	КонецПроцедуры
	&НаКлиенте
	Процедура ВывестиШтрихкод(Команда)
	        ВывестиШтрихкодНаСервере();
	КонецПроцедуры

	        в Функции изменить строку и вместо ЭтотШтрихкод заменить Штрихкод:

	//Функция ПолучитьКартинкуШтрихкода()
	Функция ПолучитьКартинкуШтрихкода(Штрихкод)
	        ...
	        // Формируем картинку штрихкода
	        //Компонент.ЗначениеКода = ЭтотОбъект.Штрихкод;
	        Компонент.ЗначениеКода = Штрихкод;

	        ок - запустить у ее нужно в режиме тонкий клиент - сервис - параметры - запуск 1с предприятия - +Выбрать автоматически - ок - запуск

Мини-проекты
	Task:
	Перечень работ
	1. Разработка проекта БД и реализация его в реляционной СУБД
	2. Создание и модификация БД, занесение  и редактирование данных
	3. Работа с данными
	4. Разработка прикладных программ
	5. Создание меню для пользователя
	Состав проекта БД по предметной области
	1. Графическая диаграмма объектов – связей
	2. Спецификации атрибутов (тип, размер, область допустимых значений (ОДЗ))
	3. Среди типов связей обязательно присутствие типа 1:М
	4. Среди значений ОДЗ должны присутствовать ограничения на числовые атрибуты и значения двух числовых атрибутов
	5. Структура таблиц по БД
	Перечень индивидуальных заданий на развитие программы
	1. Модифицировать программу для поиска по номеру записи.
	2. Модифицировать программу для поиска по числовым полям
	3. Модифицировать программу для поиска по полям типа «дата»
	4. Модифицировать программу для поиска с помощью индексных файлов по символьным полям
	5. Модифицировать программу для поиска с помощью индексных файлов по числовым полям
	6. Модифицировать программу для поиска с помощью индексных файлов по полям типа «дата»
	7. Модифицировать программу для одновременного выбора группы записей, удовлетворяющих критерию на числовые поля
	8. Модифицировать программу для одновременного выбора группы записей, удовлетворяющих критерию на символьные поля
	9. Модифицировать программу для одновременного выбора группы записей, удовлетворяющих критерию на поля тип «дата»
	Перечень индивидуальных заданий по модификации меню
	1. При выборе файла данных предоставить возможность сделать резервную копию
	2. Реализовать разветвленный просмотр файла: всего и группы записей
	3. Удаление данных: группы записей и отдельные записи
	4. Удаление данных: отдельной записи и первой записи
	5. Удаление данных: группы записей, последней записи
	6, 7, 8 Разветвленное редактирование
	9. Удаление данных: пометка к удалению и фактическое удаление
	10. 13. Факультет: кадры
	Фамилии, дом. адреса, телефоны преподавателей и студентов, номера учебных групп студентов с указанием количества студентов в группах, из них – обучаемых с ДОУ; для преподавателей – наименование кафедры и должность. По кафедрам сведения о количестве преподавателей, их должностях, ученых званиях, фамилия и.о. заведующего кафедрой. Для работников деканата выделить  должность и номер рабочего телефона
	В примечаниях: номер аудитории деканата, часы приема заведующего кафедрой, декана и заместителя декана
	Добавляются: по вспомогательному персоналу – фамилии, должности, кафедры.
	Убира.тся: номера телефонов заменяются на 11-значные
	13. Факультет: кадры
	Фамилии, дом. адреса, телефоны преподавателей и студентов, номера учебных групп студентов с указанием количества студентов в группах, из них – обучаемых с ДОУ; для преподавателей – наименование кафедры и должность. По кафедрам сведения о количестве преподавателей, их должностях, ученых званиях, фамилия и.о. заведующего кафедрой. Для работников деканата выделить  должность и номер рабочего телефона
	В примечаниях: номер аудитории деканата, часы приема заведующего кафедрой, декана и заместителя декана
	Добавляются: по вспомогательному персоналу – фамилии, должности, кафедры.
	Убира.тся: номера телефонов заменяются на 11-значные
	13. Факультет: кадры
	Фамилии, дом. адреса, телефоны преподавателей и студентов, номера учебных групп студентов с указанием количества студентов в группах, из них – обучаемых с ДОУ; для преподавателей – наименование кафедры и должность. По кафедрам сведения о количестве преподавателей, их должностях, ученых званиях, фамилия и.о. заведующего кафедрой. Для работников деканата выделить  должность и номер рабочего телефона
	В примечаниях: номер аудитории деканата, часы приема заведующего кафедрой, декана и заместителя декана
	Добавляются: по вспомогательному персоналу – фамилии, должности, кафедры.
	Убираются: номера телефонов заменяются на 11-значные
	14. Аудиторные занятия. Учебный процесс
	Фамилии, дом. адреса, телефоны студентов, номера учебных групп с количеством студентов в них, в том числе обучающихся на условиях ПВЗ, наименования дисциплин с количеством часов, из них лекционных, практических, лабораторных. Для преподавателей также кафедра и должность, ч указанием дисциплин, которые он ведет. Для групп указать, какие  дисциплины ведутся, в каком семестре, номер аудитории
	В примечаниях: список литературы по дисциплинам
	Добавляются: перечень лабораторных работ по дисциплинам с лабораторным практикумами, номер учебной лаборатории
	Убираются: номер аудитории.
	14. Аудиторные занятия. Учебный процесс
	Фамилии, дом. адреса, телефоны студентов, номера учебных групп с количеством студентов в них, в том числе обучающихся на условиях ПВЗ, наименования дисциплин с количеством часов, из них лекционных, практических, лабораторных. Для преподавателей также кафедра и должность, ч указанием дисциплин, которые он ведет. Для групп указать, какие  дисциплины ведутся, в каком семестре, номер аудитории
	В примечаниях: список литературы по дисциплинам
	Добавляются: перечень лабораторных работ по дисциплинам с лабораторным практикумами, номер учебной лаборатории
	Убираются: номер аудитории.
	14. Аудиторные занятия. Учебный процесс
	Фамилии, дом. адреса, телефоны студентов, номера учебных групп с количеством студентов в них, в том числе обучающихся на условиях ПВЗ, наименования дисциплин с количеством часов, из них лекционных, практических, лабораторных. Для преподавателей также кафедра и должность, ч указанием дисциплин, которые он ведет. Для групп указать, какие  дисциплины ведутся, в каком семестре, номер аудитории
	В примечаниях: список литературы по дисциплинам
	Добавляются: перечень лабораторных работ по дисциплинам с лабораторным практикумами, номер учебной лаборатории
	Убираются: номер аудитории.
	Decision:
	https://github.com/David138it/MyPortfolio/tree/main/TaskDecision/Engineer-Isu/Sql/UniversityStructure/
	Task:
	Создайте таблицу de13ma.XXXX_SALARY_HIST, где XXXX - ваш идентификатор. В таблице должна быть SCD2 версия таблицы de.HISTGROUP (поля PERSON, CLASS, SALARY, EFFECTIVE_FROM, EFFECTIVE_TO). Возьмите в работу таблицы
	de13ma.XXXX_SALARY_HIST и de.SALARY_PAYMENTS. Напишите SQL скрипт, выводящий таблицу платежей сотрудникам. В таблице должны быть поля PAYMENT_DT, PERSON, PAYMENT, MONTH_PAID, MONTH_REST. Результат выполнения сохраните в таблицу de13ma.XXXX_SALARY_LOG.
	1. MONTH_PAID - суммарно выплачено в месяце,
	2. MONTH_REST - осталось выплатить за месяц.
	Проверяется в первую очередь понимание как соединять фактовую таблицу с SCD2 таблицей (нельзя все расчеты сделать над DE.SALARY_PAYMENTS, ведь работнику могут недоплатить или переплатить).
	В ответе приложите SQL-скрипт, таблица de13ma.XXXX_SALARY_LOG должна быть заполнена.
	Decision:
	$ cat Sql-Gabn_SALARY_LOG6.sql
	create table de13ma.gabn_SALARY_HIST as (
		select 
			PERSON,
			CLASS,
			SALARY,
			dt as effective_from,
			coalesce((
				lead(dt) 
				over (
					partition by person 
					order by dt) - interval '1 day')::date,  
				to_date('9999-12-31', 'YYYY-MM-DD')) as effective_to
		from de.HISTGROUP);
	--select * from de13ma.gabn_SALARY_HIST;
	--select * from de.SALARY_PAYMENTS;
	create table de13ma.gabn_SALARY_LOG as (
		select --*--,
			dgsh.person as PERSON,
			dsp.dt as PAYMENT_DT,
			dsp.payment as PAYMENT,
			--sum(dsp2.payment) as MONTH_PAID,
			--sum(dsp.payment) over (order by dsp.dt between dgsh.effective_from and dgsh.effective_to) as MONTH_PAID,
			sum(dsp.payment) over (partition by dsp.payment order by dsp.dt) as MONTH_PAID,
			dgsh.salary-sum(dsp.payment) as MONTH_REST--,
			--dgsh.salary
		from de13ma.GABN_SALARY_HIST as dgsh
		inner join de.SALARY_PAYMENTS as dsp 
			on dgsh.person=dsp.person 
		--inner join de.SALARY_PAYMENTS as dsp2 
		--	on dsp.dt >= dsp2.dt
		where dsp.dt between dgsh.effective_from and dgsh.effective_to
		group by dgsh.person,
			dsp.dt,
			dsp.payment,
			dgsh.salary--,
			--dgsh.effective_from,
			--dgsh.effective_to
		order by dgsh.person,
			dsp.dt);
	select * from de13ma.gabn_SALARY_LOG;
	Task:
	На основании таблиц DE.LOG и DE.IP постройте структурированную таблицу посещений DE13MA.XXXX_LOG ( DT DATE, LINK VARCHAR( 50 ), USER_AGENT VARCHAR( 200 ), REGION VARCHAR( 30 ) ). Также постройте отчет DE13MA.XXXX_LOG_REPORT ( REGION VARCHAR( 30 ), BROWSER VARCHAR( 10 ) ) – в каких областях какой браузер является наиболее используемым.
	Под USER_AGENT подразумевается вся строка описания клиента, под BROWSER – только название браузера (Opera, Safari…). XXXX означает ваши 4 уникальные буквы.
	Важные замечания (вплоть до причины незачета задания):
	1. Не используйте регулярные выражения там, где можно обойтись без них.
	2. То, что вы видите в выводе клиента – это не всегда именно то, что содержится в базе данных.
	Decision:
	$ cat Sql-Gabn_LOG3.sql
	create table DE13MA.GABN_LOG as (
		select 
			to_date (substring (dl.data from '\d{8}'), 'YYYYMMDD') as DT,
			cast (split_part (substring (replace (substring (dl.data, strpos (dl.data, 'http://')), chr(9), '+'), 1, strpos (replace (substring (dl.data, strpos(dl.data, 'http://')), chr(9), '|'), '/5.0') -1), '+', 1) as VARCHAR(50)) LINK,
			cast (split_part (replace (substring (dl.data from 1), chr(9), '+'), '+', 8 ) as VARCHAR(200)) USER_AGENT,
			cast (split_part (di.data, chr(9), 2) as VARCHAR(30)) REGION
		from de.log as dl
		left join de.ip as di
		on
			substring (dl.data, 1, strpos (dl.data, chr(9))) = 
				substring (di.data, 1, strpos (di.data, chr(9))));
	select * from DE13MA.GABN_LOG;
	$ cat Sql-Gabn_LOG_REPORTS3.sql
	create table DE13MA.GABN_LOG_REPORT as (SELECT
			region, 
			browser--, 
			--cnt
		FROM (select
			t1.* , 
			ROW_NUMBER() OVER (PARTITION BY region ORDER BY cnt DESC) as numb
		FROM (select 
				cast (split_part (di.data, chr(9), 2) as VARCHAR(30)) REGION, 
				cast (split_part (substring (replace (substring (dl.data, strpos(dl.data, 'http://')), chr(9), '+'), 1, strpos (replace (substring (dl.data, strpos (dl.data, 'http://')), chr(9), '|'), '/5.0') -1), '+', 4) as VARCHAR(10)) BROWSER,
				count(1) as cnt
			from de.log as dl
			--order by dl.data
			left join de.ip as di
			--on dl.data=di.data;
			on 
				substring (dl.data, 1, strpos (dl.data, chr(9))) =
					substring (di.data, 1, strpos (di.data, chr(9)))	
			--order by region
			group by region, browser) 
			as t1)
		as t2
		WHERE numb = 1);
	select * from DE13MA.GABN_LOG_REPORT;
	Task:
	Создайте структуру базы данных по одной из предложенных тематик.
	К базе данных предъявляются следующие требования:
	1. должно быть не менее 4 сущностей (включая технические объекты);
	2. должна быть хотя бы одна связь один-ко-многим
	3. должна быть хотя бы одна связь многие-ко-многим;
	4. все отношения приведены к 3НФ.
	Предметная область:
	1. Продажа автомобилей.
	2. Приют для животных.
	3. Железнодорожные перевозки.
	4. Служба доставки.
	5. Организация марафона.
	Требования к оформлению:
	ER-диаграмму необходимо составлять на app.dbdesigner.net, на проверку нужно присылать ссылку на диаграмму. Также необходимо сделать таблицу в Google Sheets с примерами данных в таблицах.
	Возьмите в работу ER-диаграмму, разработанную вами. Разработайте DDL для нее. Создайте файл Sql-Ddl2.sql, в котором должно быть:
	1. DDL создания всех таблиц, с правильным указанием имен, типов и ограничений целостности.
	2. Для каждой таблицы приведите 2-3 команды INSERT для наполнения данных. Обращайте внимание на типизацию вставляемых данны
	Decision:
	$ cat Sql-Ddl2.sql
	CREATE TABLE de13ma.gabn_dz2_brands (
	id_brand SERIAL PRIMARY KEY,
	title VARCHAR (255)
	);
	INSERT INTO de13ma.gabn_dz2_brands (title) VALUES 
	('Nissan'),
	('Chevrolet'),
	('Datsun'),
	('Hyundai'),
	('Lada');
	CREATE TABLE de13ma.gabn_dz2_transmittion_box (
	id_box SERIAL PRIMARY KEY,
	title VARCHAR (255)
	);
	INSERT INTO de13ma.gabn_dz2_transmittion_box (title) VALUES 
	('Автомат'),
	('Механика'),
	('Вариатор');
	CREATE TABLE de13ma.gabn_dz2_country_partner (
	id_country SERIAL PRIMARY KEY,
	title VARCHAR (255)
	);
	INSERT INTO de13ma.gabn_dz2_country_partner (title) VALUES 
	('Russia'),
	('Japane'),
	('USA'),
	('South Korea');
	CREATE TABLE de13ma.gabn_dz2_clients (
	id_client SERIAL PRIMARY KEY,
	fio VARCHAR (255),
	phone VARCHAR (255),
	city VARCHAR (255)
	);
	INSERT INTO de13ma.gabn_dz2_clients 
	(fio, phone, city) 
	VALUES 
	('David', '88886666000', 'Kutaisi'),
	('Angelina', '88880000665', 'Irkutsk'),
	('Leonid', '88886666111', 'Irkutsk');
	CREATE TABLE de13ma.gabn_dz2_cars (
	id_car SERIAL PRIMARY KEY,
	id_brand INT REFERENCES de13ma.gabn_dz2_brands(id_brand),
	model VARCHAR (255),
	price NUMERIC,
	releases TIMESTAMP,
	id_box INT REFERENCES de13ma.gabn_dz2_transmittion_box(id_box),
	id_country INT REFERENCES de13ma.gabn_dz2_country_partner(id_country)
	);
	INSERT INTO de13ma.gabn_dz2_cars (id_brand, model, price, releases, id_box, id_country) VALUES 
	(1, 'Windgroad', 250000, '2006-09-12 12:12:12', 1, 2),
	(2, 'Aveo', 450000, '2013-09-12 12:12:12', 3, 3),
	(3, 'On-do', 300000, '2015-09-12 12:12:12', 2, 2),
	(4, 'Solaris1', 750000, '2017-09-12 12:12:12', 1, 4),
	(4, 'Solaris2', 900000, '2020-09-12 12:12:12', 1, 4),
	(5, 'Vesta', 850000, '2021-09-12 12:12:12', 3, 1);
	CREATE TABLE de13ma.gabn_dz2_sale (
	id_sale SERIAL PRIMARY KEY,
	id_car INT REFERENCES de13ma.gabn_dz2_cars(id_car),
	id_client INT REFERENCES de13ma.gabn_dz2_clients(id_client),
	dates TIMESTAMP
	);
	INSERT INTO de13ma.gabn_dz2_sale (id_car, id_client, dates) VALUES 
	(1, 1, '2006-09-12 12:12:12'),
	(2, 2, '2014-09-12 12:12:12'),
	(3, 1, '2015-09-12 12:12:12'),
	(4, 2, '2017-09-12 12:12:12'),
	(5, 3, '2020-09-12 12:12:12'),
	(6, 1, '2021-09-12 12:12:12');
	SELECT * from de13ma.gabn_dz2_sale;
	Task:
	Необходимо разработать БД для хранения данных сервиса выдачи VPN-ключей пользователям:
	1. У пользователя может быть несколько устройств. Для каждого устройства создается свой VPN-ключ, использование одного ключа на 2 и более устройствах не допускается.
	2. Ресурсы организации, к которым даётся доступ, объединяются в VPN-группы. Одному VPN-ключу может назначаться несколько VPN-групп.
	3. Разные устройства пользователя могут обладать разными правами доступа к инфраструктуре организации.
	4. Права доступа на ключ пользователя назначает VPN-администратор.
	5. Организация разделена на департаменты. В каждом департаменте имеются свои VPN-администраторы, которые могут давать доступ любому ключу, но только на ресурсы своего департамента. VPN-администратор может числиться в нескольких департаментах.
	6. Все действия VPN-администраторов должны записываться.
	Результат следует представить в виде SQL-запросов для создания таблиц и реляционной модели данной БД (схема или рисунок).
	Task:
	Модель базы данных:
	1. Пользователь – репрезентация пользователей в приложении. Должны быть обычные и админ пользователи (админ назначается руками в базе или создаётся на старте приложения)
	2. Товар – Состоит из заголовка, описания и цены
	3. Счёт – Имеет идентификатор счёта и баланс. Привязан к пользователю. У пользователя может быть несколько счетов
	4. Транзакция – история зачисления на счёт, хранит сумму зачисления и идентификатор счёта
	Функциональные критерии:
	Весь описываемый ниже функционал должен быть осуществлён в формате REST API. Работа с шаблонами, HTML или фронтендом в любой форме не предусматривается.
	Пользователь может:
	1. Регистрация (по паролю и логину, возвращает ссылку активации)
	2. Логин
	3. Просмотр списка товаров
	4. Покупка товара, просто списывает с баланса стоимость товара, при условии наличия на балансе счёта достаточного количества средств
	5. Просмотр баланса всех счетов и историю транзакций
	6. Зачисление средств на счёт, выполняется с помощью эндпоинта [POST] /payment/webhook симулирует начисление со стороннего сервиса.
	Пример тела вебхука, с транзакцией (формат json):
	{
		“signature”: “f4eae5b2881d8b6a1455f62502d08b2258d80084”,
		“transaction_id”: 1234567,
		“user_id”: 123456,
		“bill_id”: 123456,
		“amount”: 100
	}
	Сигнатура формируются по правилу:
	from Crypto.Hash import SHA1 
	signature = SHA1.new()\
	.update(f'{private_key}:{transaction_id}:{user_id}:{bill_id}:{amount}'.encode())\
	.hexdigest()
	Где private_key – приватный ключ, задаётся в свойствах приложения, transaction_id – уникальный идентификатор транзакции, user_id – пользователь на чеё счёт произойдёт зачисление, bill_id – идентификатор счёта (если счёта с таким айди не существует, то но должен быть создан), amount – сумма транзакции.
	Возможности админа:
	1. Видеть все товары
	2. Видеть всех пользователей и их счета
	3. Включать/отключать пользователей
	4. Создавать/редактировать/удалять товары
	Не функциональные критерии
	1. Логины пользователей уникальны
	2. После регистрации пользователь создаётся в не активном состоянии. Становится активным переходя по ссылке полученной с регистрации
	3. Авторизация должна быть сделана через JWT. Защищённые эндпоинты должны получать токен в заголовке Authorization в Bearer формате
	Время выполнения задачи желательно не более 7 дней.
	Выполнить задачу с учётом особенностей асинхронной обработки данных. В особенности это касается обработки транзакций, приложение должно быть способно обработать сравнительно большой объём параллельных запросов (с поправкой на технические характеристики сервера).
